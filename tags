!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.8	//
A	macros/maze/maze.c	/^char*M,A,Z,E=40,J[40],T[40];main(C){for(*J=A=scanf(M="%d",&C);$/;"	v
A	macros/maze/mazeansi.c	/^char*M,A,Z,E=40,J[80],T[3];main(C){for(M=J+E,*J=A=scanf("%d",&$/;"	v
ABBREV	src/vim.h	207;"	d
ABBR_OFF	src/keymap.h	40;"	d
ACTION_EXPAND	src/vim.h	258;"	d
ACTION_GOTO	src/vim.h	254;"	d
ACTION_SHOW	src/vim.h	253;"	d
ACTION_SHOW_ALL	src/vim.h	256;"	d
ACTION_SPLIT	src/vim.h	255;"	d
ALIGN_LONG	src/structs.h	120;"	d
ALIGN_MASK	src/structs.h	126;"	d
ALIGN_SIZE	src/structs.h	121;"	d
ALIGN_SIZE	src/structs.h	123;"	d
ALL_CFLAGS	src/Makefile	/^ALL_CFLAGS = $(DEFS) $(GUI_DEFS) $(EXTRA_DEFS) $(GUI_IPATH) $(CFLAGS) $(X_CFLAGS)$/;"	m
ALL_GUI_INCL	src/Makefile	/^ALL_GUI_INCL = gui.h gui_at_sb.h$/;"	m
ALL_GUI_PRO	src/Makefile	/^ALL_GUI_PRO  = gui.pro gui_motif.pro gui_athena.pro gui_x11.pro$/;"	m
ALL_GUI_SRC	src/Makefile	/^ALL_GUI_SRC  = gui.c gui_motif.c gui_x11.c gui_athena.c gui_at_sb.c$/;"	m
ALL_INCL	src/Makefile	/^ALL_INCL = $(BASIC_INCL) $(ALL_GUI_INCL)$/;"	m
ALL_LIBS	src/Makefile	/^ALL_LIBS = $(GUI_LIBS_DIR) $(X_LIBS_DIR) $(GUI_LIBS) $(X_PRE_LIBS) $(GUI_X_LIBS) $(X_LIBS) $(X_EXTRA_LIBS) $(LIBS) $(EXTRA_LIBS)$/;"	m
ALL_SRC	src/Makefile	/^ALL_SRC = $(BASIC_SRC) $(ALL_GUI_SRC)$/;"	m
ANY	src/regexp.c	102;"	d	file:
ANYBUT	src/regexp.c	104;"	d	file:
ANYOF	src/regexp.c	103;"	d	file:
APPENDBIN	src/vim.h	424;"	d
APPENDBIN	src/vim.h	428;"	d
ASKMORE	src/vim.h	205;"	d
ATHENA_COMMENT	src/config.mk	/^ATHENA_COMMENT = ZZZ$/;"	m
AUTOCMD	src/feature.h	69;"	d
AppendCharToRedobuff	src/getchar.c	/^AppendCharToRedobuff(c)$/;"	f
AppendNumberToRedobuff	src/getchar.c	/^AppendNumberToRedobuff(n)$/;"	f
AppendToRedobuff	src/getchar.c	/^AppendToRedobuff(s)$/;"	f
AutoCmd	src/option.c	/^typedef struct AutoCmd$/;"	s	file:
AutoCmd	src/option.c	/^} AutoCmd;$/;"	t	typeref:struct:AutoCmd	file:
AutoPat	src/option.c	/^typedef struct AutoPat$/;"	s	file:
AutoPat	src/option.c	/^} AutoPat;$/;"	t	typeref:struct:AutoPat	file:
B0_FNAME_SIZE	src/memline.c	152;"	d	file:
B0_HNAME_SIZE	src/memline.c	154;"	d	file:
B0_MAGIC_CHAR	src/memline.c	163;"	d	file:
B0_MAGIC_INT	src/memline.c	161;"	d	file:
B0_MAGIC_LONG	src/memline.c	160;"	d	file:
B0_MAGIC_SHORT	src/memline.c	162;"	d	file:
B0_UNAME_SIZE	src/memline.c	153;"	d	file:
BACK	src/regexp.c	108;"	d	file:
BACKREF	src/regexp.c	129;"	d	file:
BACKSLASH	tools/ctags/ctags.c	134;"	d	file:
BACKSLASH_IN_FILENAME	src/conf_os2.h	6;"	d
BACKSLASH_IN_FILENAME	src/msdos.h	15;"	d
BACKSPACE_CHAR	src/edit.c	54;"	d	file:
BACKSPACE_LINE	src/edit.c	57;"	d	file:
BACKSPACE_WORD	src/edit.c	55;"	d	file:
BACKSPACE_WORD_NOT_SPACE	src/edit.c	56;"	d	file:
BACKWARD	src/vim.h	211;"	d
BAD_GETCWD	src/conf_os2.h	107;"	d
BANG	src/cmdtab.h	16;"	d
BASENAMELEN	src/msdos.h	105;"	d
BASENAMELEN	src/msdos.h	107;"	d
BASENAMELEN	src/unix.h	228;"	d
BASIC_INCL	src/Makefile	/^BASIC_INCL = vim.h globals.h option.h keymap.h macros.h ascii.h term.h unix.h \\$/;"	m
BASIC_SRC	src/Makefile	/^BASIC_SRC =	alloc.c buffer.c charset.c \\$/;"	m
BC	src/term.c	/^char *UP, *BC, PC;$/;"	v
BHDR	src/structs.h	/^typedef struct block_hdr	BHDR;$/;"	t	typeref:struct:block_hdr
BH_DIRTY	src/structs.h	185;"	d
BH_LOCKED	src/structs.h	186;"	d
BINARY_FILE_IO	atari/src/mint.h	13;"	d
BINARY_FILE_IO	src/conf_os2.h	7;"	d
BINARY_FILE_IO	src/msdos.h	16;"	d
BINLOC	src/Makefile	/^BINLOC = $(EXEC_PREFIX)\/bin$/;"	m
BINMOD	src/Makefile	/^BINMOD = 755$/;"	m
BIN_ASSIGN	tools/xxd/xxd.c	58;"	d	file:
BIN_ASSIGN	tools/xxd/xxd.c	62;"	d	file:
BIN_READ	tools/xxd/xxd.c	56;"	d	file:
BIN_READ	tools/xxd/xxd.c	60;"	d	file:
BIN_WRITE	tools/xxd/xxd.c	57;"	d	file:
BIN_WRITE	tools/xxd/xxd.c	61;"	d	file:
BIOSTICK	src/msdos.c	76;"	d	file:
BLOCK0_ID0	src/memline.c	92;"	d	file:
BLOCK0_ID1	src/memline.c	93;"	d	file:
BOL	src/regexp.c	100;"	d	file:
BOTH_DIRECTIONS	src/vim.h	212;"	d
BOW	src/regexp.c	115;"	d	file:
BRACE_AT_END	src/misccmds.c	2663;"	d	file:
BRACE_AT_START	src/misccmds.c	2662;"	d	file:
BRACE_IN_COL0	src/misccmds.c	2661;"	d	file:
BRANCH	src/regexp.c	106;"	d	file:
BREAKCHECK_SKIP	src/misccmds.c	3849;"	d	file:
BREAKCHECK_SKIP	src/msdos.h	37;"	d
BROKEN_TOUPPER	src/conf_os2.h	98;"	d
BSIZE	src/term.c	1538;"	d	file:
BSIZE	src/term.c	1539;"	d	file:
BT_EXTRA_KEYS	src/term.c	73;"	d	file:
BUF	src/structs.h	/^typedef struct buffer BUF;$/;"	t	typeref:struct:buffer
BUFNAME	src/cmdtab.h	31;"	d
BUFSIZE	src/fileio.c	29;"	d	file:
Buffer	tools/ctags/ctags.c	/^} Buffer;$/;"	v	typeref:struct:__anon16	file:
CASE_INSENSITIVE_FILENAME	src/conf_os2.h	4;"	d
CASE_INSENSITIVE_FILENAME	src/msdos.h	13;"	d
CC	src/Makefile	/^	CC="$(CC) $(ALL_CFLAGS)" srcdir=${srcdir} sh $(srcdir)\/osdef.sh$/;"	m
CC	src/Makefile	/^CC=$/;"	m
CC	src/config.mk	/^CC = gcc$/;"	m
CFLAGS	src/Makefile	/^CFLAGS = -g$/;"	m
CFLAGS	src/config.mk	/^CFLAGS = -g -O -Wall -Wshadow$/;"	m
CFLAGS	tools/ctags/Makefile	/^CFLAGS = -O$/;"	m
CHANGE	src/ops.h	19;"	d
CHANGED	src/vim.h	441;"	d
CHAR_BOLD	src/vim.h	186;"	d
CHAR_ID	src/charset.c	25;"	d	file:
CHAR_IF	src/charset.c	26;"	d	file:
CHAR_INVERT	src/vim.h	184;"	d
CHAR_ITALIC	src/vim.h	188;"	d
CHAR_MASK	src/charset.c	24;"	d	file:
CHAR_NORMAL	src/vim.h	183;"	d
CHAR_STDOUT	src/vim.h	187;"	d
CHAR_UNDERL	src/vim.h	185;"	d
CHECK	src/memfile.c	10;"	d	file:
CHECK	src/memline.c	11;"	d	file:
CHECK_INODE	src/unix.h	217;"	d
CHECK_INODE	src/vim.h	89;"	d
CHECK_PATH	src/vim.h	251;"	d
CINDENT	src/feature.h	127;"	d
CLEAR	src/vim.h	178;"	d
CMDBUFFSIZE	src/unix.h	214;"	d
CMDBUFFSIZE	src/vim.h	399;"	d
CMDLINE	src/vim.h	200;"	d
CMD_Next	src/cmdtab.h	274;"	d
CMD_SIZE	src/cmdtab.h	445;"	d
CMD_abbreviate	src/cmdtab.h	56;"	d
CMD_abclear	src/cmdtab.h	58;"	d
CMD_all	src/cmdtab.h	54;"	d
CMD_and	src/cmdtab.h	442;"	d
CMD_append	src/cmdtab.h	52;"	d
CMD_args	src/cmdtab.h	60;"	d
CMD_argument	src/cmdtab.h	62;"	d
CMD_ascii	src/cmdtab.h	64;"	d
CMD_at	src/cmdtab.h	432;"	d
CMD_autocmd	src/cmdtab.h	66;"	d
CMD_bNext	src/cmdtab.h	82;"	d
CMD_ball	src/cmdtab.h	70;"	d
CMD_bang	src/cmdtab.h	434;"	d
CMD_bdelete	src/cmdtab.h	74;"	d
CMD_blast	src/cmdtab.h	88;"	d
CMD_bmodified	src/cmdtab.h	78;"	d
CMD_bnext	src/cmdtab.h	80;"	d
CMD_bprevious	src/cmdtab.h	84;"	d
CMD_brewind	src/cmdtab.h	86;"	d
CMD_buffer	src/cmdtab.h	68;"	d
CMD_buffers	src/cmdtab.h	72;"	d
CMD_bunload	src/cmdtab.h	76;"	d
CMD_cNext	src/cmdtab.h	120;"	d
CMD_cabbrev	src/cmdtab.h	92;"	d
CMD_cabclear	src/cmdtab.h	94;"	d
CMD_cc	src/cmdtab.h	96;"	d
CMD_cd	src/cmdtab.h	98;"	d
CMD_center	src/cmdtab.h	100;"	d
CMD_cfile	src/cmdtab.h	102;"	d
CMD_change	src/cmdtab.h	90;"	d
CMD_chdir	src/cmdtab.h	104;"	d
CMD_checkpath	src/cmdtab.h	106;"	d
CMD_clist	src/cmdtab.h	108;"	d
CMD_close	src/cmdtab.h	110;"	d
CMD_cmap	src/cmdtab.h	112;"	d
CMD_cmapclear	src/cmdtab.h	114;"	d
CMD_cmenu	src/cmdtab.h	116;"	d
CMD_cnext	src/cmdtab.h	118;"	d
CMD_cnoreabbrev	src/cmdtab.h	126;"	d
CMD_cnoremap	src/cmdtab.h	122;"	d
CMD_cnoremenu	src/cmdtab.h	124;"	d
CMD_copy	src/cmdtab.h	128;"	d
CMD_cprevious	src/cmdtab.h	130;"	d
CMD_cquit	src/cmdtab.h	132;"	d
CMD_cunabbrev	src/cmdtab.h	138;"	d
CMD_cunmap	src/cmdtab.h	134;"	d
CMD_cunmenu	src/cmdtab.h	136;"	d
CMD_delete	src/cmdtab.h	140;"	d
CMD_digraphs	src/cmdtab.h	144;"	d
CMD_display	src/cmdtab.h	142;"	d
CMD_djump	src/cmdtab.h	146;"	d
CMD_dlist	src/cmdtab.h	148;"	d
CMD_doautocmd	src/cmdtab.h	150;"	d
CMD_dsearch	src/cmdtab.h	152;"	d
CMD_dsplit	src/cmdtab.h	154;"	d
CMD_edit	src/cmdtab.h	156;"	d
CMD_equal	src/cmdtab.h	440;"	d
CMD_ex	src/cmdtab.h	158;"	d
CMD_exit	src/cmdtab.h	160;"	d
CMD_file	src/cmdtab.h	162;"	d
CMD_files	src/cmdtab.h	164;"	d
CMD_fixdel	src/cmdtab.h	166;"	d
CMD_global	src/cmdtab.h	168;"	d
CMD_gui	src/cmdtab.h	170;"	d
CMD_gvim	src/cmdtab.h	172;"	d
CMD_help	src/cmdtab.h	174;"	d
CMD_iabbrev	src/cmdtab.h	178;"	d
CMD_iabclear	src/cmdtab.h	180;"	d
CMD_ijump	src/cmdtab.h	182;"	d
CMD_ilist	src/cmdtab.h	184;"	d
CMD_imap	src/cmdtab.h	186;"	d
CMD_imapclear	src/cmdtab.h	188;"	d
CMD_imenu	src/cmdtab.h	190;"	d
CMD_inoreabbrev	src/cmdtab.h	196;"	d
CMD_inoremap	src/cmdtab.h	192;"	d
CMD_inoremenu	src/cmdtab.h	194;"	d
CMD_insert	src/cmdtab.h	176;"	d
CMD_isearch	src/cmdtab.h	198;"	d
CMD_isplit	src/cmdtab.h	200;"	d
CMD_iunabbrev	src/cmdtab.h	206;"	d
CMD_iunmap	src/cmdtab.h	202;"	d
CMD_iunmenu	src/cmdtab.h	204;"	d
CMD_join	src/cmdtab.h	208;"	d
CMD_jumps	src/cmdtab.h	210;"	d
CMD_k	src/cmdtab.h	212;"	d
CMD_last	src/cmdtab.h	216;"	d
CMD_left	src/cmdtab.h	218;"	d
CMD_list	src/cmdtab.h	214;"	d
CMD_ls	src/cmdtab.h	220;"	d
CMD_lshift	src/cmdtab.h	436;"	d
CMD_make	src/cmdtab.h	232;"	d
CMD_map	src/cmdtab.h	228;"	d
CMD_mapclear	src/cmdtab.h	230;"	d
CMD_mark	src/cmdtab.h	224;"	d
CMD_marks	src/cmdtab.h	226;"	d
CMD_menu	src/cmdtab.h	234;"	d
CMD_mfstat	src/cmdtab.h	240;"	d
CMD_mkexrc	src/cmdtab.h	236;"	d
CMD_mkvimrc	src/cmdtab.h	238;"	d
CMD_mode	src/cmdtab.h	242;"	d
CMD_move	src/cmdtab.h	222;"	d
CMD_new	src/cmdtab.h	246;"	d
CMD_next	src/cmdtab.h	244;"	d
CMD_nmap	src/cmdtab.h	248;"	d
CMD_nmapclear	src/cmdtab.h	250;"	d
CMD_nmenu	src/cmdtab.h	252;"	d
CMD_nnoremap	src/cmdtab.h	254;"	d
CMD_nnoremenu	src/cmdtab.h	256;"	d
CMD_noreabbrev	src/cmdtab.h	266;"	d
CMD_noremap	src/cmdtab.h	262;"	d
CMD_noremenu	src/cmdtab.h	264;"	d
CMD_normal	src/cmdtab.h	268;"	d
CMD_number	src/cmdtab.h	258;"	d
CMD_nunmap	src/cmdtab.h	270;"	d
CMD_nunmenu	src/cmdtab.h	272;"	d
CMD_only	src/cmdtab.h	278;"	d
CMD_open	src/cmdtab.h	276;"	d
CMD_pop	src/cmdtab.h	282;"	d
CMD_pound	src/cmdtab.h	260;"	d
CMD_preserve	src/cmdtab.h	286;"	d
CMD_previous	src/cmdtab.h	288;"	d
CMD_print	src/cmdtab.h	280;"	d
CMD_put	src/cmdtab.h	284;"	d
CMD_pwd	src/cmdtab.h	290;"	d
CMD_qall	src/cmdtab.h	294;"	d
CMD_quit	src/cmdtab.h	292;"	d
CMD_read	src/cmdtab.h	296;"	d
CMD_recover	src/cmdtab.h	300;"	d
CMD_redo	src/cmdtab.h	302;"	d
CMD_registers	src/cmdtab.h	304;"	d
CMD_resize	src/cmdtab.h	306;"	d
CMD_retab	src/cmdtab.h	308;"	d
CMD_rewind	src/cmdtab.h	298;"	d
CMD_right	src/cmdtab.h	310;"	d
CMD_rshift	src/cmdtab.h	438;"	d
CMD_rviminfo	src/cmdtab.h	312;"	d
CMD_sNext	src/cmdtab.h	350;"	d
CMD_sall	src/cmdtab.h	318;"	d
CMD_sargument	src/cmdtab.h	316;"	d
CMD_sbNext	src/cmdtab.h	328;"	d
CMD_sball	src/cmdtab.h	322;"	d
CMD_sblast	src/cmdtab.h	334;"	d
CMD_sbmodified	src/cmdtab.h	324;"	d
CMD_sbnext	src/cmdtab.h	326;"	d
CMD_sbprevious	src/cmdtab.h	330;"	d
CMD_sbrewind	src/cmdtab.h	332;"	d
CMD_sbuffer	src/cmdtab.h	320;"	d
CMD_set	src/cmdtab.h	338;"	d
CMD_shell	src/cmdtab.h	340;"	d
CMD_slast	src/cmdtab.h	356;"	d
CMD_sleep	src/cmdtab.h	342;"	d
CMD_snext	src/cmdtab.h	348;"	d
CMD_source	src/cmdtab.h	344;"	d
CMD_split	src/cmdtab.h	346;"	d
CMD_sprevious	src/cmdtab.h	352;"	d
CMD_srewind	src/cmdtab.h	354;"	d
CMD_stag	src/cmdtab.h	360;"	d
CMD_stop	src/cmdtab.h	358;"	d
CMD_substitute	src/cmdtab.h	314;"	d
CMD_sunhide	src/cmdtab.h	362;"	d
CMD_suspend	src/cmdtab.h	336;"	d
CMD_sview	src/cmdtab.h	364;"	d
CMD_swapname	src/cmdtab.h	366;"	d
CMD_t	src/cmdtab.h	368;"	d
CMD_tag	src/cmdtab.h	370;"	d
CMD_tags	src/cmdtab.h	372;"	d
CMD_tilde	src/cmdtab.h	444;"	d
CMD_unabbreviate	src/cmdtab.h	376;"	d
CMD_undo	src/cmdtab.h	374;"	d
CMD_unhide	src/cmdtab.h	378;"	d
CMD_unmap	src/cmdtab.h	380;"	d
CMD_unmenu	src/cmdtab.h	382;"	d
CMD_version	src/cmdtab.h	386;"	d
CMD_vglobal	src/cmdtab.h	384;"	d
CMD_view	src/cmdtab.h	390;"	d
CMD_visual	src/cmdtab.h	388;"	d
CMD_vmap	src/cmdtab.h	392;"	d
CMD_vmapclear	src/cmdtab.h	394;"	d
CMD_vmenu	src/cmdtab.h	396;"	d
CMD_vnoremap	src/cmdtab.h	398;"	d
CMD_vnoremenu	src/cmdtab.h	400;"	d
CMD_vunmap	src/cmdtab.h	402;"	d
CMD_vunmenu	src/cmdtab.h	404;"	d
CMD_wNext	src/cmdtab.h	410;"	d
CMD_wall	src/cmdtab.h	418;"	d
CMD_winsize	src/cmdtab.h	414;"	d
CMD_wnext	src/cmdtab.h	408;"	d
CMD_wprevious	src/cmdtab.h	412;"	d
CMD_wq	src/cmdtab.h	416;"	d
CMD_wqall	src/cmdtab.h	420;"	d
CMD_write	src/cmdtab.h	406;"	d
CMD_wviminfo	src/cmdtab.h	422;"	d
CMD_xall	src/cmdtab.h	426;"	d
CMD_xit	src/cmdtab.h	424;"	d
CMD_yank	src/cmdtab.h	428;"	d
CMD_z	src/cmdtab.h	430;"	d
COLON	src/ops.h	26;"	d
COLS	tools/xxd/xxd.c	66;"	d	file:
COL_RULER	src/option.c	2460;"	d	file:
COMMENT_C	tools/ctags/ctags.c	/^typedef enum { COMMENT_NONE, COMMENT_C, COMMENT_CPLUS } Comment;$/;"	e	enum:__anon8	file:
COMMENT_CPLUS	tools/ctags/ctags.c	/^typedef enum { COMMENT_NONE, COMMENT_C, COMMENT_CPLUS } Comment;$/;"	e	enum:__anon8	file:
COMMENT_NONE	tools/ctags/ctags.c	/^typedef enum { COMMENT_NONE, COMMENT_C, COMMENT_CPLUS } Comment;$/;"	e	enum:__anon8	file:
COM_ALL	src/option.h	108;"	d
COM_BLANK	src/option.h	101;"	d
COM_END	src/option.h	104;"	d
COM_FIRST	src/option.h	105;"	d
COM_LEFT	src/option.h	106;"	d
COM_MAX_LEN	src/option.h	109;"	d
COM_MIDDLE	src/option.h	103;"	d
COM_NEST	src/option.h	100;"	d
COM_RIGHT	src/option.h	107;"	d
COM_START	src/option.h	102;"	d
CONF_OPT_GUI	src/Makefile	/^CONF_OPT_GUI = --enable-gui=yes$/;"	m
CONTEXT_UNKNOWN	src/vim.h	221;"	d
COUNT	src/cmdtab.h	25;"	d
CPO_ALL	src/option.h	58;"	d
CPO_BAR	src/option.h	40;"	d
CPO_BSLASH	src/option.h	41;"	d
CPO_BUFOPT	src/option.h	49;"	d
CPO_BUFOPTGLOB	src/option.h	50;"	d
CPO_DEFAULT	src/option.h	57;"	d
CPO_DOLLAR	src/option.h	53;"	d
CPO_ESC	src/option.h	52;"	d
CPO_EXECBUF	src/option.h	43;"	d
CPO_FILTER	src/option.h	54;"	d
CPO_FNAMER	src/option.h	44;"	d
CPO_FNAMEW	src/option.h	45;"	d
CPO_LINEOFF	src/option.h	47;"	d
CPO_MATCH	src/option.h	55;"	d
CPO_REDO	src/option.h	48;"	d
CPO_SEARCH	src/option.h	42;"	d
CPO_SHOWMATCH	src/option.h	46;"	d
CPO_SPECI	src/option.h	56;"	d
CPO_TAGPAT	src/option.h	51;"	d
CPP	src/config.mk	/^CPP = gcc -E$/;"	m
CPP_DEPEND	src/Makefile	/^CPP_DEPEND = $(CC) -M$(CPP_MM) -DPROTO -DUSE_GUI $(DEFS) $(GUI_DEFS) $(EXTRA_DEFS) $(GUI_IPATH) $(X_CFLAGS)$/;"	m
CPP_MM	src/config.mk	/^CPP_MM = M$/;"	m
CPP_NESTING_LEVEL	tools/ctags/ctags.c	110;"	d	file:
CR	src/ascii.h	17;"	d
CR	tools/ctags/ctags.c	131;"	d	file:
CSI	src/ascii.h	21;"	d
CTAGS	src/config.mk	/^CTAGS = ctags$/;"	m
CTRL_X_DICTIONARY	src/edit.c	33;"	d	file:
CTRL_X_FILES	src/edit.c	28;"	d	file:
CTRL_X_FINISHED	src/edit.c	32;"	d	file:
CTRL_X_NOT_DEFINED_YET	src/edit.c	25;"	d	file:
CTRL_X_PATH_DEFINES	src/edit.c	31;"	d	file:
CTRL_X_PATH_PATTERNS	src/edit.c	30;"	d	file:
CTRL_X_SCROLL	src/edit.c	26;"	d	file:
CTRL_X_TAGS	src/edit.c	29;"	d	file:
CTRL_X_WANT_IDENT	src/edit.c	23;"	d	file:
CTRL_X_WHOLE_LINE	src/edit.c	27;"	d	file:
CURSOR_MOVED	src/vim.h	380;"	d
CURSUPD	src/vim.h	177;"	d
Columns	src/globals.h	/^EXTERN long		Columns;				\/* number of columns in the screen *\/$/;"	v
Comment	tools/ctags/ctags.c	/^typedef enum { COMMENT_NONE, COMMENT_C, COMMENT_CPLUS } Comment;$/;"	t	typeref:enum:__anon8	file:
Completion	src/edit.c	/^struct Completion$/;"	s	file:
Cpp	tools/ctags/ctags.c	/^} Cpp = {$/;"	v	typeref:struct:__anon22	file:
Ctrl	src/ascii.h	23;"	d
D	src/gui.h	12;"	d
DATA_BL	src/memline.c	/^typedef struct data_block		DATA_BL;	\/* contents of a data block *\/$/;"	t	typeref:struct:data_block	file:
DATA_ID	src/memline.c	90;"	d	file:
DBPTR	src/Makefile	/^	cproto $(PFLAGS) -DAMIGA -UHAVE_CONFIG_H -DBPTR=char* amiga.c > proto\/amiga.pro$/;"	m
DB_INDEX_MASK	src/memline.c	147;"	d	file:
DB_MARKED	src/memline.c	146;"	d	file:
DEBUG	src/regexp.c	56;"	d	file:
DECL_CLASS	tools/ctags/ctags.c	/^	DECL_CLASS,				\/* C++ class *\/$/;"	e	enum:__anon12	file:
DECL_ENUM	tools/ctags/ctags.c	/^	DECL_ENUM,				\/* enumeration *\/$/;"	e	enum:__anon12	file:
DECL_STRUCT	tools/ctags/ctags.c	/^	DECL_STRUCT,			\/* structure *\/$/;"	e	enum:__anon12	file:
DECL_UNION	tools/ctags/ctags.c	/^	DECL_UNION				\/* union *\/$/;"	e	enum:__anon12	file:
DECL_UNSPEC	tools/ctags/ctags.c	/^	DECL_UNSPEC,			\/* unspecified (non-specific) *\/$/;"	e	enum:__anon12	file:
DEFAULT_TERM	src/term.c	819;"	d	file:
DEFAULT_TERM	src/term.c	823;"	d	file:
DEFAULT_TERM	src/term.c	827;"	d	file:
DEFAULT_TERM	src/term.c	831;"	d	file:
DEFAULT_TERM	src/term.c	835;"	d	file:
DEFAULT_TERM	src/term.c	839;"	d	file:
DEFS	src/config.mk	/^DEFS = -DHAVE_CONFIG_H$/;"	m
DEF_BDIR	src/msdos.h	86;"	d
DEF_BDIR	src/unix.h	193;"	d
DEF_BDIR	src/unix.h	195;"	d
DEF_DIR	src/msdos.h	90;"	d
DEF_DIR	src/unix.h	201;"	d
DEF_DIR	src/unix.h	203;"	d
DEL	src/ascii.h	20;"	d
DELETE	src/ops.h	17;"	d
DELETION_REGISTER	src/ops.c	37;"	d	file:
DFLALL	src/cmdtab.h	20;"	d
DIGRAPHS	src/feature.h	29;"	d
DIRMOD	src/Makefile	/^DIRMOD = 755$/;"	m
DOBUF_CURRENT	src/vim.h	314;"	d
DOBUF_DEL	src/vim.h	311;"	d
DOBUF_FIRST	src/vim.h	315;"	d
DOBUF_GOTO	src/vim.h	308;"	d
DOBUF_LAST	src/vim.h	316;"	d
DOBUF_MOD	src/vim.h	317;"	d
DOBUF_SPLIT	src/vim.h	309;"	d
DOBUF_UNLOAD	src/vim.h	310;"	d
DOCS	doc/Makefile	/^DOCS = vim_ami.txt vim_arch.txt vim_diff.txt vim_digr.txt vim_dos.txt \\$/;"	m
DOUBLE_QUOTE	tools/ctags/ctags.c	132;"	d	file:
DRCTV_DEFINE	tools/ctags/ctags.c	/^	DRCTV_DEFINE,$/;"	e	enum:__anon14	file:
DRCTV_HASH	tools/ctags/ctags.c	/^	DRCTV_HASH,$/;"	e	enum:__anon14	file:
DRCTV_IF	tools/ctags/ctags.c	/^	DRCTV_IF$/;"	e	enum:__anon14	file:
DRCTV_NONE	tools/ctags/ctags.c	/^	DRCTV_NONE,$/;"	e	enum:__anon14	file:
E	macros/maze/maze.c	/^char*M,A,Z,E=40,J[40],T[40];main(C){for(*J=A=scanf(M="%d",&C);$/;"	v
E	macros/maze/mazeansi.c	/^char*M,A,Z,E=40,J[80],T[3];main(C){for(M=J+E,*J=A=scanf("%d",&$/;"	v
EDITCMD	src/cmdtab.h	30;"	d
EMSG	src/vim.h	457;"	d
EMSG2	src/vim.h	458;"	d
EMSGN	src/vim.h	459;"	d
EMSG_RETURN	src/regexp.c	181;"	d	file:
END	src/regexp.c	99;"	d	file:
END_PAGE_DATA	src/gui_at_sb.h	144;"	d
ENV_VARIABLE_NAME	tools/ctags/ctags.c	107;"	d	file:
EOL	src/regexp.c	101;"	d	file:
EOW	src/regexp.c	116;"	d	file:
ESC	src/ascii.h	18;"	d
ESC_STR	src/ascii.h	19;"	d
EVENT_BUFENTER	src/vim.h	/^	EVENT_BUFENTER = 0,		\/* after entering a buffer *\/$/;"	e	enum:auto_events
EVENT_BUFLEAVE	src/vim.h	/^	EVENT_BUFLEAVE,			\/* before leaving a buffer *\/$/;"	e	enum:auto_events
EVENT_BUFNEWFILE	src/vim.h	/^	EVENT_BUFNEWFILE,		\/* when creating a buffer for a new file *\/$/;"	e	enum:auto_events
EVENT_BUFREADPOST	src/vim.h	/^	EVENT_BUFREADPOST,		\/* after reading a buffer *\/$/;"	e	enum:auto_events
EVENT_BUFREADPRE	src/vim.h	/^	EVENT_BUFREADPRE,		\/* before reading a buffer *\/$/;"	e	enum:auto_events
EVENT_BUFWRITEPOST	src/vim.h	/^	EVENT_BUFWRITEPOST,		\/* after writing a buffer *\/$/;"	e	enum:auto_events
EVENT_BUFWRITEPRE	src/vim.h	/^	EVENT_BUFWRITEPRE,		\/* before writing a buffer *\/$/;"	e	enum:auto_events
EVENT_FILEAPPENDPOST	src/vim.h	/^	EVENT_FILEAPPENDPOST,	\/* after appending to a file *\/$/;"	e	enum:auto_events
EVENT_FILEAPPENDPRE	src/vim.h	/^	EVENT_FILEAPPENDPRE,	\/* before appending to a file *\/$/;"	e	enum:auto_events
EVENT_FILEREADPOST	src/vim.h	/^	EVENT_FILEREADPOST,		\/* after reading a file *\/$/;"	e	enum:auto_events
EVENT_FILEREADPRE	src/vim.h	/^	EVENT_FILEREADPRE,		\/* before reading a file *\/$/;"	e	enum:auto_events
EVENT_FILEWRITEPOST	src/vim.h	/^	EVENT_FILEWRITEPOST,	\/* after writing a file *\/$/;"	e	enum:auto_events
EVENT_FILEWRITEPRE	src/vim.h	/^	EVENT_FILEWRITEPRE,		\/* before writing a file *\/$/;"	e	enum:auto_events
EVENT_FILTERREADPOST	src/vim.h	/^	EVENT_FILTERREADPOST,	\/* after reading from a filter *\/$/;"	e	enum:auto_events
EVENT_FILTERREADPRE	src/vim.h	/^	EVENT_FILTERREADPRE,	\/* before reading from a filter *\/$/;"	e	enum:auto_events
EVENT_FILTERWRITEPOST	src/vim.h	/^	EVENT_FILTERWRITEPOST,	\/* after writing to a filter *\/$/;"	e	enum:auto_events
EVENT_FILTERWRITEPRE	src/vim.h	/^	EVENT_FILTERWRITEPRE,	\/* before writing to a filter *\/$/;"	e	enum:auto_events
EVENT_VIMLEAVE	src/vim.h	/^	EVENT_VIMLEAVE,			\/* before exiting Vim *\/$/;"	e	enum:auto_events
EVENT_WINENTER	src/vim.h	/^	EVENT_WINENTER,			\/* after entering a window *\/$/;"	e	enum:auto_events
EVENT_WINLEAVE	src/vim.h	/^	EVENT_WINLEAVE,			\/* before leaving a window *\/$/;"	e	enum:auto_events
EXACTLY	src/regexp.c	109;"	d	file:
EXEC_PREFIX	src/config.mk	/^EXEC_PREFIX = ${prefix}$/;"	m
EXPAND_BOOL_SETTINGS	src/vim.h	228;"	d
EXPAND_BUFFERS	src/vim.h	232;"	d
EXPAND_COMMANDS	src/vim.h	224;"	d
EXPAND_DIRECTORIES	src/vim.h	226;"	d
EXPAND_EVENTS	src/vim.h	233;"	d
EXPAND_FILES	src/vim.h	225;"	d
EXPAND_HELP	src/vim.h	231;"	d
EXPAND_MENUS	src/vim.h	234;"	d
EXPAND_NOTHING	src/vim.h	223;"	d
EXPAND_OLD_SETTING	src/vim.h	230;"	d
EXPAND_SETTINGS	src/vim.h	227;"	d
EXPAND_TAGS	src/vim.h	229;"	d
EXPAND_UNSUCCESSFUL	src/vim.h	222;"	d
EXRC_FILE	src/msdos.h	72;"	d
EXRC_FILE	src/unix.h	172;"	d
EXTERN	src/globals.h	16;"	d
EXTERN	src/main.c	9;"	d	file:
EXTERN	src/normal.c	19;"	d	file:
EXTERN	src/normal.c	21;"	d	file:
EXTERN	src/option.h	16;"	d
EXTRA	src/cmdtab.h	17;"	d
EXTRASIZE	src/pty.c	446;"	d	file:
EXTRA_MARKS	src/mark.c	29;"	d	file:
Eargs	tools/mvi/mvi.c	/^static char **Eargs= NULL; \/* ...and arguments to pass to it *\/$/;"	v	file:
Editor	tools/mvi/mvi.c	/^static char *Editor= NULL; \/* Editor to use to edit file names... *\/$/;"	v	file:
EnvArgList	tools/ctags/ctags.c	/^static char EnvArgList[MAXLINE];$/;"	v	file:
Exec_reg	src/globals.h	/^EXTERN int		Exec_reg INIT(= FALSE);	\/* TRUE when executing a register *\/$/;"	v
ExpandBufnames	src/buffer.c	/^ExpandBufnames(pat, num_file, file, options)$/;"	f
ExpandCommands	src/cmdline.c	/^ExpandCommands(prog, num_file, file)$/;"	f	file:
ExpandEvents	src/option.c	/^ExpandEvents(prog, num_file, file)$/;"	f
ExpandFromContext	src/cmdline.c	/^ExpandFromContext(pat, num_file, file, files_only, options)$/;"	f	file:
ExpandOldSetting	src/option.c	/^ExpandOldSetting(num_file, file)$/;"	f
ExpandOne	src/cmdline.c	/^ExpandOne(str, orig, options, mode)$/;"	f
ExpandSettings	src/option.c	/^ExpandSettings(prog, num_file, file)$/;"	f
ExpandWildCards	src/archie.c	/^ExpandWildCards(num_pat, pat, num_file, file, files_only, list_notfound)$/;"	f
ExpandWildCards	src/msdos.c	/^ExpandWildCards(num_pat, pat, num_file, file, files_only, list_notfound)$/;"	f
ExpandWildCards	src/unix.c	/^ExpandWildCards(num_pat, pat, num_file, file, files_only, list_notfound)$/;"	f
FAIL	src/vim.h	216;"	d
FALSE	src/vim.h	364;"	d
FALSE	tools/ctags/ctags.c	/^typedef enum { FALSE, TRUE } boolean;$/;"	e	enum:__anon7	file:
FALSE	tools/ctags/ctags.c	172;"	d	file:
FILE1	src/cmdtab.h	34;"	d
FILES	src/Makefile	/^FILES = *.c *.h Makefile *.in makefile.* *.sh cmdtab.tab proto\/*.pro tags configure$/;"	m
FILES	src/cmdtab.h	32;"	d
FILL_X	src/gui.h	43;"	d
FILL_Y	src/gui.h	44;"	d
FILTER	src/ops.h	22;"	d
FIND_ANY	src/vim.h	249;"	d
FIND_DEFINE	src/vim.h	250;"	d
FIND_IDENT	src/vim.h	275;"	d
FIND_STRING	src/vim.h	276;"	d
FL_CHUNK	src/msdos.c	1166;"	d	file:
FM_BACKWARD	src/vim.h	302;"	d
FM_BLOCKSTOP	src/vim.h	304;"	d
FM_FORWARD	src/vim.h	303;"	d
FM_SKIPCOMM	src/vim.h	305;"	d
FNAME	src/regexp.c	119;"	d	file:
FNAME_EXP	src/vim.h	280;"	d
FNAME_HYP	src/vim.h	281;"	d
FNAME_MESS	src/vim.h	279;"	d
FOREVER	src/msdos.c	219;"	d	file:
FORMAT	src/ops.h	25;"	d
FORWARD	src/vim.h	210;"	d
FO_ALL	src/option.h	37;"	d
FO_DFLT	src/option.h	36;"	d
FO_DFLT_VI	src/option.h	35;"	d
FO_INS_BLANK	src/option.h	33;"	d
FO_INS_LONG	src/option.h	32;"	d
FO_INS_VI	src/option.h	31;"	d
FO_OPEN_COMS	src/option.h	28;"	d
FO_Q_COMS	src/option.h	29;"	d
FO_Q_SECOND	src/option.h	30;"	d
FO_RET_COMS	src/option.h	27;"	d
FO_WRAP	src/option.h	25;"	d
FO_WRAP_COMS	src/option.h	26;"	d
FPC_DIFF	src/vim.h	328;"	d
FPC_DIFFX	src/vim.h	330;"	d
FPC_NOTX	src/vim.h	329;"	d
FPC_SAME	src/vim.h	327;"	d
FPOS	src/structs.h	/^typedef struct fpos		FPOS;$/;"	t	typeref:struct:fpos
F_BSIZE	src/memfile.c	55;"	d	file:
F_BSIZE	src/memfile.c	58;"	d	file:
Fclose	tools/mvi/mvi.c	/^Fclose( fp )$/;"	f	file:
File	tools/ctags/ctags.c	/^} File = { NULL, NULL, 0, -1, FALSE, 0, FALSE, FALSE };$/;"	v	typeref:struct:__anon21	file:
FileList	src/msdos.c	/^} FileList;$/;"	t	typeref:struct:filelist	file:
Fopen	tools/mvi/mvi.c	/^Fopen( name, acc )$/;"	f	file:
Fprintf	tools/mvi/mvi.c	44;"	d	file:
FreeWild	src/misccmds.c	/^FreeWild(num, file)$/;"	f
FullName	src/archie.c	/^FullName(fname, buf, len, force)$/;"	f
FullName	src/msdos.c	/^FullName(fname, buf, len, force)$/;"	f
FullName	src/unix.c	/^FullName(fname, buf, len, force)$/;"	f
FullName_save	src/misccmds.c	/^FullName_save(fname)$/;"	f
GAP	src/option.c	2200;"	d	file:
GAP	src/term.c	2928;"	d	file:
GETF_ALT	src/vim.h	285;"	d
GETF_SETMARK	src/vim.h	284;"	d
GO_ALL	src/option.h	97;"	d
GO_ASEL	src/option.h	90;"	d
GO_BOT	src/option.h	91;"	d
GO_FORG	src/option.h	92;"	d
GO_GREY	src/option.h	93;"	d
GO_LEFT	src/option.h	94;"	d
GO_MENUS	src/option.h	95;"	d
GO_RIGHT	src/option.h	96;"	d
GTARGET	src/Makefile	/^GTARGET = gvim$/;"	m
GUI_INC_LOC	src/Makefile	/^	GUI_INC_LOC="$(GUI_INC_LOC)" GUI_LIB_LOC="$(GUI_LIB_LOC)" \\$/;"	m
GUI_INC_LOC	src/config.mk	/^GUI_INC_LOC = $/;"	m
GUI_LIB_LOC	src/config.mk	/^GUI_LIB_LOC = $/;"	m
GUI_SELECTION_REGISTER	src/ops.c	39;"	d	file:
GUI_X_LIBS	src/config.mk	/^GUI_X_LIBS = $/;"	m
GVIMRC_FILE	src/unix.h	181;"	d
Gui	src/gui.h	/^typedef struct Gui$/;"	s
Gui	src/gui.h	/^} Gui;$/;"	t	typeref:struct:Gui
GuiMenu	src/gui.h	/^typedef struct GuiMenu$/;"	s
GuiMenu	src/gui.h	/^} GuiMenu;$/;"	t	typeref:struct:GuiMenu
GuiScrollbar	src/gui.h	/^typedef struct GuiScrollbar$/;"	s
GuiScrollbar	src/gui.h	/^} GuiScrollbar;$/;"	t	typeref:struct:GuiScrollbar
GuiSelection	src/gui.h	/^typedef struct GuiSelection$/;"	s
GuiSelection	src/gui.h	/^} GuiSelection;$/;"	t	typeref:struct:GuiSelection
HASWIDTH	src/regexp.c	196;"	d	file:
HAVE_DATE_TIME	src/archie.h	14;"	d
HAVE_DATE_TIME	src/conf_os2.h	48;"	d
HAVE_DATE_TIME	src/msdos.h	35;"	d
HAVE_DIRENT_H	src/conf_os2.h	167;"	d
HAVE_DIRENT_H	src/config.h	157;"	d
HAVE_ERRNO_H	src/conf_os2.h	223;"	d
HAVE_ERRNO_H	src/config.h	213;"	d
HAVE_FCHDIR	src/conf_os2.h	146;"	d
HAVE_FCHDIR	src/config.h	136;"	d
HAVE_FCHOWN	src/conf_os2.h	137;"	d
HAVE_FCHOWN	src/config.h	127;"	d
HAVE_FCNTL_H	src/archie.h	17;"	d
HAVE_FCNTL_H	src/conf_os2.h	202;"	d
HAVE_FCNTL_H	src/config.h	192;"	d
HAVE_FCNTL_H	src/msdos.h	30;"	d
HAVE_FSYNC	src/conf_os2.h	143;"	d
HAVE_FSYNC	src/config.h	133;"	d
HAVE_GETCWD	src/conf_os2.h	110;"	d
HAVE_GETCWD	src/config.h	100;"	d
HAVE_GETPWNAM	src/conf_os2.h	161;"	d
HAVE_GETPWNAM	src/config.h	151;"	d
HAVE_GETPWUID	src/conf_os2.h	158;"	d
HAVE_GETPWUID	src/config.h	148;"	d
HAVE_GETTIMEOFDAY	src/conf_os2.h	155;"	d
HAVE_GETTIMEOFDAY	src/config.h	145;"	d
HAVE_GETWD	src/conf_os2.h	113;"	d
HAVE_GETWD	src/config.h	103;"	d
HAVE_KILLPG	src/conf_os2.h	125;"	d
HAVE_KILLPG	src/config.h	115;"	d
HAVE_LIBCURSES	src/conf_os2.h	18;"	d
HAVE_LIBC_H	src/conf_os2.h	244;"	d
HAVE_LIBNCURSES	src/conf_os2.h	27;"	d
HAVE_LIBTERMCAP	src/conf_os2.h	21;"	d
HAVE_LIBTERMCAP	src/config.h	11;"	d
HAVE_LIBTERMLIB	src/conf_os2.h	24;"	d
HAVE_LOCALE_H	src/conf_os2.h	232;"	d
HAVE_LOCALE_H	src/config.h	222;"	d
HAVE_MEMSET	src/conf_os2.h	131;"	d
HAVE_MEMSET	src/config.h	121;"	d
HAVE_MEMSET	src/msdos.h	32;"	d
HAVE_NDIR_H	src/conf_os2.h	176;"	d
HAVE_OSPEED	src/conf_os2.h	33;"	d
HAVE_OSPEED	src/config.h	23;"	d
HAVE_OUTFUNTYPE	src/conf_os2.h	45;"	d
HAVE_PUTENV	src/conf_os2.h	152;"	d
HAVE_PUTENV	src/config.h	142;"	d
HAVE_PWD_H	src/conf_os2.h	253;"	d
HAVE_PWD_H	src/config.h	243;"	d
HAVE_QSORT	src/archie.h	16;"	d
HAVE_QSORT	src/conf_os2.h	164;"	d
HAVE_QSORT	src/config.h	154;"	d
HAVE_QSORT	src/msdos.h	33;"	d
HAVE_RENAME	src/conf_os2.h	140;"	d
HAVE_RENAME	src/config.h	130;"	d
HAVE_SELECT	src/conf_os2.h	116;"	d
HAVE_SELECT	src/config.h	106;"	d
HAVE_SETENV	src/conf_os2.h	149;"	d
HAVE_SETENV	src/config.h	139;"	d
HAVE_SGTTY_H	src/conf_os2.h	205;"	d
HAVE_SGTTY_H	src/config.h	195;"	d
HAVE_SIGSET	src/conf_os2.h	104;"	d
HAVE_STDLIB_H	src/conf_os2.h	189;"	d
HAVE_STDLIB_H	src/config.h	179;"	d
HAVE_STDLIB_H	src/msdos.h	28;"	d
HAVE_STRCSPN	src/conf_os2.h	119;"	d
HAVE_STRCSPN	src/config.h	109;"	d
HAVE_STRCSPN	src/msdos.h	31;"	d
HAVE_STRERROR	src/conf_os2.h	134;"	d
HAVE_STRERROR	src/config.h	124;"	d
HAVE_STRINGS_H	src/conf_os2.h	226;"	d
HAVE_STRINGS_H	src/config.h	216;"	d
HAVE_STRING_H	src/conf_os2.h	190;"	d
HAVE_STRING_H	src/config.h	180;"	d
HAVE_STRING_H	src/msdos.h	29;"	d
HAVE_STROPTS_H	src/conf_os2.h	220;"	d
HAVE_STRTOL	src/conf_os2.h	122;"	d
HAVE_STRTOL	src/config.h	112;"	d
HAVE_SYS_DIR_H	src/conf_os2.h	173;"	d
HAVE_SYS_IOCTL_H	src/conf_os2.h	208;"	d
HAVE_SYS_IOCTL_H	src/config.h	198;"	d
HAVE_SYS_NDIR_H	src/conf_os2.h	170;"	d
HAVE_SYS_POLL_H	src/conf_os2.h	250;"	d
HAVE_SYS_PTEM_H	src/conf_os2.h	238;"	d
HAVE_SYS_SELECT_H	src/conf_os2.h	193;"	d
HAVE_SYS_SELECT_H	src/config.h	183;"	d
HAVE_SYS_STATFS_H	src/conf_os2.h	247;"	d
HAVE_SYS_STREAM_H	src/conf_os2.h	235;"	d
HAVE_SYS_SYSTEMINFO_H	src/conf_os2.h	229;"	d
HAVE_SYS_TIME_H	src/conf_os2.h	211;"	d
HAVE_SYS_TIME_H	src/config.h	201;"	d
HAVE_SYS_UTSNAME_H	src/conf_os2.h	196;"	d
HAVE_SYS_UTSNAME_H	src/config.h	186;"	d
HAVE_SYS_WAIT_H	src/conf_os2.h	179;"	d
HAVE_SYS_WAIT_H	src/config.h	169;"	d
HAVE_TERMCAP_H	src/conf_os2.h	199;"	d
HAVE_TERMCAP_H	src/config.h	189;"	d
HAVE_TERMIOS_H	src/conf_os2.h	241;"	d
HAVE_TERMIOS_H	src/config.h	231;"	d
HAVE_TERMIO_H	src/conf_os2.h	214;"	d
HAVE_TGETENT	src/conf_os2.h	128;"	d
HAVE_TGETENT	src/config.h	118;"	d
HAVE_UNION_WAIT	src/conf_os2.h	182;"	d
HAVE_UNISTD_H	src/conf_os2.h	217;"	d
HAVE_UNISTD_H	src/config.h	207;"	d
HAVE_UP_BC_PC	src/conf_os2.h	39;"	d
HAVE_UP_BC_PC	src/config.h	29;"	d
HAVE_X11	src/conf_os2.h	15;"	d
HAVE_X11	src/config.h	5;"	d
HEADER_SEPARATORS	tools/ctags/ctags.c	126;"	d	file:
HEADER_SIZE	src/memline.c	150;"	d	file:
HELPDIR	src/config.mk	/^HELPDIR = \/share$/;"	m
HELPLOC	src/Makefile	/^HELPLOC = $(PREFIX)$(HELPDIR)$/;"	m
HELPMOD	src/Makefile	/^HELPMOD = 644$/;"	m
HELPSOURCE	src/Makefile	/^HELPSOURCE = ..\/doc$/;"	m
HELPSUBDIR	src/Makefile	/^HELPSUBDIR = \/vim$/;"	m
HELPSUBLOC	src/Makefile	/^HELPSUBLOC = $(HELPLOC)$(HELPSUBDIR)$/;"	m
HEX_CINCLUDE	tools/xxd/xxd.c	74;"	d	file:
HEX_NORMAL	tools/xxd/xxd.c	72;"	d	file:
HEX_POSTSCRIPT	tools/xxd/xxd.c	73;"	d	file:
HITRETURN	src/vim.h	204;"	d
HL_ALL	src/gui.h	88;"	d
HL_BOLD	src/gui.h	83;"	d
HL_INVERSE	src/gui.h	82;"	d
HL_ITAL	src/gui.h	84;"	d
HL_NORMAL	src/gui.h	81;"	d
HL_SELECTED	src/gui.h	87;"	d
HL_STANDOUT	src/gui.h	86;"	d
HL_UNDERLINE	src/gui.h	85;"	d
Help	tools/ctags/ctags.c	/^static const char *const Help[] = {$/;"	v	file:
IDENT	src/regexp.c	117;"	d	file:
INBUFLEN	src/archie.c	516;"	d	file:
INBUFLEN	src/unix.c	2182;"	d	file:
INC	src/option.c	2199;"	d	file:
INC	src/term.c	2927;"	d	file:
INCL	src/Makefile	/^INCL =  $(BASIC_INCL) $(GUI_INCL)$/;"	m
INCSTACK_SIZE	src/tag.c	275;"	d	file:
INDENT	src/ops.h	24;"	d
INDENT_DEC	src/vim.h	299;"	d
INDENT_INC	src/vim.h	298;"	d
INDENT_SET	src/vim.h	297;"	d
INDEX_SIZE	src/memline.c	149;"	d	file:
INIT	src/globals.h	17;"	d
INIT	src/globals.h	20;"	d
INIT	src/normal.c	20;"	d	file:
INIT	src/normal.c	22;"	d	file:
INIT	src/option.h	17;"	d
INIT	src/option.h	20;"	d
INPUT_BUFLEN	src/edit.c	2734;"	d	file:
INSERT	src/vim.h	201;"	d
INSERT_EXPAND	src/feature.h	46;"	d
INTERNAL_SORT	tools/ctags/ctags.c	101;"	d	file:
INVALIDATE_CURSOR	src/gui.h	107;"	d
INVERTED	src/vim.h	174;"	d
IN_BUFFER	src/vim.h	378;"	d
IN_STATUS_LINE	src/vim.h	379;"	d
IN_UNKNOWN	src/vim.h	377;"	d
IOSIZE	src/vim.h	404;"	d
IObuff	src/globals.h	/^EXTERN char_u 	*IObuff;				\/* sprintf's are done in this buffer *\/$/;"	v
IPTR	src/structs.h	/^typedef struct info_pointer		IPTR;		\/* block\/index pair *\/$/;"	t	typeref:struct:info_pointer
ISSPECIAL	src/edit.c	2528;"	d	file:
IS_ABBR	src/keymap.h	39;"	d
IS_CURSOR_VALID	src/gui.h	115;"	d
IS_SPECIAL	src/keymap.h	38;"	d
IceConnectionNumber	src/configure	/^IceConnectionNumber()$/;"	f
IceOpenConnection	src/configure	/^IceOpenConnection()$/;"	f
Insstart	src/edit.c	/^static FPOS 	Insstart;		\/* This is where the latest insert\/append$/;"	v	file:
Insstart_blank_vcol	src/edit.c	/^static colnr_t	Insstart_blank_vcol;	\/* vcol for first inserted blank *\/$/;"	v	file:
Insstart_textlen	src/edit.c	/^static colnr_t	Insstart_textlen;	\/* length of line when insert started *\/$/;"	v	file:
J	macros/maze/maze.c	/^char*M,A,Z,E=40,J[40],T[40];main(C){for(*J=A=scanf(M="%d",&C);$/;"	v
J	macros/maze/mazeansi.c	/^char*M,A,Z,E=40,J[80],T[3];main(C){for(M=J+E,*J=A=scanf("%d",&$/;"	v
JOIN	src/ops.h	29;"	d
JUMPLISTSIZE	src/structs.h	48;"	d
KEEP_ROOM	src/alloc.c	24;"	d	file:
KEY2TERMCAP0	src/keymap.h	84;"	d
KEY2TERMCAP1	src/keymap.h	85;"	d
KEY_NAMES_TABLE_LEN	src/tables.c	205;"	d	file:
KEY_OPEN_BACK	src/vim.h	289;"	d
KEY_OPEN_FORW	src/vim.h	288;"	d
KE_IGNORE	src/keymap.h	164;"	d
KE_LEFTDRAG	src/keymap.h	155;"	d
KE_LEFTMOUSE	src/keymap.h	154;"	d
KE_LEFTRELEASE	src/keymap.h	156;"	d
KE_MIDDLEDRAG	src/keymap.h	158;"	d
KE_MIDDLEMOUSE	src/keymap.h	157;"	d
KE_MIDDLERELEASE	src/keymap.h	159;"	d
KE_MOUSE	src/keymap.h	148;"	d
KE_NAME	src/keymap.h	104;"	d
KE_RIGHTDRAG	src/keymap.h	161;"	d
KE_RIGHTMOUSE	src/keymap.h	160;"	d
KE_RIGHTRELEASE	src/keymap.h	162;"	d
KE_S_DOWN	src/keymap.h	107;"	d
KE_S_F1	src/keymap.h	109;"	d
KE_S_F10	src/keymap.h	118;"	d
KE_S_F11	src/keymap.h	120;"	d
KE_S_F12	src/keymap.h	121;"	d
KE_S_F13	src/keymap.h	122;"	d
KE_S_F14	src/keymap.h	123;"	d
KE_S_F15	src/keymap.h	124;"	d
KE_S_F16	src/keymap.h	125;"	d
KE_S_F17	src/keymap.h	126;"	d
KE_S_F18	src/keymap.h	127;"	d
KE_S_F19	src/keymap.h	128;"	d
KE_S_F2	src/keymap.h	110;"	d
KE_S_F20	src/keymap.h	129;"	d
KE_S_F21	src/keymap.h	131;"	d
KE_S_F22	src/keymap.h	132;"	d
KE_S_F23	src/keymap.h	133;"	d
KE_S_F24	src/keymap.h	134;"	d
KE_S_F25	src/keymap.h	135;"	d
KE_S_F26	src/keymap.h	136;"	d
KE_S_F27	src/keymap.h	137;"	d
KE_S_F28	src/keymap.h	138;"	d
KE_S_F29	src/keymap.h	139;"	d
KE_S_F3	src/keymap.h	111;"	d
KE_S_F30	src/keymap.h	140;"	d
KE_S_F31	src/keymap.h	142;"	d
KE_S_F32	src/keymap.h	143;"	d
KE_S_F33	src/keymap.h	144;"	d
KE_S_F34	src/keymap.h	145;"	d
KE_S_F35	src/keymap.h	146;"	d
KE_S_F4	src/keymap.h	112;"	d
KE_S_F5	src/keymap.h	113;"	d
KE_S_F6	src/keymap.h	114;"	d
KE_S_F7	src/keymap.h	115;"	d
KE_S_F8	src/keymap.h	116;"	d
KE_S_F9	src/keymap.h	117;"	d
KE_S_TAB	src/keymap.h	167;"	d
KE_S_UP	src/keymap.h	106;"	d
KE_TAB	src/keymap.h	166;"	d
KS_AL	src/term.h	/^	KS_AL,		\/* add new blank line *\/$/;"	e	enum:SpecialKeys
KS_CAL	src/term.h	/^	KS_CAL,		\/* add number of blank lines *\/$/;"	e	enum:SpecialKeys
KS_CD	src/term.h	/^	KS_CD,		\/* clear to end of display *\/$/;"	e	enum:SpecialKeys
KS_CDL	src/term.h	/^	KS_CDL,		\/* delete number of lines *\/$/;"	e	enum:SpecialKeys
KS_CE	src/term.h	/^	KS_CE,		\/* clear to end of line *\/$/;"	e	enum:SpecialKeys
KS_CL	src/term.h	/^	KS_CL,		\/* clear screen *\/$/;"	e	enum:SpecialKeys
KS_CM	src/term.h	/^	KS_CM,		\/* cursor motion *\/$/;"	e	enum:SpecialKeys
KS_CRI	src/term.h	/^	KS_CRI,		\/* cursor number of chars right *\/$/;"	e	enum:SpecialKeys
KS_CS	src/term.h	/^	KS_CS,		\/* scroll region *\/$/;"	e	enum:SpecialKeys
KS_CSC	src/term.h	/^	KS_CSC		\/* cur is relative to scroll region *\/$/;"	e	enum:SpecialKeys
KS_CZH	src/term.h	/^	KS_CZH,		\/* italic mode start *\/$/;"	e	enum:SpecialKeys
KS_CZR	src/term.h	/^	KS_CZR,		\/* italic mode end *\/$/;"	e	enum:SpecialKeys
KS_DA	src/term.h	/^	KS_DA,		\/* text may be scrolled down from up *\/$/;"	e	enum:SpecialKeys
KS_DB	src/term.h	/^	KS_DB,		\/* text may be scrolled up from down *\/$/;"	e	enum:SpecialKeys
KS_DL	src/term.h	/^	KS_DL,		\/* delete line *\/$/;"	e	enum:SpecialKeys
KS_EXTRA	src/keymap.h	58;"	d
KS_HORIZ_SCROLLBAR	src/keymap.h	73;"	d
KS_KE	src/term.h	/^	KS_KE,		\/* out of "keypad transmit" mode *\/$/;"	e	enum:SpecialKeys
KS_KS	src/term.h	/^	KS_KS,		\/* put term in "keypad transmit" mode *\/$/;"	e	enum:SpecialKeys
KS_LAST	src/term.h	65;"	d
KS_MD	src/term.h	/^	KS_MD,		\/* bold mode *\/$/;"	e	enum:SpecialKeys
KS_ME	src/term.h	/^	KS_ME,		\/* normal mode *\/$/;"	e	enum:SpecialKeys
KS_MENU	src/keymap.h	71;"	d
KS_MODIFIER	src/keymap.h	64;"	d
KS_MOUSE	src/keymap.h	70;"	d
KS_MR	src/term.h	/^	KS_MR,		\/* reverse mode *\/$/;"	e	enum:SpecialKeys
KS_MS	src/term.h	/^	KS_MS,		\/* save to move cur in reverse mode *\/$/;"	e	enum:SpecialKeys
KS_NAME	src/term.h	/^	KS_NAME = 0,		\/* name of this terminal entry *\/$/;"	e	enum:SpecialKeys
KS_SCROLLBAR	src/keymap.h	72;"	d
KS_SE	src/term.h	/^	KS_SE,		\/* normal mode *\/$/;"	e	enum:SpecialKeys
KS_SO	src/term.h	/^	KS_SO,		\/* standout mode *\/$/;"	e	enum:SpecialKeys
KS_SPECIAL	src/keymap.h	52;"	d
KS_SR	src/term.h	/^	KS_SR,		\/* scroll reverse (backward) *\/$/;"	e	enum:SpecialKeys
KS_TE	src/term.h	/^	KS_TE,		\/* out of termcap mode *\/$/;"	e	enum:SpecialKeys
KS_TI	src/term.h	/^	KS_TI,		\/* put terminal in termcap mode *\/$/;"	e	enum:SpecialKeys
KS_UE	src/term.h	/^	KS_UE,		\/* exit underscore mode *\/$/;"	e	enum:SpecialKeys
KS_US	src/term.h	/^	KS_US,		\/* underscore mode *\/$/;"	e	enum:SpecialKeys
KS_VB	src/term.h	/^	KS_VB,		\/* visual bell *\/$/;"	e	enum:SpecialKeys
KS_VE	src/term.h	/^	KS_VE,		\/* cursor visible *\/$/;"	e	enum:SpecialKeys
KS_VI	src/term.h	/^	KS_VI,		\/* cursor invisible *\/$/;"	e	enum:SpecialKeys
KS_VS	src/term.h	/^	KS_VS,		\/* cursor very visible *\/$/;"	e	enum:SpecialKeys
KS_ZERO	src/keymap.h	46;"	d
K_BS	src/keymap.h	266;"	d
K_CCIRCM	src/keymap.h	9;"	d
K_DEL	src/keymap.h	269;"	d
K_DOWN	src/keymap.h	175;"	d
K_END	src/keymap.h	271;"	d
K_F1	src/keymap.h	185;"	d
K_F10	src/keymap.h	194;"	d
K_F11	src/keymap.h	196;"	d
K_F12	src/keymap.h	197;"	d
K_F13	src/keymap.h	198;"	d
K_F14	src/keymap.h	199;"	d
K_F15	src/keymap.h	200;"	d
K_F16	src/keymap.h	201;"	d
K_F17	src/keymap.h	202;"	d
K_F18	src/keymap.h	203;"	d
K_F19	src/keymap.h	204;"	d
K_F2	src/keymap.h	186;"	d
K_F20	src/keymap.h	205;"	d
K_F21	src/keymap.h	207;"	d
K_F22	src/keymap.h	208;"	d
K_F23	src/keymap.h	209;"	d
K_F24	src/keymap.h	210;"	d
K_F25	src/keymap.h	211;"	d
K_F26	src/keymap.h	212;"	d
K_F27	src/keymap.h	213;"	d
K_F28	src/keymap.h	214;"	d
K_F29	src/keymap.h	215;"	d
K_F3	src/keymap.h	187;"	d
K_F30	src/keymap.h	216;"	d
K_F31	src/keymap.h	218;"	d
K_F32	src/keymap.h	219;"	d
K_F33	src/keymap.h	220;"	d
K_F34	src/keymap.h	221;"	d
K_F35	src/keymap.h	222;"	d
K_F4	src/keymap.h	188;"	d
K_F5	src/keymap.h	189;"	d
K_F6	src/keymap.h	190;"	d
K_F7	src/keymap.h	191;"	d
K_F8	src/keymap.h	192;"	d
K_F9	src/keymap.h	193;"	d
K_FILLER	src/keymap.h	78;"	d
K_HELP	src/keymap.h	263;"	d
K_HOME	src/keymap.h	270;"	d
K_HORIZ_SCROLLBAR	src/keymap.h	278;"	d
K_IGNORE	src/keymap.h	294;"	d
K_INS	src/keymap.h	268;"	d
K_LEFT	src/keymap.h	176;"	d
K_LEFTDRAG	src/keymap.h	285;"	d
K_LEFTMOUSE	src/keymap.h	284;"	d
K_LEFTRELEASE	src/keymap.h	286;"	d
K_MENU	src/keymap.h	276;"	d
K_MIDDLEDRAG	src/keymap.h	288;"	d
K_MIDDLEMOUSE	src/keymap.h	287;"	d
K_MIDDLERELEASE	src/keymap.h	289;"	d
K_MOUSE	src/keymap.h	275;"	d
K_NEEDMORET	src/getchar.c	887;"	d	file:
K_NUL	src/keymap.h	15;"	d
K_PAGEDOWN	src/keymap.h	273;"	d
K_PAGEUP	src/keymap.h	272;"	d
K_RIGHT	src/keymap.h	177;"	d
K_RIGHTDRAG	src/keymap.h	291;"	d
K_RIGHTMOUSE	src/keymap.h	290;"	d
K_RIGHTRELEASE	src/keymap.h	292;"	d
K_SCROLLBAR	src/keymap.h	277;"	d
K_SECOND	src/keymap.h	90;"	d
K_SPECIAL	src/keymap.h	31;"	d
K_S_DOWN	src/keymap.h	179;"	d
K_S_F1	src/keymap.h	224;"	d
K_S_F10	src/keymap.h	233;"	d
K_S_F11	src/keymap.h	235;"	d
K_S_F12	src/keymap.h	236;"	d
K_S_F13	src/keymap.h	237;"	d
K_S_F14	src/keymap.h	238;"	d
K_S_F15	src/keymap.h	239;"	d
K_S_F16	src/keymap.h	240;"	d
K_S_F17	src/keymap.h	241;"	d
K_S_F18	src/keymap.h	242;"	d
K_S_F19	src/keymap.h	243;"	d
K_S_F2	src/keymap.h	225;"	d
K_S_F20	src/keymap.h	244;"	d
K_S_F21	src/keymap.h	246;"	d
K_S_F22	src/keymap.h	247;"	d
K_S_F23	src/keymap.h	248;"	d
K_S_F24	src/keymap.h	249;"	d
K_S_F25	src/keymap.h	250;"	d
K_S_F26	src/keymap.h	251;"	d
K_S_F27	src/keymap.h	252;"	d
K_S_F28	src/keymap.h	253;"	d
K_S_F29	src/keymap.h	254;"	d
K_S_F3	src/keymap.h	226;"	d
K_S_F30	src/keymap.h	255;"	d
K_S_F31	src/keymap.h	257;"	d
K_S_F32	src/keymap.h	258;"	d
K_S_F33	src/keymap.h	259;"	d
K_S_F34	src/keymap.h	260;"	d
K_S_F35	src/keymap.h	261;"	d
K_S_F4	src/keymap.h	227;"	d
K_S_F5	src/keymap.h	228;"	d
K_S_F6	src/keymap.h	229;"	d
K_S_F7	src/keymap.h	230;"	d
K_S_F8	src/keymap.h	231;"	d
K_S_F9	src/keymap.h	232;"	d
K_S_LEFT	src/keymap.h	180;"	d
K_S_RIGHT	src/keymap.h	181;"	d
K_S_TAB	src/keymap.h	183;"	d
K_S_UP	src/keymap.h	178;"	d
K_TAB	src/keymap.h	182;"	d
K_THIRD	src/keymap.h	92;"	d
K_UNDO	src/keymap.h	264;"	d
K_UP	src/keymap.h	174;"	d
K_ZERO	src/keymap.h	172;"	d
KeyStuffed	src/globals.h	/^EXTERN int		KeyStuffed;				\/* TRUE if current char from stuffbuf *\/$/;"	v
KeyTyped	src/globals.h	/^EXTERN int		KeyTyped;				\/* TRUE if user typed current char *\/$/;"	v
LANGMAP_ADJUST	src/macros.h	58;"	d
LDFLAGS	src/config.mk	/^LDFLAGS = $/;"	m
LIBS	src/config.mk	/^LIBS = -ltermcap $/;"	m
LINELEN	doc/doctags.c	14;"	d	file:
LISPINDENT	src/feature.h	123;"	d
LLEN	tools/xxd/xxd.c	67;"	d	file:
LOOKFOR_ANY	src/misccmds.c	2671;"	d	file:
LOOKFOR_CASE	src/misccmds.c	2670;"	d	file:
LOOKFOR_DO	src/misccmds.c	2669;"	d	file:
LOOKFOR_IF	src/misccmds.c	2668;"	d	file:
LOOKFOR_TERM	src/misccmds.c	2672;"	d	file:
LOOKFOR_UNTERM	src/misccmds.c	2673;"	d	file:
LOWER	src/ops.h	28;"	d
LSHIFT	src/ops.h	20;"	d
LSIZE	src/vim.h	402;"	d
LinePointers	src/globals.h	/^EXTERN char_u 	**LinePointers INIT(= NULL);$/;"	v
M	macros/maze/maze.c	/^char*M,A,Z,E=40,J[40],T[40];main(C){for(*J=A=scanf(M="%d",&C);$/;"	v
M	macros/maze/mazeansi.c	/^char*M,A,Z,E=40,J[80],T[3];main(C){for(M=J+E,*J=A=scanf("%d",&$/;"	v
MAGIC	src/regexp.h	38;"	d
MANDIR	src/Makefile	/^MANDIR = \/man1$/;"	m
MANLOC	src/Makefile	/^MANLOC = $(PREFIX)\/man$/;"	m
MANMOD	src/Makefile	/^MANMOD = 644$/;"	m
MAXCOL	src/vim.h	470;"	d
MAXCOL	src/vim.h	472;"	d
MAXLINE	tools/ctags/ctags.c	121;"	d	file:
MAXLNUM	src/vim.h	467;"	d
MAXMAPLEN	src/vim.h	419;"	d
MAXMEM	src/msdos.h	98;"	d
MAXMEM	src/unix.h	222;"	d
MAXMEMTOT	src/msdos.h	101;"	d
MAXMEMTOT	src/unix.h	225;"	d
MAXNAME	tools/ctags/ctags.c	117;"	d	file:
MAXNAMLEN	src/unix.h	118;"	d
MAXNAMLEN	src/unix.h	122;"	d
MAXNAMLEN	src/unix.h	126;"	d
MAXNAMLEN	src/unix.h	134;"	d
MAXNAMLEN	src/vim.h	112;"	d
MAXPATH	tools/ctags/ctags.c	113;"	d	file:
MAXPATHL	src/unix.h	215;"	d
MAXPATHL	src/vim.h	116;"	d
MAXSUFLEN	src/cmdline.c	3924;"	d	file:
MAX_ADDR	src/quickfix.c	45;"	d	file:
MAX_ENV_ARGS	tools/ctags/ctags.c	109;"	d	file:
MAX_HEADER_EXTENSIONS	tools/ctags/ctags.c	108;"	d	file:
MAX_KEY_CODE_LEN	src/keymap.h	320;"	d
MAX_KEY_NAME_LEN	src/keymap.h	310;"	d
MAYBE	src/vim.h	368;"	d
MBLOCK	src/ops.h	53;"	d
MCHAR	src/ops.h	51;"	d
MCLOSE	src/regexp.c	128;"	d	file:
MEMBLOCKSIZE	src/undo.c	772;"	d	file:
MEMFILE	src/structs.h	/^typedef struct memfile		MEMFILE;$/;"	t	typeref:struct:memfile
MEMFILE_PAGE_SIZE	src/memfile.c	75;"	d	file:
MEMHASH	src/structs.h	211;"	d
MEMHASHSIZE	src/structs.h	210;"	d
MEMLINE	src/structs.h	/^typedef struct memline MEMLINE;$/;"	t	typeref:struct:memline
MENU_ALL_MODES	src/gui.h	53;"	d
MENU_CMDLINE_MODE	src/gui.h	52;"	d
MENU_DEFAULT_HEIGHT	src/gui.h	78;"	d
MENU_INDEX_CMDLINE	src/gui.h	60;"	d
MENU_INDEX_INSERT	src/gui.h	59;"	d
MENU_INDEX_INVALID	src/gui.h	56;"	d
MENU_INDEX_NORMAL	src/gui.h	57;"	d
MENU_INDEX_VISUAL	src/gui.h	58;"	d
MENU_INSERT_MODE	src/gui.h	51;"	d
MENU_NORMAL_MODE	src/gui.h	49;"	d
MENU_VISUAL_MODE	src/gui.h	50;"	d
MESSAGE	src/message.c	15;"	d	file:
META	src/regexp.c	/^       static char_u META[] = ".[()|=+*<>iIkKfFpP";$/;"	v	file:
META	src/regexp.c	/^       static char_u META[] = ".[()|=+*<>iIkKfFpP123456789";$/;"	v	file:
META	src/regexp.c	/^       static char_u META[] = ".[()|=+*<>iIkKfFpP~";$/;"	v	file:
META	src/regexp.c	/^       static char_u META[] = ".[()|=+*<>iIkKfFpP~123456789";$/;"	v	file:
MINIMAL_SIZE	src/getchar.c	32;"	d	file:
MIN_COLUMNS	src/vim.h	391;"	d
MIN_ROWS	src/vim.h	392;"	d
MLINE	src/ops.h	52;"	d
ML_DELETE	src/memline.c	208;"	d	file:
ML_EMPTY	src/structs.h	262;"	d
ML_FIND	src/memline.c	210;"	d	file:
ML_FLUSH	src/memline.c	211;"	d	file:
ML_INSERT	src/memline.c	209;"	d	file:
ML_LINE_DIRTY	src/structs.h	263;"	d
ML_LOCKED_DIRTY	src/structs.h	264;"	d
ML_LOCKED_POS	src/structs.h	265;"	d
ML_SIMPLE	src/memline.c	212;"	d	file:
MOD_MASK_2CLICK	src/keymap.h	300;"	d
MOD_MASK_3CLICK	src/keymap.h	301;"	d
MOD_MASK_4CLICK	src/keymap.h	302;"	d
MOD_MASK_ALT	src/keymap.h	299;"	d
MOD_MASK_CTRL	src/keymap.h	298;"	d
MOD_MASK_MULTI_CLICK	src/keymap.h	304;"	d
MOD_MASK_SHIFT	src/keymap.h	297;"	d
MOPEN	src/regexp.c	125;"	d	file:
MOTIF_COMMENT	src/config.mk	/^MOTIF_COMMENT = ZZZ$/;"	m
MOUSE_A	src/option.h	70;"	d
MOUSE_ALL	src/option.h	71;"	d
MOUSE_ALT	src/msdos.h	117;"	d
MOUSE_ALT	src/unix.h	254;"	d
MOUSE_CLICK_MASK	src/msdos.h	122;"	d
MOUSE_CLICK_MASK	src/unix.h	258;"	d
MOUSE_COMMAND	src/option.h	67;"	d
MOUSE_CTRL	src/msdos.h	118;"	d
MOUSE_CTRL	src/unix.h	255;"	d
MOUSE_DID_MOVE	src/vim.h	385;"	d
MOUSE_DRAG	src/msdos.h	120;"	d
MOUSE_DRAG	src/unix.h	256;"	d
MOUSE_FOCUS	src/vim.h	383;"	d
MOUSE_HELP	src/option.h	68;"	d
MOUSE_INSERT	src/option.h	66;"	d
MOUSE_LEFT	src/msdos.h	111;"	d
MOUSE_LEFT	src/unix.h	249;"	d
MOUSE_MAY_VIS	src/vim.h	384;"	d
MOUSE_MIDDLE	src/msdos.h	113;"	d
MOUSE_MIDDLE	src/unix.h	250;"	d
MOUSE_NORMAL	src/option.h	64;"	d
MOUSE_RELEASE	src/msdos.h	114;"	d
MOUSE_RELEASE	src/unix.h	252;"	d
MOUSE_RETURN	src/option.h	69;"	d
MOUSE_RIGHT	src/msdos.h	112;"	d
MOUSE_RIGHT	src/unix.h	251;"	d
MOUSE_SETPOS	src/vim.h	386;"	d
MOUSE_SHIFT	src/msdos.h	116;"	d
MOUSE_SHIFT	src/unix.h	253;"	d
MOUSE_VISUAL	src/option.h	65;"	d
MSDOS	tools/ctags/ctags.c	65;"	d	file:
MSDOS	tools/ctags/ctags.c	89;"	d	file:
MSDOS	tools/xxd/xxd.c	39;"	d	file:
MSG	src/vim.h	456;"	d
MSG_BUF_LEN	src/vim.h	405;"	d
MSG_OUTSTR	src/vim.h	462;"	d
M_NEEDMORET	src/getchar.c	888;"	d	file:
M_OFFSET	src/undo.c	788;"	d	file:
M_OFFSET	src/undo.c	791;"	d	file:
Magic	src/regexp.c	131;"	d	file:
Meta	src/ascii.h	24;"	d
NAMEDF	src/cmdtab.h	35;"	d
NAMEDFS	src/cmdtab.h	36;"	d
NAMLEN	src/unix.h	92;"	d
NAMLEN	src/unix.h	95;"	d
NARROW_PROTO	src/config.mk	/^NARROW_PROTO = $/;"	m
NEEDARG	src/cmdtab.h	22;"	d
NEWLINE	tools/ctags/ctags.c	130;"	d	file:
NEXT	src/regexp.c	169;"	d	file:
NL	src/ascii.h	15;"	d
NL_STR	src/ascii.h	16;"	d
NMARKS	src/structs.h	47;"	d
NODFL	src/cmdtab.h	21;"	d
NOP	src/ops.h	16;"	d
NORMAL	src/vim.h	198;"	d
NORMAL_BUSY	src/vim.h	202;"	d
NOSPC	src/cmdtab.h	19;"	d
NOTADR	src/cmdtab.h	29;"	d
NOTHING	src/regexp.c	110;"	d	file:
NOTRLCOM	src/cmdtab.h	26;"	d
NOT_VALID	src/vim.h	176;"	d
NO_ATTR	src/Makefile	/^NO_ATTR = -D__inline= -D"__attribute__\\\\(x\\\\)="$/;"	m
NR_TRANS	src/structs.h	/^typedef struct nr_trans NR_TRANS;$/;"	t	typeref:struct:nr_trans
NSCRIPT	src/globals.h	302;"	d
NSUBEXP	src/regexp.h	21;"	d
NUL	src/ascii.h	13;"	d
NUMBUFLEN	src/ops.c	2203;"	d	file:
NUM_EVENTS	src/vim.h	/^	NUM_EVENTS				\/* MUST be the last one *\/$/;"	e	enum:auto_events
NUM_MOUSE_CLICKS	src/msdos.h	124;"	d
NUM_MOUSE_CLICKS	src/unix.h	260;"	d
NUM_REGISTERS	src/ops.c	29;"	d	file:
NUM_REGISTERS	src/ops.c	31;"	d	file:
NameBuff	src/globals.h	/^EXTERN char_u	*NameBuff;				\/* file names are expanded in this$/;"	v
NextScreen	src/globals.h	/^EXTERN char_u 	*NextScreen INIT(= NULL);$/;"	v
OBJ	src/Makefile	/^OBJ =	alloc.o unix.o buffer.o charset.o \\$/;"	m
OK	src/vim.h	215;"	d
ONE_LINE_DATA	src/gui_at_sb.h	142;"	d
ONE_PAGE_DATA	src/gui_at_sb.h	143;"	d
OP	src/regexp.c	168;"	d	file:
OPERAND	src/regexp.c	170;"	d	file:
OSPEED_EXTERN	src/conf_os2.h	36;"	d
OUTSTR	src/vim.h	460;"	d
OUTSTRN	src/vim.h	461;"	d
O_EXTRA	src/vim.h	436;"	d
O_EXTRA	src/vim.h	438;"	d
O_NOCTTY	src/pty.c	111;"	d	file:
OpenPTY	src/pty.c	/^OpenPTY(ttyn)$/;"	f
Opencmd	src/misccmds.c	/^Opencmd(dir, redraw, del_spaces)$/;"	f
Option	tools/ctags/ctags.c	/^} Option = {$/;"	v	typeref:struct:__anon17	file:
PARAM_COUNT	src/option.c	710;"	d	file:
PATHSEP	src/ascii.h	31;"	d
PATHSEPSTR	src/ascii.h	32;"	d
PC	src/term.c	/^char *UP, *BC, PC;$/;"	v
PFLAGS	src/Makefile	/^PFLAGS = $(PROTO_FLAGS) -DPROTO $(DEFS) $(GUI_DEFS) $(EXTRA_DEFS) $(GUI_IPATH) $(X_CFLAGS)$/;"	m
PLUS	src/regexp.c	113;"	d	file:
PREFIX	src/config.mk	/^PREFIX = \/usr\/local$/;"	m
PRINT	src/regexp.c	120;"	d	file:
PRI_CURRENT	src/tag.c	227;"	d	file:
PRI_FULL_MATCH	src/tag.c	228;"	d	file:
PRI_GLOBAL	src/tag.c	226;"	d	file:
PROTO_FLAGS	src/Makefile	/^PROTO_FLAGS = -m -M__PARMS -d -E"$(CPP)" $(NO_ATTR)$/;"	m
PRO_AUTO	src/Makefile	/^PRO_AUTO = unix.pro $(ALL_GUI_PRO) \\$/;"	m
PRO_MANUAL	src/Makefile	/^PRO_MANUAL = amiga.pro msdos.pro win32.pro$/;"	m
PTR_BL	src/memline.c	/^typedef struct pointer_block	PTR_BL;		\/* contents of a pointer block *\/$/;"	t	typeref:struct:pointer_block	file:
PTR_EN	src/memline.c	/^typedef struct pointer_entry	PTR_EN;		\/* block\/line-count pair *\/$/;"	t	typeref:struct:pointer_entry	file:
PTR_ID	src/memline.c	91;"	d	file:
PTYRANGE0	src/pty.c	86;"	d	file:
PTYRANGE1	src/pty.c	89;"	d	file:
PTY_DONE	src/pty.c	135;"	d	file:
PTY_DONE	src/pty.c	154;"	d	file:
PTY_DONE	src/pty.c	181;"	d	file:
PTY_DONE	src/pty.c	209;"	d	file:
PTY_DONE	src/pty.c	238;"	d	file:
PTY_DONE	src/pty.c	277;"	d	file:
PV_AI	src/option.c	61;"	d	file:
PV_BIN	src/option.c	62;"	d	file:
PV_CIN	src/option.c	63;"	d	file:
PV_CINK	src/option.c	64;"	d	file:
PV_CINO	src/option.c	65;"	d	file:
PV_CINW	src/option.c	66;"	d	file:
PV_COM	src/option.c	67;"	d	file:
PV_EOL	src/option.c	68;"	d	file:
PV_ET	src/option.c	69;"	d	file:
PV_FO	src/option.c	70;"	d	file:
PV_INF	src/option.c	83;"	d	file:
PV_ISK	src/option.c	82;"	d	file:
PV_LBR	src/option.c	59;"	d	file:
PV_LISP	src/option.c	71;"	d	file:
PV_LIST	src/option.c	55;"	d	file:
PV_ML	src/option.c	72;"	d	file:
PV_MOD	src/option.c	73;"	d	file:
PV_NU	src/option.c	56;"	d	file:
PV_RL	src/option.c	84;"	d	file:
PV_RO	src/option.c	74;"	d	file:
PV_SCROLL	src/option.c	57;"	d	file:
PV_SI	src/option.c	75;"	d	file:
PV_SN	src/option.c	76;"	d	file:
PV_SW	src/option.c	77;"	d	file:
PV_TS	src/option.c	78;"	d	file:
PV_TW	src/option.c	79;"	d	file:
PV_TX	src/option.c	80;"	d	file:
PV_WM	src/option.c	81;"	d	file:
PV_WRAP	src/option.c	58;"	d	file:
P_ALLOCED	src/option.c	40;"	d	file:
P_BOOL	src/option.c	37;"	d	file:
P_DEF_ALLOCED	src/option.c	46;"	d	file:
P_EXPAND	src/option.c	43;"	d	file:
P_IND	src/option.c	44;"	d	file:
P_NODEFAULT	src/option.c	45;"	d	file:
P_NO_MKRC	src/option.c	49;"	d	file:
P_NUM	src/option.c	38;"	d	file:
P_STRING	src/option.c	39;"	d	file:
P_WAS_SET	src/option.c	48;"	d	file:
PeekChr	src/regexp.c	262;"	d	file:
Prenum	src/normal.c	/^static linenr_t	Prenum; 		\/* The (optional) number before a command. *\/$/;"	v	file:
PtyProto	src/pty.c	/^static char PtyProto[] = "\/dev\/ptyXY";$/;"	v	file:
PtyProto	src/pty.c	/^static char PtyProto[] = "\/dev\/ptym\/ptyXY";$/;"	v	file:
RANGE	src/cmdtab.h	15;"	d
READBIN	src/vim.h	423;"	d
READBIN	src/vim.h	427;"	d
REGEXP_ABBR	src/regexp.c	/^static char_u REGEXP_ABBR[] = "rteb";$/;"	v	file:
REGSTR	src/cmdtab.h	24;"	d
REPLACE	src/vim.h	203;"	d
RETSIGTYPE	src/conf_os2.h	92;"	d
RETSIGTYPE	src/config.h	82;"	d
RET_ERROR	src/vim.h	371;"	d
RET_WIN_BUF_CHARTABSIZE	src/charset.c	260;"	d	file:
RE_BOTH	src/vim.h	323;"	d
RE_LAST	src/vim.h	324;"	d
RE_SEARCH	src/vim.h	321;"	d
RE_SUBST	src/vim.h	322;"	d
RSHIFT	src/ops.h	21;"	d
Read	src/archie.c	/^Read(buf, maxlen)$/;"	f	file:
Read	src/unix.c	/^Read(buf, maxlen)$/;"	f	file:
RealWaitForChar	src/archie.c	/^RealWaitForChar(ticks)$/;"	f	file:
RealWaitForChar	src/unix.c	/^RealWaitForChar(fd, msec)$/;"	f	file:
Recording	src/globals.h	/^EXTERN int		Recording INIT(= FALSE);\/* TRUE when recording into a register$/;"	v
RedrawingDisabled	src/globals.h	/^EXTERN int		RedrawingDisabled INIT(= FALSE);$/;"	v
ResetRedobuff	src/getchar.c	/^ResetRedobuff()$/;"	f
Rows	src/globals.h	/^EXTERN long		Rows;					\/* number of rows in the screen *\/$/;"	v
SBUFSIZE	src/fileio.c	30;"	d	file:
SB_BOTTOM	src/gui.h	72;"	d
SB_DEFAULT_WIDTH	src/gui.h	75;"	d
SB_LEFT	src/gui.h	70;"	d
SB_NONE	src/gui.h	69;"	d
SB_RIGHT	src/gui.h	71;"	d
SB_UPDATE_CREATE	src/gui.h	66;"	d
SB_UPDATE_HEIGHT	src/gui.h	65;"	d
SB_UPDATE_NOTHING	src/gui.h	63;"	d
SB_UPDATE_VALUE	src/gui.h	64;"	d
SCOPE_EXTERN	tools/ctags/ctags.c	/^	SCOPE_EXTERN,			\/* external storage class *\/$/;"	e	enum:__anon11	file:
SCOPE_GLOBAL	tools/ctags/ctags.c	/^	SCOPE_GLOBAL,			\/* no storage class specified *\/$/;"	e	enum:__anon11	file:
SCOPE_STATIC	tools/ctags/ctags.c	/^	SCOPE_STATIC,			\/* static storage class *\/$/;"	e	enum:__anon11	file:
SCOPE_TYPEDEF	tools/ctags/ctags.c	/^	SCOPE_TYPEDEF			\/* scoping depends upon context *\/$/;"	e	enum:__anon11	file:
SEARCH_ECHO	src/vim.h	263;"	d
SEARCH_END	src/vim.h	268;"	d
SEARCH_HIS	src/vim.h	267;"	d
SEARCH_KEEP	src/vim.h	272;"	d
SEARCH_MARK	src/vim.h	271;"	d
SEARCH_MSG	src/vim.h	264;"	d
SEARCH_NFMSG	src/vim.h	265;"	d
SEARCH_NOOF	src/vim.h	269;"	d
SEARCH_OPT	src/vim.h	266;"	d
SEARCH_REV	src/vim.h	262;"	d
SEARCH_START	src/vim.h	270;"	d
SEEK_END	src/archie.c	650;"	d	file:
SEEK_END	src/unix.c	2395;"	d	file:
SEEK_SET	src/archie.c	647;"	d	file:
SEEK_SET	src/unix.c	2392;"	d	file:
SELECT_CLEARED	src/gui.h	93;"	d
SELECT_DONE	src/gui.h	95;"	d
SELECT_IN_PROGRESS	src/gui.h	94;"	d
SELECT_MODE_CHAR	src/gui.h	97;"	d
SELECT_MODE_LINE	src/gui.h	99;"	d
SELECT_MODE_WORD	src/gui.h	98;"	d
SETWSIZE	src/vim.h	206;"	d
SET_NUM_MOUSE_CLICKS	src/msdos.h	127;"	d
SET_NUM_MOUSE_CLICKS	src/unix.h	263;"	d
SFNAME	src/regexp.c	123;"	d	file:
SHELL	src/Makefile	/^SHELL = \/bin\/sh$/;"	m
SHELL_COOKED	src/vim.h	294;"	d
SHELL_EXPAND	src/vim.h	293;"	d
SHELL_FILTER	src/vim.h	292;"	d
SHM_A	src/option.h	82;"	d
SHM_ALL	src/option.h	87;"	d
SHM_FILE	src/option.h	76;"	d
SHM_LAST	src/option.h	77;"	d
SHM_LINES	src/option.h	79;"	d
SHM_MOD	src/option.h	75;"	d
SHM_NEW	src/option.h	80;"	d
SHM_OVER	src/option.h	85;"	d
SHM_RO	src/option.h	74;"	d
SHM_SEARCH	src/option.h	86;"	d
SHM_TEXT	src/option.h	78;"	d
SHM_TRUNC	src/option.h	84;"	d
SHM_WRI	src/option.h	81;"	d
SHM_WRITE	src/option.h	83;"	d
SHORT_FNAME	src/msdos.h	26;"	d
SHOWCMD_COLS	src/vim.h	475;"	d
SIDENT	src/regexp.c	121;"	d	file:
SIGDEFARG	src/unix.c	/^deathtrap SIGDEFARG(sigarg)$/;"	f	file:
SIGDEFARG	src/unix.c	/^sig_alarm SIGDEFARG(sigarg)$/;"	f	file:
SIGDEFARG	src/unix.c	/^sig_winch SIGDEFARG(sigarg)$/;"	f	file:
SIGDEFARG	src/unix.h	77;"	d
SIGDEFARG	src/unix.h	81;"	d
SIGDEFARG	src/unix.h	86;"	d
SIGDUMMYARG	src/unix.h	78;"	d
SIGDUMMYARG	src/unix.h	82;"	d
SIGDUMMYARG	src/unix.h	87;"	d
SIGHAS3ARGS	src/unix.h	71;"	d
SIGHASARG	src/unix.h	66;"	d
SIGPROTOARG	src/osdef.h	/^extern RETSIGTYPE (*sigset __ARGS((int, RETSIGTYPE (*func) SIGPROTOARG))) __PARMS(SIGPROTOARG);$/;"	v
SIGPROTOARG	src/unix.h	76;"	d
SIGPROTOARG	src/unix.h	80;"	d
SIGPROTOARG	src/unix.h	85;"	d
SIGRETURN	src/conf_os2.h	95;"	d
SIGRETURN	src/config.h	85;"	d
SIGWINCH	src/unix.c	53;"	d	file:
SIGWINCH	src/unix.c	61;"	d	file:
SIMPLE	src/regexp.c	197;"	d	file:
SINGLE_QUOTE	tools/ctags/ctags.c	133;"	d	file:
SIZEOF_INT	src/conf_os2.h	54;"	d
SIZEOF_INT	src/config.h	44;"	d
SIZEOF_INT	src/msdos.h	41;"	d
SIZEOF_INT	src/msdos.h	43;"	d
SMARTINDENT	src/feature.h	131;"	d
SMODE_CONT	src/gui_at_sb.h	136;"	d
SMODE_LINE_DOWN	src/gui_at_sb.h	140;"	d
SMODE_LINE_UP	src/gui_at_sb.h	139;"	d
SMODE_NONE	src/gui_at_sb.h	135;"	d
SMODE_PAGE_DOWN	src/gui_at_sb.h	138;"	d
SMODE_PAGE_UP	src/gui_at_sb.h	137;"	d
SOLARIS	src/unix.h	37;"	d
SOME_BUILTIN_TCAPS	src/feature.h	106;"	d
SPACE_IN_FILENAME	src/conf_os2.h	5;"	d
SPACE_IN_FILENAME	src/msdos.h	14;"	d
SPEC_AFILE	src/cmdline.c	1649;"	d	file:
SPEC_CCWORD	src/cmdline.c	1645;"	d	file:
SPEC_CFILE	src/cmdline.c	1647;"	d	file:
SPEC_COUNT	src/cmdline.c	1651;"	d	file:
SPEC_CWORD	src/cmdline.c	1643;"	d	file:
SPEC_HASH	src/cmdline.c	1641;"	d	file:
SPEC_PERC	src/cmdline.c	1639;"	d	file:
SPRINT	src/regexp.c	124;"	d	file:
SPSTART	src/regexp.c	198;"	d	file:
SRC	src/Makefile	/^SRC =	$(BASIC_SRC) $(GUI_SRC)$/;"	m
STACK_INCR	src/memline.c	195;"	d	file:
STAR	src/regexp.c	111;"	d	file:
STATFS	src/memfile.c	54;"	d	file:
STATFS	src/memfile.c	57;"	d	file:
STATUS_HEIGHT	src/vim.h	393;"	d
STRCAT	src/vim.h	453;"	d
STRCMP	src/vim.h	451;"	d
STRCPY	src/vim.h	449;"	d
STRIP	src/Makefile	/^STRIP = strip$/;"	m
STRLEN	src/vim.h	448;"	d
STRNCAT	src/vim.h	454;"	d
STRNCMP	src/vim.h	452;"	d
STRNCPY	src/vim.h	450;"	d
SVR4	src/conf_os2.h	51;"	d
SVR4	src/unix.h	30;"	d
SWORD	src/regexp.c	122;"	d	file:
SYNC_DUP_CLOSE	src/msdos.h	21;"	d
SYS_GVIMRC_FILE	src/Makefile	/^SYS_GVIMRC_FILE = $(HELPSUBLOC)\/gvimrc$/;"	m
SYS_SELECT_WITH_SYS_TIME	src/conf_os2.h	89;"	d
SYS_SELECT_WITH_SYS_TIME	src/config.h	79;"	d
SYS_VIMRC_FILE	src/Makefile	/^SYS_VIMRC_FILE  = $(HELPSUBLOC)\/vimrc$/;"	m
S_ISLNK	tools/ctags/ctags.c	165;"	d	file:
S_ISREG	tools/ctags/ctags.c	158;"	d	file:
S_ISREG	tools/ctags/ctags.c	160;"	d	file:
ScrollbarClassPart	src/gui_at_sb.h	/^typedef struct {int empty;} ScrollbarClassPart;$/;"	t	typeref:struct:__anon3
ScrollbarClassRec	src/gui_at_sb.h	/^} ScrollbarClassRec;$/;"	t	typeref:struct:_ScrollbarClassRec
ScrollbarPart	src/gui_at_sb.h	/^} ScrollbarPart;$/;"	t	typeref:struct:__anon2
ScrollbarRec	src/gui_at_sb.h	/^} ScrollbarRec;$/;"	t	typeref:struct:_ScrollbarRec
ScrollbarWidget	src/gui_at_sb.h	/^typedef struct _ScrollbarRec	  *ScrollbarWidget;$/;"	t	typeref:struct:_ScrollbarRec
ScrollbarWidgetClass	src/gui_at_sb.h	/^typedef struct _ScrollbarClassRec *ScrollbarWidgetClass;$/;"	t	typeref:struct:_ScrollbarClassRec
SearchedFile	src/search.c	/^typedef struct SearchedFile$/;"	s	file:
SearchedFile	src/search.c	/^} SearchedFile;$/;"	t	typeref:struct:SearchedFile	file:
Self	tools/mvi/mvi.c	/^static char *Self;         \/* Program name (argument zero) *\/$/;"	v	file:
Signal	tools/mvi/mvi.c	46;"	d	file:
SpecialKeys	src/term.h	/^enum SpecialKeys$/;"	g
Sprintf	tools/mvi/mvi.c	45;"	d	file:
State	src/globals.h	/^EXTERN int		State INIT(= NORMAL);	\/* This is the current state of the$/;"	v
T	macros/maze/maze.c	/^char*M,A,Z,E=40,J[40],T[40];main(C){for(*J=A=scanf(M="%d",&C);$/;"	v
T	macros/maze/mazeansi.c	/^char*M,A,Z,E=40,J[80],T[3];main(C){for(M=J+E,*J=A=scanf("%d",&$/;"	v
TAB	src/ascii.h	14;"	d
TAGSTACKSIZE	src/structs.h	49;"	d
TAG_BLOCKTAG	tools/ctags/ctags.c	/^	TAG_BLOCKTAG,			\/* enum\/struct\/union tag or C++ class name *\/$/;"	e	enum:__anon9	file:
TAG_DEFINE	tools/ctags/ctags.c	/^	TAG_DEFINE,				\/* C pre-processor define *\/$/;"	e	enum:__anon9	file:
TAG_ENUM	tools/ctags/ctags.c	/^	TAG_ENUM,				\/* enumeration value *\/$/;"	e	enum:__anon9	file:
TAG_FUNCDECL	tools/ctags/ctags.c	/^	TAG_FUNCDECL,			\/* function declaration *\/$/;"	e	enum:__anon9	file:
TAG_FUNCTION	tools/ctags/ctags.c	/^	TAG_FUNCTION,			\/* function definition *\/$/;"	e	enum:__anon9	file:
TAG_NUMTYPES	tools/ctags/ctags.c	/^	TAG_NUMTYPES			\/* must be last *\/$/;"	e	enum:__anon9	file:
TAG_TYPEDEF	tools/ctags/ctags.c	/^	TAG_TYPEDEF,			\/* typedef name *\/$/;"	e	enum:__anon9	file:
TAG_VARIABLE	tools/ctags/ctags.c	/^	TAG_VARIABLE,			\/* variable defintion *\/$/;"	e	enum:__anon9	file:
TARGET	src/Makefile	/^TARGET = vim$/;"	m
TBUFSZ	src/vim.h	410;"	d
TBUFSZ	src/vim.h	412;"	d
TERMBUFSIZE	src/vim.h	407;"	d
TERMCAP2KEY	src/keymap.h	83;"	d
TERMINFO	src/conf_os2.h	30;"	d
TERMINFO	src/config.h	20;"	d
TEXT_X	src/gui.h	40;"	d
TEXT_Y	src/gui.h	41;"	d
TGETENT	src/term.c	113;"	d	file:
TGETSTR	src/term.c	112;"	d	file:
TGETSTR_CHAR_P	src/conf_os2.h	101;"	d
TILDE	src/ops.h	23;"	d
TILDE	src/regexp.c	210;"	d	file:
TIME_WITH_SYS_TIME	src/conf_os2.h	86;"	d
TIME_WITH_SYS_TIME	src/config.h	76;"	d
TIOCGWINSZ	src/unix.c	56;"	d	file:
TMPNAME1	src/msdos.h	93;"	d
TMPNAME1	src/unix.h	207;"	d
TMPNAME2	src/msdos.h	94;"	d
TMPNAME2	src/unix.h	208;"	d
TMPNAMELEN	src/msdos.h	95;"	d
TMPNAMELEN	src/unix.h	209;"	d
TOK_ARGS	tools/ctags/ctags.c	/^	 TOK_ARGS,				\/* a parenthetical pair and its contents *\/$/;"	e	enum:__anon10	file:
TOK_BODY	tools/ctags/ctags.c	/^	 TOK_BODY,				\/* a brace enclosed block *\/$/;"	e	enum:__anon10	file:
TOK_COMMA	tools/ctags/ctags.c	/^	 TOK_COMMA,				\/* the comma character *\/$/;"	e	enum:__anon10	file:
TOK_ENUM_BODY_END	tools/ctags/ctags.c	/^	 TOK_ENUM_BODY_END,		\/* the beginning of a list of enumeration values *\/$/;"	e	enum:__anon10	file:
TOK_EOF	tools/ctags/ctags.c	/^	 TOK_EOF,				\/* end of file *\/$/;"	e	enum:__anon10	file:
TOK_IGNORE	tools/ctags/ctags.c	/^	 TOK_IGNORE,			\/* a sequence not to be seen by createTags() *\/$/;"	e	enum:__anon10	file:
TOK_NAME	tools/ctags/ctags.c	/^	 TOK_NAME,				\/* an unknown name *\/$/;"	e	enum:__anon10	file:
TOK_SEMICOLON	tools/ctags/ctags.c	/^	 TOK_SEMICOLON,			\/* the semicolon character *\/$/;"	e	enum:__anon10	file:
TOK_SPEC	tools/ctags/ctags.c	/^	 TOK_SPEC				\/* a storage class, qualifier, type, etc. *\/$/;"	e	enum:__anon10	file:
TO_LOWER	src/macros.h	44;"	d
TO_LOWER	src/macros.h	47;"	d
TO_SPECIAL	src/keymap.h	97;"	d
TO_UPPER	src/macros.h	43;"	d
TO_UPPER	src/macros.h	46;"	d
TPUTSFUNCAST	src/term.c	41;"	d	file:
TPUTSFUNCAST	src/term.c	44;"	d	file:
TPUTSFUNCAST	src/term.c	46;"	d	file:
TRLBAR	src/cmdtab.h	23;"	d
TRUE	src/vim.h	365;"	d
TRUE	tools/ctags/ctags.c	/^typedef enum { FALSE, TRUE } boolean;$/;"	e	enum:__anon7	file:
TRUE	tools/ctags/ctags.c	173;"	d	file:
TRY_SEEK	tools/xxd/xxd.c	65;"	d	file:
TYPELEN_INIT	src/getchar.c	91;"	d	file:
T_AL	src/term.h	81;"	d
T_CAL	src/term.h	82;"	d
T_CD	src/term.h	87;"	d
T_CDL	src/term.h	84;"	d
T_CE	src/term.h	80;"	d
T_CL	src/term.h	86;"	d
T_CM	src/term.h	103;"	d
T_CRI	src/term.h	105;"	d
T_CS	src/term.h	85;"	d
T_CSC	src/term.h	111;"	d
T_CZH	src/term.h	98;"	d
T_CZR	src/term.h	99;"	d
T_DA	src/term.h	88;"	d
T_DB	src/term.h	89;"	d
T_DL	src/term.h	83;"	d
T_KE	src/term.h	108;"	d
T_KS	src/term.h	107;"	d
T_MD	src/term.h	95;"	d
T_ME	src/term.h	93;"	d
T_MR	src/term.h	94;"	d
T_MS	src/term.h	102;"	d
T_SE	src/term.h	96;"	d
T_SO	src/term.h	97;"	d
T_SR	src/term.h	104;"	d
T_TE	src/term.h	110;"	d
T_TI	src/term.h	109;"	d
T_UE	src/term.h	100;"	d
T_US	src/term.h	101;"	d
T_VB	src/term.h	106;"	d
T_VE	src/term.h	91;"	d
T_VI	src/term.h	90;"	d
T_VS	src/term.h	92;"	d
TagFile	tools/ctags/ctags.c	/^} TagFile = { NULL, NULL, 0, { 0, 0, 0 } };$/;"	v	typeref:struct:__anon19	file:
TagTypeNames	tools/ctags/ctags.c	/^static const char *TagTypeNames[] = {$/;"	v	file:
TtyProto	src/pty.c	/^static char TtyProto[] = "\/dev\/pty\/ttyXY";$/;"	v	file:
TtyProto	src/pty.c	/^static char TtyProto[] = "\/dev\/ttyXY";$/;"	v	file:
UCHARAT	src/regexp.c	176;"	d	file:
UCHARAT	src/regexp.c	178;"	d	file:
UCHARAT	src/regsub.c	65;"	d	file:
UCHARAT	src/regsub.c	67;"	d	file:
UH_CHANGED	src/structs.h	113;"	d
UH_EMPTYBUF	src/structs.h	114;"	d
UNCHANGED	src/vim.h	442;"	d
UNIX	src/conf_os2.h	50;"	d
UNIX	src/config.h	40;"	d
UNKNOWN	src/fileio.c	101;"	d	file:
UP	src/term.c	/^char *UP, *BC, PC;$/;"	v
UPPER	src/ops.h	27;"	d
UP_BC_PC_EXTERN	src/conf_os2.h	42;"	d
USAGE_ARG_MISSING	src/main.c	28;"	d	file:
USAGE_GARBAGE	src/main.c	29;"	d	file:
USAGE_TOO_MANY_ARGS	src/main.c	27;"	d	file:
USAGE_UNKNOWN_OPTION	src/main.c	26;"	d	file:
USEBCOPY	src/conf_os2.h	60;"	d
USECTRLV	src/cmdtab.h	28;"	d
USEMEMCPY	src/conf_os2.h	62;"	d
USEMEMMOVE	src/conf_os2.h	61;"	d
USEMEMMOVE	src/config.h	51;"	d
USE_CRNL	src/conf_os2.h	8;"	d
USE_CRNL	src/msdos.h	17;"	d
USE_FNAME_CASE	src/msdos.h	24;"	d
USE_GETCWD	src/unix.h	47;"	d
USE_GUI	src/vim.h	30;"	d
USE_GUI_X11	src/gui.h	15;"	d
USE_GUI_X11	src/gui.h	24;"	d
USE_LONG_FNAME	src/msdos.h	23;"	d
USE_MOUSE	src/msdos.h	20;"	d
USE_MOUSE	src/unix.h	219;"	d
USE_NL	src/screen.c	2622;"	d	file:
USE_T_AL	src/screen.c	2618;"	d	file:
USE_T_CAL	src/screen.c	2616;"	d	file:
USE_T_CD	src/screen.c	2623;"	d	file:
USE_T_CDL	src/screen.c	2617;"	d	file:
USE_T_CE	src/screen.c	2619;"	d	file:
USE_T_DL	src/screen.c	2620;"	d	file:
USE_T_SR	src/screen.c	2621;"	d	file:
USE_VIM_CHDIR	src/msdos.h	19;"	d
USE_VIM_REMOVE	src/msdos.h	18;"	d
USING_PROTOTYPES	tools/ctags/ctags.c	94;"	d	file:
USING_PROTOTYPES	tools/ctags/ctags.c	97;"	d	file:
USR_EXRC_FILE	src/msdos.h	64;"	d
USR_EXRC_FILE	src/unix.h	158;"	d
USR_GVIMRC_FILE	src/unix.h	167;"	d
USR_VIMRC_FILE	src/msdos.h	60;"	d
USR_VIMRC_FILE	src/unix.h	162;"	d
Unlink	tools/mvi/mvi.c	/^Unlink( name )$/;"	f	file:
VALID	src/vim.h	173;"	d
VALID_TO_CURSCHAR	src/vim.h	175;"	d
VERSION	tools/ctags/ctags.c	86;"	d	file:
VIMINFO	src/feature.h	77;"	d
VIMINFO_FILE	src/msdos.h	81;"	d
VIMINFO_FILE	src/unix.h	187;"	d
VIMRC_FILE	src/msdos.h	68;"	d
VIMRC_FILE	src/unix.h	176;"	d
VIMVERSION	src/Makefile	/^	VIMVERSION=$(VIMVERSION); cd ..\/..\/..; set -x; \\$/;"	m
VIMVERSION	src/Makefile	/^VIMVERSION = `eval "basename \\`cd ..\/..\/; pwd\\`"`$/;"	m
VIM_HLP	src/Makefile	/^VIM_HLP = $(HELPSUBLOC)\/vim_help.txt$/;"	m
VIM_HLP	src/msdos.h	76;"	d
VIM_MEMMOVE	src/unix.h	243;"	d
VIM_VERSION_BUILD	src/version.h	27;"	d
VIM_VERSION_BUILD_STR	src/version.h	28;"	d
VIM_VERSION_MAJOR	src/version.h	21;"	d
VIM_VERSION_MAJOR_STR	src/version.h	22;"	d
VIM_VERSION_MINOR	src/version.h	24;"	d
VIM_VERSION_MINOR_STR	src/version.h	25;"	d
VIM_VERSION_PATCHLEVEL	src/version.h	30;"	d
VIM_VERSION_PATCHLEVEL_STR	src/version.h	31;"	d
VISUAL	src/vim.h	199;"	d
VIsual	src/globals.h	/^EXTERN FPOS 	VIsual; 		\/* start position of Visual *\/$/;"	v
VIsual_active	src/globals.h	/^EXTERN int		VIsual_active INIT(= FALSE);$/;"	v
VIsual_end	src/globals.h	/^EXTERN FPOS 	VIsual_end;		\/* end position of Visual; set when$/;"	v
VIsual_mode	src/globals.h	/^EXTERN int		VIsual_mode INIT(= 'v');$/;"	v
VIsual_mode_save	src/globals.h	/^EXTERN int		VIsual_mode_save;$/;"	v
VIsual_save	src/globals.h	/^EXTERN FPOS		VIsual_save;	\/* copy of VIsual before 'v' command *\/$/;"	v
Verbose	tools/mvi/mvi.c	/^static int Verbose= 0;     \/* If we echo each renaming to stderr *\/$/;"	v	file:
Version	src/version.c	/^char		   *Version = "VIM 4.0";$/;"	v
WANT_X11	src/feature.h	253;"	d
WEXITSTATUS	src/unixunix.h	38;"	d
WEXITSTATUS	src/unixunix.h	40;"	d
WIFEXITED	src/unixunix.h	46;"	d
WIFEXITED	src/unixunix.h	48;"	d
WILD_ALL	src/vim.h	242;"	d
WILD_EXPAND_FREE	src/vim.h	238;"	d
WILD_EXPAND_KEEP	src/vim.h	239;"	d
WILD_FREE	src/vim.h	237;"	d
WILD_HOME_REPLACE	src/vim.h	246;"	d
WILD_LIST_NOTFOUND	src/vim.h	245;"	d
WILD_LONGEST	src/vim.h	243;"	d
WILD_NEXT	src/vim.h	240;"	d
WILD_PREV	src/vim.h	241;"	d
WIN	src/structs.h	/^typedef struct window		WIN;$/;"	t	typeref:struct:window
WINLNUM	src/structs.h	/^typedef struct winlnum		WINLNUM;$/;"	t	typeref:struct:winlnum
WORD	src/regexp.c	118;"	d	file:
WORD1	src/cmdtab.h	33;"	d
WORST	src/regexp.c	199;"	d	file:
WRITEBACKUP	src/feature.h	152;"	d
WRITEBIN	src/vim.h	422;"	d
WRITEBIN	src/vim.h	426;"	d
WW_ALL	src/option.h	61;"	d
W_OK	src/unix.h	150;"	d
Wait	tools/mvi/mvi.c	47;"	d	file:
WaitForChar	src/archie.c	/^WaitForChar(ticks)$/;"	f	file:
WaitForChar	src/msdos.c	/^WaitForChar(msec)$/;"	f	file:
WaitForChar	src/unix.c	/^WaitForChar(msec)$/;"	f	file:
XAW_LIB	src/Makefile	/^XAW_LIB = -lXaw$/;"	m
XFILE	src/cmdtab.h	18;"	d
XREF_TMP	tools/ctags/ctags.c	102;"	d	file:
XREF_TMP	tools/ctags/ctags.c	104;"	d	file:
XShapeQueryExtension	src/configure	/^XShapeQueryExtension()$/;"	f
X_2_COL	src/gui.h	45;"	d
X_CFLAGS	src/config.mk	/^X_CFLAGS = -I\/usr\/X11R6\/include $/;"	m
X_EXTRA_LIBS	src/config.mk	/^X_EXTRA_LIBS = $/;"	m
X_LIBS	src/config.mk	/^X_LIBS = -lX11$/;"	m
X_LIBS_DIR	src/config.mk	/^X_LIBS_DIR =  -L\/usr\/X11R6\/lib$/;"	m
X_PRE_LIBS	src/config.mk	/^X_PRE_LIBS =  -lSM -lICE$/;"	m
XtCBottomShadowPixel	src/gui_at_sb.h	81;"	d
XtCMaxOfThumb	src/gui_at_sb.h	78;"	d
XtCMinimumThumb	src/gui_at_sb.h	75;"	d
XtCShadowWidth	src/gui_at_sb.h	79;"	d
XtCShown	src/gui_at_sb.h	76;"	d
XtCTopOfThumb	src/gui_at_sb.h	77;"	d
XtCTopShadowPixel	src/gui_at_sb.h	80;"	d
XtNbottomShadowPixel	src/gui_at_sb.h	88;"	d
XtNmaxOfThumb	src/gui_at_sb.h	85;"	d
XtNminimumThumb	src/gui_at_sb.h	83;"	d
XtNshadowWidth	src/gui_at_sb.h	86;"	d
XtNtopOfThumb	src/gui_at_sb.h	84;"	d
XtNtopShadowPixel	src/gui_at_sb.h	87;"	d
YANK	src/ops.h	18;"	d
Y_2_ROW	src/gui.h	46;"	d
Z	macros/maze/maze.c	/^char*M,A,Z,E=40,J[40],T[40];main(C){for(*J=A=scanf(M="%d",&C);$/;"	v
Z	macros/maze/mazeansi.c	/^char*M,A,Z,E=40,J[80],T[3];main(C){for(M=J+E,*J=A=scanf("%d",&$/;"	v
ZEROR	src/cmdtab.h	27;"	d
ZERO_BL	src/memline.c	/^typedef struct block0			ZERO_BL;	\/* contents of the first block *\/$/;"	t	typeref:struct:block0	file:
_IO_PTEM_H	src/unixunix.h	77;"	d
_REGEXP_H	src/regexp.h	19;"	d
_ScrollbarClassRec	src/gui_at_sb.h	/^typedef struct _ScrollbarClassRec {$/;"	s
_ScrollbarRec	src/gui_at_sb.h	/^typedef struct _ScrollbarRec {$/;"	s
_Scrollbar_h	src/gui_at_sb.h	60;"	d
__ARGS	src/regsub.c	/^typedef void (*(*fptr) __ARGS((char_u *, int)))();$/;"	t	file:
__ARGS	src/regsub.c	54;"	d	file:
__ARGS	src/regsub.c	74;"	d	file:
__ARGS	src/regsub.c	75;"	d	file:
__ARGS	src/unix.h	146;"	d
__ARGS	src/unix.h	52;"	d
__ARGS	src/unix.h	54;"	d
__ARGS	src/vim.h	41;"	d
__ARGS	src/vim.h	47;"	d
__ARGS	src/vim.h	53;"	d
__ARGS	src/vim.h	58;"	d
__ARGS	src/vim.h	71;"	d
__ARGS	src/vim.h	73;"	d
__ARGS	tools/ctags/ctags.c	93;"	d	file:
__ARGS	tools/ctags/ctags.c	96;"	d	file:
__PARMS	src/vim.h	42;"	d
__PARMS	src/vim.h	48;"	d
__PARMS	src/vim.h	54;"	d
__PARMS	src/vim.h	79;"	d
accept	tools/ctags/ctags.c	/^		boolean		accept;		\/* is a directive syntatically permitted? *\/$/;"	m	struct:__anon22::__anon23	file:
add_buff	src/getchar.c	/^add_buff(buf, s)$/;"	f	file:
add_char_buff	src/getchar.c	/^add_char_buff(buf, c)$/;"	f	file:
add_completion	src/edit.c	/^add_completion(str, len, fname, dir)$/;"	f	file:
add_completion_and_infercase	src/edit.c	/^add_completion_and_infercase(str, len, fname, dir)$/;"	f
add_long_to_buf	src/term.c	/^add_long_to_buf(val, dst)$/;"	f
add_num_buff	src/getchar.c	/^add_num_buff(buf, n)$/;"	f	file:
add_termcap_entry	src/term.c	/^add_termcap_entry(name, force)$/;"	f
add_termcode	src/term.c	/^add_termcode(name, string)$/;"	f
add_to_history	src/cmdline.c	/^add_to_history(histype, new_entry)$/;"	f
add_to_input_buf	src/unix.c	/^add_to_input_buf(s, len)$/;"	f
add_to_showcmd	src/normal.c	/^add_to_showcmd(c, display_always)$/;"	f
addfile	src/msdos.c	/^addfile(fl, f, isdir)$/;"	f	file:
addstar	src/cmdline.c	/^addstar(fname, len)$/;"	f
adjust_cursor	src/linefunc.c	/^adjust_cursor()$/;"	f
adr	src/quickfix.c	/^	char_u			*(adr[MAX_ADDR]);	\/* addresses used *\/$/;"	m	struct:eformat	file:
adr	src/quickfix.c	/^	void			*(adr[MAX_ADDR]);$/;"	m	struct:eformat	file:
adr_cnt	src/quickfix.c	/^	int				adr_cnt;		\/* number of addresses used *\/$/;"	m	struct:eformat	file:
afterNL	tools/ctags/ctags.c	/^	boolean	afterNL;		\/* boolean: was previous character a newline? *\/$/;"	m	struct:__anon21	file:
after_label	src/misccmds.c	/^after_label(l)$/;"	f	file:
aixhack	src/pty.c	/^int aixhack = -1;$/;"	v
all_cflags	src/Makefile	/^	-@echo 'char_u *all_cflags = (char_u *)"$(CC) -c -I$(srcdir) $(ALL_CFLAGS)";' >> pathdef.c$/;"	m
all_cflags	src/pathdef.c	/^char_u *all_cflags = (char_u *)"gcc -c -I. -DHAVE_CONFIG_H    -g -I\/usr\/X11R6\/include ";$/;"	v
alloc	src/alloc.c	/^alloc(size)$/;"	f
alloc_check	src/alloc.c	/^alloc_check(size)$/;"	f
alloc_cmdbuff	src/cmdline.c	/^alloc_cmdbuff(len)$/;"	f
allow_directories	src/option.c	/^	int				allow_directories;		\/* Pattern may match whole path *\/$/;"	m	struct:AutoPat	file:
allow_keys	src/globals.h	/^EXTERN int		allow_keys INIT(= FALSE);	\/* allow key codes when no_mapping$/;"	v
analyzeIdentifier	tools/ctags/ctags.c	/^static void analyzeIdentifier( st )$/;"	f	file:
analyzeParens	tools/ctags/ctags.c	/^static boolean analyzeParens( st )$/;"	f	file:
append	tools/ctags/ctags.c	/^	boolean	append;			\/* -a  append to "tags" files *\/$/;"	m	struct:__anon17	file:
append_arg_number	src/buffer.c	/^append_arg_number(buf, add_file)$/;"	f	file:
applyTagInclusionList	tools/ctags/ctags.c	/^static void applyTagInclusionList( list )$/;"	f	file:
apply_autocmds	src/option.c	/^apply_autocmds(event, fname, fname_io)$/;"	f
arg_count	src/globals.h	/^EXTERN int		arg_count;	 	\/* number of files *\/$/;"	v
arg_exp	src/globals.h	/^EXTERN int		arg_exp;		\/* when TRUE arg_files must be freed *\/$/;"	v
arg_files	src/globals.h	/^EXTERN char_u	**arg_files;	\/* list of files *\/$/;"	v
arg_had_last	src/globals.h	/^EXTERN int		arg_had_last INIT(= FALSE);	\/* accessed last file in arglist *\/$/;"	v
arrow_used	src/globals.h	/^EXTERN int		arrow_used;				\/* Normally FALSE, set to TRUE after$/;"	v
ask_yesno	src/misccmds.c	/^ask_yesno(str, direct)$/;"	f
at_start	src/regexp.c	/^static int		at_start;	\/* True when we are on the first character *\/$/;"	v	file:
atom	src/gui.h	/^	Atom		atom;				\/* Vim's own special selection format *\/$/;"	m	struct:GuiSelection
attributes	src/screen.c	/^static int		attributes = 0;	\/* current attributes for screen character*\/$/;"	v	file:
auto_events	src/vim.h	/^enum auto_events$/;"	g
autocmd_busy	src/globals.h	/^EXTERN int		autocmd_busy INIT(= FALSE);	\/* Is apply_autocmds() busy? *\/$/;"	v
autocmd_fname	src/globals.h	/^EXTERN char_u	*autocmd_fname INIT(= NULL); \/* fname for "^Vf" on cmdline *\/$/;"	v
autowrite	src/cmdline.c	/^autowrite(buf)$/;"	f
autowrite_all	src/cmdline.c	/^autowrite_all()$/;"	f
b0_fname	src/memline.c	/^	char_u		b0_fname[B0_FNAME_SIZE]; \/* name of file being edited *\/$/;"	m	struct:block0	file:
b0_hname	src/memline.c	/^	char_u		b0_hname[B0_HNAME_SIZE]; \/* host name (if it has a name) *\/$/;"	m	struct:block0	file:
b0_id	src/memline.c	/^	char_u		b0_id[2];		\/* id for block 0: BLOCK0_ID0 and BLOCK0_ID1 *\/$/;"	m	struct:block0	file:
b0_ino	src/memline.c	/^	char_u		b0_ino[4];		\/* inode of b0_fname *\/$/;"	m	struct:block0	file:
b0_magic_char	src/memline.c	/^	char_u		b0_magic_char;	\/* check for last char *\/$/;"	m	struct:block0	file:
b0_magic_int	src/memline.c	/^	int			b0_magic_int;	\/* check for byte order of int *\/$/;"	m	struct:block0	file:
b0_magic_long	src/memline.c	/^	long		b0_magic_long;	\/* check for byte order of long *\/$/;"	m	struct:block0	file:
b0_magic_short	src/memline.c	/^	short		b0_magic_short;	\/* check for byte order of short *\/$/;"	m	struct:block0	file:
b0_magic_wrong	src/memline.c	/^b0_magic_wrong(b0p)$/;"	f	file:
b0_mtime	src/memline.c	/^	char_u		b0_mtime[4];	\/* last modification time of file *\/$/;"	m	struct:block0	file:
b0_page_size	src/memline.c	/^	char_u		b0_page_size[4];\/* number of bytes per page *\/$/;"	m	struct:block0	file:
b0_pid	src/memline.c	/^	char_u		b0_pid[4];		\/* process id of creator (or 0) *\/$/;"	m	struct:block0	file:
b0_uname	src/memline.c	/^	char_u		b0_uname[B0_UNAME_SIZE]; \/* name of user (uid if no name) *\/$/;"	m	struct:block0	file:
b0_version	src/memline.c	/^	char_u		b0_version[10];	\/* Vim version string *\/$/;"	m	struct:block0	file:
b_block_head	src/structs.h	/^	struct m_block	 b_block_head;		\/* head of allocated memory block list *\/$/;"	m	struct:buffer	typeref:struct:buffer::m_block
b_changed	src/structs.h	/^	int				 b_changed;			\/* 'modified': Set to TRUE if$/;"	m	struct:buffer
b_chartab	src/structs.h	/^	char			 b_chartab[256];$/;"	m	struct:buffer
b_did_warn	src/structs.h	/^	char			 b_did_warn;	\/* Set to 1 if user has been warned on$/;"	m	struct:buffer
b_filename	src/structs.h	/^	char_u			*b_filename;$/;"	m	struct:buffer
b_fnum	src/structs.h	/^	int				 b_fnum;			\/* file number for this file. *\/$/;"	m	struct:buffer
b_help	src/structs.h	/^	char			 b_help;		\/* buffer for help file *\/$/;"	m	struct:buffer
b_last_cursor	src/structs.h	/^	FPOS			 b_last_cursor;		\/* cursor position when last unloading$/;"	m	struct:buffer
b_m_search	src/structs.h	/^	info_t			*b_m_search;	 	\/* pointer to chunk before previously$/;"	m	struct:buffer
b_marks_read	src/structs.h	/^	int				 b_marks_read;		\/* Have we read viminfo marks yet? *\/$/;"	m	struct:buffer
b_mb_current	src/structs.h	/^	struct m_block	*b_mb_current;		\/* block where m_search points in *\/$/;"	m	struct:buffer	typeref:struct:buffer::m_block
b_ml	src/structs.h	/^	MEMLINE			 b_ml;				\/* associated memline (also contains$/;"	m	struct:buffer
b_mtime	src/structs.h	/^	long			 b_mtime;			\/* last change time of original file *\/$/;"	m	struct:buffer
b_mtime_read	src/structs.h	/^	long			 b_mtime_read;		\/* last change time when reading *\/$/;"	m	struct:buffer
b_namedm	src/structs.h	/^	FPOS          	 b_namedm[NMARKS];	\/* current named marks (mark.c) *\/$/;"	m	struct:buffer
b_neverloaded	src/structs.h	/^	int				 b_neverloaded;		\/* file has never been loaded into$/;"	m	struct:buffer
b_next	src/getchar.c	/^		struct bufblock *b_next;		\/* pointer to next bufblock *\/$/;"	m	struct:bufblock	typeref:struct:bufblock::bufblock	file:
b_next	src/structs.h	/^	BUF				*b_next;			\/* links in list of buffers *\/$/;"	m	struct:buffer
b_notedited	src/structs.h	/^	int				 b_notedited;		\/* Set to TRUE when file name is$/;"	m	struct:buffer
b_nwindows	src/structs.h	/^	int              b_nwindows;		\/* nr of windows open on this buffer *\/$/;"	m	struct:buffer
b_op_end	src/structs.h	/^	FPOS			 b_op_end;$/;"	m	struct:buffer
b_op_start	src/structs.h	/^	FPOS			 b_op_start;$/;"	m	struct:buffer
b_p_ai	src/structs.h	/^	int				 b_p_ai, b_p_ro, b_p_lisp;$/;"	m	struct:buffer
b_p_ai_save	src/structs.h	/^	int				 b_p_ai_save, b_p_lisp_save;$/;"	m	struct:buffer
b_p_bin	src/structs.h	/^	int				 b_p_bin, b_p_eol, b_p_et, b_p_ml, b_p_tx;$/;"	m	struct:buffer
b_p_cin	src/structs.h	/^	int				 b_p_cin;		\/* use C progam indent mode *\/$/;"	m	struct:buffer
b_p_cin_save	src/structs.h	/^	int				 b_p_cin_save;	\/* b_p_cin saved for paste mode *\/$/;"	m	struct:buffer
b_p_cink	src/structs.h	/^	char_u			*b_p_cink;		\/* C progam indent mode keys *\/$/;"	m	struct:buffer
b_p_cino	src/structs.h	/^	char_u			*b_p_cino;		\/* C progam indent mode options *\/$/;"	m	struct:buffer
b_p_cinw	src/structs.h	/^	char_u			*b_p_cinw;		\/* words extra indent for 'si' and 'cin' *\/$/;"	m	struct:buffer
b_p_com	src/structs.h	/^	char_u			*b_p_fo, *b_p_com, *b_p_isk;$/;"	m	struct:buffer
b_p_eol	src/structs.h	/^	int				 b_p_bin, b_p_eol, b_p_et, b_p_ml, b_p_tx;$/;"	m	struct:buffer
b_p_et	src/structs.h	/^	int				 b_p_bin, b_p_eol, b_p_et, b_p_ml, b_p_tx;$/;"	m	struct:buffer
b_p_et_nobin	src/structs.h	/^	int				 b_p_ml_nobin, b_p_et_nobin;$/;"	m	struct:buffer
b_p_fo	src/structs.h	/^	char_u			*b_p_fo, *b_p_com, *b_p_isk;$/;"	m	struct:buffer
b_p_inf	src/structs.h	/^	int				 b_p_inf; 			\/* infer case of ^N\/^P completions *\/$/;"	m	struct:buffer
b_p_initialized	src/structs.h	/^	int				 b_p_initialized;	\/* set when options initialized *\/$/;"	m	struct:buffer
b_p_isk	src/structs.h	/^	char_u			*b_p_fo, *b_p_com, *b_p_isk;$/;"	m	struct:buffer
b_p_lisp	src/structs.h	/^	int				 b_p_ai, b_p_ro, b_p_lisp;$/;"	m	struct:buffer
b_p_lisp_save	src/structs.h	/^	int				 b_p_ai_save, b_p_lisp_save;$/;"	m	struct:buffer
b_p_ml	src/structs.h	/^	int				 b_p_bin, b_p_eol, b_p_et, b_p_ml, b_p_tx;$/;"	m	struct:buffer
b_p_ml_nobin	src/structs.h	/^	int				 b_p_ml_nobin, b_p_et_nobin;$/;"	m	struct:buffer
b_p_ro	src/structs.h	/^	int				 b_p_ai, b_p_ro, b_p_lisp;$/;"	m	struct:buffer
b_p_si	src/structs.h	/^	int				 b_p_si, b_p_si_save;$/;"	m	struct:buffer
b_p_si_save	src/structs.h	/^	int				 b_p_si, b_p_si_save;$/;"	m	struct:buffer
b_p_sn	src/structs.h	/^	int				 b_p_sn;$/;"	m	struct:buffer
b_p_sw	src/structs.h	/^	long			 b_p_sw, b_p_ts, b_p_tw, b_p_wm;$/;"	m	struct:buffer
b_p_ta_nobin	src/structs.h	/^	int				 b_p_tx_nobin, b_p_ta_nobin;$/;"	m	struct:buffer
b_p_ts	src/structs.h	/^	long			 b_p_sw, b_p_ts, b_p_tw, b_p_wm;$/;"	m	struct:buffer
b_p_tw	src/structs.h	/^	long			 b_p_sw, b_p_ts, b_p_tw, b_p_wm;$/;"	m	struct:buffer
b_p_tw_nobin	src/structs.h	/^	long			 b_p_wm_nobin, b_p_tw_nobin;$/;"	m	struct:buffer
b_p_tw_save	src/structs.h	/^	long			 b_p_tw_save, b_p_wm_save;$/;"	m	struct:buffer
b_p_tx	src/structs.h	/^	int				 b_p_bin, b_p_eol, b_p_et, b_p_ml, b_p_tx;$/;"	m	struct:buffer
b_p_tx_nobin	src/structs.h	/^	int				 b_p_tx_nobin, b_p_ta_nobin;$/;"	m	struct:buffer
b_p_wm	src/structs.h	/^	long			 b_p_sw, b_p_ts, b_p_tw, b_p_wm;$/;"	m	struct:buffer
b_p_wm_nobin	src/structs.h	/^	long			 b_p_wm_nobin, b_p_tw_nobin;$/;"	m	struct:buffer
b_p_wm_save	src/structs.h	/^	long			 b_p_tw_save, b_p_wm_save;$/;"	m	struct:buffer
b_prev	src/structs.h	/^	BUF				*b_prev;$/;"	m	struct:buffer
b_sfilename	src/structs.h	/^	char_u			*b_sfilename;$/;"	m	struct:buffer
b_shortname	src/structs.h	/^	int				 b_shortname;	\/* this file has an 8.3 filename *\/$/;"	m	struct:buffer
b_str	src/getchar.c	/^		char_u			b_str[1];		\/* contents (actually longer) *\/$/;"	m	struct:bufblock	file:
b_u_curhead	src/structs.h	/^	struct u_header	*b_u_curhead;		\/* pointer to current header *\/$/;"	m	struct:buffer	typeref:struct:buffer::u_header
b_u_line_colnr	src/structs.h	/^	colnr_t			 b_u_line_colnr;	\/* optional column number *\/$/;"	m	struct:buffer
b_u_line_lnum	src/structs.h	/^	linenr_t		 b_u_line_lnum;		\/* line number of line in u_line *\/$/;"	m	struct:buffer
b_u_line_ptr	src/structs.h	/^	char_u			*b_u_line_ptr;		\/* saved line for "U" command *\/$/;"	m	struct:buffer
b_u_newhead	src/structs.h	/^	struct u_header	*b_u_newhead;		\/* pointer to newest header *\/$/;"	m	struct:buffer	typeref:struct:buffer::u_header
b_u_numhead	src/structs.h	/^	int				 b_u_numhead;		\/* current number of headers *\/$/;"	m	struct:buffer
b_u_oldhead	src/structs.h	/^	struct u_header	*b_u_oldhead;		\/* pointer to oldest header *\/$/;"	m	struct:buffer	typeref:struct:buffer::u_header
b_u_synced	src/structs.h	/^	int				 b_u_synced;		\/* entry lists are synced *\/$/;"	m	struct:buffer
b_winlnum	src/structs.h	/^	WINLNUM			*b_winlnum;			\/* list of last used lnum for$/;"	m	struct:buffer
b_xfilename	src/structs.h	/^	char_u			*b_xfilename;$/;"	m	struct:buffer
back_gc	src/gui.h	/^	GC			back_gc;$/;"	m	struct:Gui
back_in_line	src/search.c	/^back_in_line()$/;"	f	file:
back_pixel	src/gui.h	/^	Pixel		back_pixel;			\/* Pixel value of background *\/$/;"	m	struct:Gui
backslash_halve	src/cmdline.c	/^backslash_halve(p, expand_wildcards)$/;"	f	file:
backward	tools/ctags/ctags.c	/^	boolean	backward;		\/* -B  regexp patterns search backwards *\/$/;"	m	struct:__anon17	file:
bangredo	src/globals.h	/^EXTERN int		bangredo INIT(= FALSE);		\/* set to TRUE whith ! command *\/$/;"	v
bck_word	src/search.c	/^bck_word(count, type, stop)$/;"	f
bckend_word	src/search.c	/^bckend_word(count, type, eol)$/;"	f
beep_count	src/globals.h	/^EXTERN int		beep_count INIT(= 0);	\/* nr of beeps since last char typed *\/$/;"	v
beep_flush	src/misccmds.c	/^beep_flush()$/;"	f
beginline	src/edit.c	/^beginline(flag)$/;"	f
bh_bnum	src/structs.h	/^	blocknr_t	bh_bnum;				\/* block number *\/$/;"	m	struct:block_hdr
bh_curr	src/getchar.c	/^		struct bufblock *bh_curr;		\/* bufblock for appending *\/$/;"	m	struct:buffheader	typeref:struct:buffheader::bufblock	file:
bh_data	src/structs.h	/^	char_u		*bh_data;			\/* pointer to memory (for used block) *\/$/;"	m	struct:block_hdr
bh_first	src/getchar.c	/^		struct bufblock bh_first;		\/* first (dummy) block of list *\/$/;"	m	struct:buffheader	typeref:struct:buffheader::bufblock	file:
bh_flags	src/structs.h	/^	char		bh_flags;			\/* BH_DIRTY or BH_LOCKED *\/$/;"	m	struct:block_hdr
bh_hash_next	src/structs.h	/^	BHDR		*bh_hash_next;		\/* next block_hdr in hash list *\/$/;"	m	struct:block_hdr
bh_hash_prev	src/structs.h	/^	BHDR		*bh_hash_prev;		\/* previous block_hdr in hash list *\/$/;"	m	struct:block_hdr
bh_index	src/getchar.c	/^		int 			bh_index;		\/* index for reading *\/$/;"	m	struct:buffheader	file:
bh_next	src/structs.h	/^	BHDR		*bh_next;			\/* next block_hdr in free or used list *\/$/;"	m	struct:block_hdr
bh_page_count	src/structs.h	/^	int			bh_page_count;		\/* number of pages in this block *\/$/;"	m	struct:block_hdr
bh_prev	src/structs.h	/^	BHDR		*bh_prev;			\/* previous block_hdr in used list *\/$/;"	m	struct:block_hdr
bh_space	src/getchar.c	/^		int 			bh_space;		\/* space in bh_curr for appending *\/$/;"	m	struct:buffheader	file:
block0	src/memline.c	/^struct block0$/;"	s	file:
blockTags	tools/ctags/ctags.c	/^		boolean	blockTags;	\/* -ig  include tags for enum, struct and union *\/$/;"	m	struct:__anon17::__anon18	file:
block_def	src/ops.c	/^struct block_def$/;"	s	file:
block_hdr	src/structs.h	/^struct block_hdr$/;"	s
block_prep	src/ops.c	/^block_prep(bd, lnum, is_del)$/;"	f	file:
block_redo	src/getchar.c	/^static int		block_redo = FALSE;$/;"	v	file:
blocknr_t	src/structs.h	/^typedef long				blocknr_t;$/;"	t
bold_font	src/gui.h	/^	XFontStruct	*bold_font;$/;"	m	struct:Gui
bold_pixel	src/gui.h	/^	Pixel		bold_pixel;			\/* Pixel value of bold text *\/$/;"	m	struct:Gui
boldital_font	src/gui.h	/^	XFontStruct	*boldital_font;$/;"	m	struct:Gui
boolean	tools/ctags/ctags.c	/^typedef enum { FALSE, TRUE } boolean;$/;"	t	typeref:enum:__anon7	file:
border_offset	src/gui.h	/^	int			border_offset;		\/* Total pixel offset for all borders *\/$/;"	m	struct:Gui
border_width	src/gui.h	/^	int			border_width;		\/* Width of our border around text area *\/$/;"	m	struct:Gui
bot_shadow_GC	src/gui_at_sb.h	/^    GC		bot_shadow_GC;$/;"	m	struct:__anon2
bot_shadow_contrast	src/gui_at_sb.h	/^    int		bot_shadow_contrast;$/;"	m	struct:__anon2
bot_shadow_pixel	src/gui_at_sb.h	/^    Pixel	bot_shadow_pixel;$/;"	m	struct:__anon2
bot_top_msg	src/search.c	/^static char_u *bot_top_msg = (char_u *)"search hit BOTTOM, continuing at TOP";$/;"	v	file:
bottommsg	src/tag.c	/^static char_u *bottommsg = (char_u *)"at bottom of tag stack";$/;"	v	file:
bpos	src/term.c	/^static int				bpos = 0;		\/* number of chars in outbuf *\/$/;"	v	file:
braceFormat	tools/ctags/ctags.c	/^	boolean	braceFormat;	\/* use brace formatting to detect end of block *\/$/;"	m	struct:__anon17	file:
breakLine	tools/ctags/ctags.c	/^	long breakLine;			\/* -#  source line at which to call lineBreak() *\/$/;"	m	struct:__anon17	file:
breakat_flags	src/globals.h	/^EXTERN char		breakat_flags[256];		\/* which characters are in 'breakat' *\/$/;"	v
bt_entry	src/term.c	/^	int			bt_entry;$/;"	m	struct:builtin_term	file:
bt_string	src/term.c	/^	char		*bt_string;$/;"	m	struct:builtin_term	file:
buf_check_timestamp	src/fileio.c	/^buf_check_timestamp(buf)$/;"	f
buf_clear	src/buffer.c	/^buf_clear(buf)$/;"	f
buf_copy_options	src/option.c	/^buf_copy_options(bp_from, bp_to, entering)$/;"	f
buf_freeall	src/buffer.c	/^buf_freeall(buf)$/;"	f
buf_modname	src/fileio.c	/^buf_modname(buf, fname, ext)$/;"	f
buf_write	src/fileio.c	/^buf_write(buf, fname, sfname, start, end, append, forceit,$/;"	f
buf_write_all	src/cmdline.c	/^buf_write_all(buf)$/;"	f	file:
bufblock	src/getchar.c	/^struct bufblock$/;"	s	file:
bufempty	src/macros.h	37;"	d
buffer	src/addcr.c	/^char buffer[1024];$/;"	v
buffer	src/structs.h	/^struct buffer$/;"	s
buffheader	src/getchar.c	/^struct buffheader$/;"	s	file:
buflist_add	src/buffer.c	/^buflist_add(fname)$/;"	f
buflist_altlnum	src/buffer.c	/^buflist_altlnum()$/;"	f
buflist_findlnum	src/buffer.c	/^buflist_findlnum(buf)$/;"	f	file:
buflist_findname	src/buffer.c	/^buflist_findname(fname)$/;"	f
buflist_findnr	src/buffer.c	/^buflist_findnr(nr)$/;"	f
buflist_findpat	src/buffer.c	/^buflist_findpat(pattern, pattern_end)$/;"	f
buflist_getfile	src/buffer.c	/^buflist_getfile(n, lnum, options)$/;"	f
buflist_getlnum	src/buffer.c	/^buflist_getlnum()$/;"	f
buflist_list	src/buffer.c	/^buflist_list()$/;"	f
buflist_match	src/buffer.c	/^buflist_match(prog, buf)$/;"	f	file:
buflist_name_nr	src/buffer.c	/^buflist_name_nr(fnum, fname, lnum)$/;"	f
buflist_new	src/buffer.c	/^buflist_new(fname, sfname, lnum, use_curbuf)$/;"	f
buflist_nr2name	src/buffer.c	/^buflist_nr2name(n, fullname, helptail)$/;"	f
buflist_setlnum	src/buffer.c	/^buflist_setlnum(buf, lnum)$/;"	f	file:
builtin_term	src/term.c	/^struct builtin_term$/;"	s	file:
builtin_termcaps	src/term.c	/^struct builtin_term builtin_termcaps[] =$/;"	v	typeref:struct:builtin_term
button	src/tables.c	/^	int		button;				\/* Which mouse button is it? *\/$/;"	m	struct:__anon5	file:
call_shell	src/archie.c	/^call_shell(cmd, options)$/;"	f
call_shell	src/msdos.c	/^call_shell(cmd, options)$/;"	f
call_shell	src/unix.c	/^call_shell(cmd, options)$/;"	f
can_cindent	src/edit.c	/^static int		can_cindent;	\/* may do cindenting on this line *\/$/;"	v	file:
can_si	src/globals.h	/^EXTERN int		can_si INIT(= FALSE);$/;"	v
can_si_back	src/globals.h	/^EXTERN int		can_si_back INIT(= FALSE);$/;"	v
canopt	src/screen.c	/^static int		canopt;			\/* TRUE when cursor goto can be optimized *\/$/;"	v	file:
catch_cbrk	src/msdos.c	/^catch_cbrk()$/;"	f
catch_cint	src/msdos.c	/^catch_cint(bp, di, si, ds, es, dx, cx, bx, ax)$/;"	f
catch_signals	src/unix.c	/^catch_signals(func)$/;"	f	file:
cb	src/gui.h	/^	void		(*cb)();			\/* Call-back routine *\/$/;"	m	struct:GuiMenu
cbrk_handler	src/msdos.c	/^cbrk_handler()$/;"	f	file:
cbrk_pressed	src/msdos.c	/^static int cbrk_pressed = FALSE;	\/* set by ctrl-break interrupt *\/$/;"	v	file:
ccheck_abbr	src/cmdline.c	/^ccheck_abbr(c)$/;"	f	file:
change_drive	src/msdos.c	/^change_drive(drive)$/;"	f	file:
change_indent	src/edit.c	/^change_indent(type, amount, round)$/;"	f	file:
change_warning	src/misccmds.c	/^change_warning()$/;"	f
char_ascent	src/gui.h	/^	int			char_ascent;		\/* Ascent of char in pixels *\/$/;"	m	struct:Gui
char_avail	src/getchar.c	/^char_avail()$/;"	f
char_height	src/gui.h	/^	int			char_height;		\/* Height of char in pixels *\/$/;"	m	struct:Gui
char_to_long	src/memline.c	/^char_to_long(s)$/;"	f	file:
char_u	src/term.h	/^typedef unsigned char char_u;$/;"	t
char_u	src/vim.h	/^typedef unsigned char	char_u;$/;"	t
char_width	src/gui.h	/^	int			char_width;			\/* Width of char in pixels *\/$/;"	m	struct:Gui
charsize	src/charset.c	/^charsize(c)$/;"	f
chartab	src/charset.c	/^static char_u chartab[256];$/;"	v	file:
chartab_initialized	src/charset.c	/^static int	  chartab_initialized = FALSE;$/;"	v	file:
chartabsize	src/charset.c	/^chartabsize(c, col)$/;"	f
chdir	src/vim.h	88;"	d
check_abbr	src/getchar.c	/^check_abbr(c, ptr, col, mincol)$/;"	f
check_arg_idx	src/cmdline.c	/^check_arg_idx()$/;"	f
check_buf_options	src/option.c	/^check_buf_options(buf)$/;"	f
check_changed	src/cmdline.c	/^check_changed(buf, checkaw, mult_win)$/;"	f	file:
check_changed_any	src/cmdline.c	/^check_changed_any()$/;"	f	file:
check_cursor	src/screen.c	/^check_cursor()$/;"	f
check_fname	src/cmdline.c	/^check_fname()$/;"	f
check_map_keycodes	src/getchar.c	/^check_map_keycodes()$/;"	f
check_mark	src/mark.c	/^check_mark(pos)$/;"	f
check_marks_read	src/fileio.c	/^check_marks_read()$/;"	f	file:
check_more	src/cmdline.c	/^check_more(message)$/;"	f	file:
check_options	src/option.c	/^check_options()$/;"	f
check_readonly	src/cmdline.c	/^check_readonly()$/;"	f	file:
check_shifted_spec_key	src/tables.c	/^check_shifted_spec_key(c)$/;"	f
check_status	src/misccmds.c	/^check_status(buf)$/;"	f	file:
check_termcode	src/term.c	/^check_termcode(max_offset)$/;"	f
check_timestamps	src/fileio.c	/^check_timestamps()$/;"	f
check_winsize	src/term.c	/^check_winsize()$/;"	f
checkclearop	src/normal.c	/^checkclearop()$/;"	f	file:
checkclearopq	src/normal.c	/^checkclearopq()$/;"	f	file:
checkpcmark	src/mark.c	/^checkpcmark()$/;"	f
children	src/gui.h	/^	struct GuiMenu *children;		\/* Children of sub-menu *\/$/;"	m	struct:GuiMenu	typeref:struct:GuiMenu::GuiMenu
chk_modeline	src/buffer.c	/^chk_modeline(lnum)$/;"	f	file:
chktemp	tools/mvi/mvi.c	/^chktemp( tmp, head, argv )$/;"	f	file:
cleanup_jumplist	src/mark.c	/^cleanup_jumplist()$/;"	f	file:
clearTagList	tools/ctags/ctags.c	/^static void clearTagList()$/;"	f	file:
clear_cmdline	src/globals.h	/^EXTERN int		clear_cmdline INIT(= FALSE);	\/* cmdline must be cleared *\/$/;"	v
clear_showcmd	src/normal.c	/^clear_showcmd()$/;"	f
clear_termcodes	src/term.c	/^clear_termcodes()$/;"	f
clear_termoptions	src/option.c	/^clear_termoptions()$/;"	f
clearop	src/normal.c	/^clearop()$/;"	f	file:
clearopbeep	src/normal.c	/^clearopbeep()$/;"	f	file:
close_buffer	src/buffer.c	/^close_buffer(win, buf, free_buf, del_buf)$/;"	f
close_others	src/window.c	/^close_others(message)$/;"	f
close_window	src/window.c	/^close_window(win, free_buf)$/;"	f
close_windows	src/window.c	/^close_windows(buf)$/;"	f
clrallmarks	src/mark.c	/^clrallmarks(buf)$/;"	f
cls	src/search.c	/^cls()$/;"	f	file:
cmd	src/option.c	/^	char_u			*cmd;					\/* The command to be executed *\/$/;"	m	struct:AutoCmd	file:
cmd_argt	src/cmdtab.h	/^	long_u	 cmd_argt;	\/* command line arguments permitted\/needed\/used *\/$/;"	m	struct:__anon1
cmd_hkmap	src/cmdline.c	/^static int			cmd_hkmap = 0;		\/* Hebrew mapping during command line *\/$/;"	v	file:
cmd_name	src/cmdtab.h	/^	char_u	*cmd_name;	\/* name of the command *\/$/;"	m	struct:__anon1
cmd_numfiles	src/cmdline.c	/^static int  		cmd_numfiles = -1;	  \/* number of files found by$/;"	v	file:
cmdbuff	src/cmdline.c	/^static char_u	*cmdbuff;		\/* pointer to command line buffer *\/$/;"	v	file:
cmdbufflen	src/cmdline.c	/^static int		 cmdbufflen;	\/* length of cmdbuff *\/$/;"	v	file:
cmdfirstc	src/cmdline.c	/^static int		 cmdfirstc; 	\/* ':', '\/' or '?' *\/$/;"	v	file:
cmdlen	src/cmdline.c	/^static int		 cmdlen;		\/* number of chars on command line *\/$/;"	v	file:
cmdline_paste	src/ops.c	/^cmdline_paste(c)$/;"	f
cmdline_row	src/globals.h	/^EXTERN int		cmdline_row;$/;"	v
cmdline_sb	src/gui.h	/^	GuiScrollbar cmdline_sb;		\/* Scroll bar for command line *\/$/;"	m	struct:Gui
cmdnames	src/cmdtab.h	/^} cmdnames[] =$/;"	v	typeref:struct:__anon1
cmdpos	src/cmdline.c	/^static int		 cmdpos;		\/* current cursor position *\/$/;"	v	file:
cmds	src/option.c	/^	AutoCmd			*cmds;					\/* list of commands to do *\/$/;"	m	struct:AutoPat	file:
cmdspos	src/cmdline.c	/^static int		 cmdspos;		\/* cursor column on screen *\/$/;"	v	file:
cnt	tools/mvi/mvi.c	/^static int cnt= 0, dcnt= 0, lcnt= 0;$/;"	v	file:
code	src/term.c	/^	char_u	*code;			\/* terminal code (in allocated memory) *\/$/;"	m	struct:termcode	file:
col	src/gui.h	/^	int			col;				\/* Current cursor column in GUI display *\/$/;"	m	struct:Gui
col	src/structs.h	/^	colnr_t 		col;			\/* column number *\/$/;"	m	struct:fpos
col_print	src/buffer.c	/^col_print(buf, col, vcol)$/;"	f
coladvance	src/linefunc.c	/^coladvance(wcol)$/;"	f
colnr_t	src/structs.h	/^typedef unsigned		colnr_t;$/;"	t
colnr_t	src/vim.h	/^typedef unsigned	colnr_t;		\/* column number type *\/$/;"	t
command_height	src/window.c	/^command_height()$/;"	f
commentorempty	src/misccmds.c	/^commentorempty(s)$/;"	f	file:
comp_Botline	src/screen.c	/^comp_Botline(wp)$/;"	f
comp_Botline_all	src/screen.c	/^comp_Botline_all()$/;"	f
comp_Botline_sub	src/screen.c	/^comp_Botline_sub(wp, lnum, done)$/;"	f	file:
comp_col	src/option.c	/^comp_col()$/;"	f
compareTags	tools/ctags/ctags.c	/^static int compareTags( one, two )$/;"	f	file:
complete_dictionaries	src/edit.c	/^complete_dictionaries(pat, dir)$/;"	f	file:
compute_cmdrow	src/cmdline.c	/^compute_cmdrow()$/;"	f
concat_fnames	src/misccmds.c	/^concat_fnames(fname1, fname2, sep)$/;"	f
const	src/conf_os2.h	65;"	d
const	tools/ctags/ctags.c	75;"	d	file:
copy_option_part	src/alloc.c	/^copy_option_part(option, buf, maxlen, sep_chars)$/;"	f
copy_redo	src/getchar.c	/^copy_redo(old_redo)$/;"	f	file:
copy_spaces	src/alloc.c	/^copy_spaces(ptr, count)$/;"	f
copy_viminfo_marks	src/mark.c	/^copy_viminfo_marks(line, fp_in, fp_out, count, eof)$/;"	f
core	src/gui_at_sb.h	/^    CorePart		core;$/;"	m	struct:_ScrollbarRec
core_class	src/gui_at_sb.h	/^    CoreClassPart		core_class;$/;"	m	struct:_ScrollbarClassRec
core_dump	src/unix.c	/^static int		core_dump = FALSE;			\/* core dump in mch_windexit() *\/$/;"	v	file:
count_completions	src/edit.c	/^count_completions()$/;"	f	file:
cppClose	tools/ctags/ctags.c	/^static void cppClose()$/;"	f	file:
cppGetc	tools/ctags/ctags.c	/^static int cppGetc()$/;"	f	file:
cppIgnore	tools/ctags/ctags.c	152;"	d	file:
cppOpen	tools/ctags/ctags.c	/^static boolean cppOpen( name )$/;"	f	file:
cppReadDirective	tools/ctags/ctags.c	/^static boolean cppReadDirective( c, name )$/;"	f	file:
cppReadIdentifier	tools/ctags/ctags.c	/^static boolean cppReadIdentifier( c, tag )$/;"	f	file:
cppUngetc	tools/ctags/ctags.c	/^static void cppUngetc( c )$/;"	f	file:
createTags	tools/ctags/ctags.c	/^static boolean createTags( name )$/;"	f	file:
createTagsForArgs	tools/ctags/ctags.c	/^static void createTagsForArgs( argList )$/;"	f	file:
createTagsForList	tools/ctags/ctags.c	/^static void createTagsForList( listFile )$/;"	f	file:
cstrchr	src/regexp.c	/^cstrchr(s, c)$/;"	f	file:
cstrncmp	src/regexp.c	/^cstrncmp(s1, s2, n)$/;"	f
ctrl_x_mode	src/globals.h	/^EXTERN int		ctrl_x_mode INIT(= 0);	\/* Which Ctrl-X mode are we in? *\/$/;"	v
ctrlc_pressed	src/msdos.c	/^static int ctrlc_pressed = FALSE;	\/* set when ctrl-C or ctrl-break detected *\/$/;"	v	file:
curbuf	src/globals.h	/^EXTERN BUF		*curbuf INIT(= NULL);	\/* currently active buffer *\/$/;"	v
curchr	src/regexp.c	/^static int 		curchr;$/;"	v	file:
curr_match	src/edit.c	/^struct Completion *curr_match = NULL;$/;"	v	typeref:struct:Completion
curr_tmode	src/unix.c	/^static int curr_tmode = 0;	\/* contains current raw\/cooked mode (0 = cooked) *\/$/;"	v	file:
current_block	src/search.c	/^current_block(what, count)$/;"	f
current_menu	src/globals.h	/^EXTERN GuiMenu	*current_menu;$/;"	v
current_par	src/search.c	/^current_par(type, count)$/;"	f
current_scrollbar	src/globals.h	/^EXTERN int		current_scrollbar;$/;"	v
current_sent	src/search.c	/^current_sent(count)$/;"	f
current_word	src/search.c	/^current_word(count, type)$/;"	f
curs_columns	src/screen.c	/^curs_columns(scroll)$/;"	f
curs_rows	src/screen.c	/^curs_rows()$/;"	f
curscript	src/globals.h	/^EXTERN int		curscript INIT(= 0);		\/* index in scriptin[] *\/$/;"	v
cursor_col	src/gui.h	/^	int			cursor_col;			\/* Physical cursor column in GUI display *\/$/;"	m	struct:Gui
cursor_correct	src/screen.c	/^cursor_correct()$/;"	f
cursor_down	src/edit.c	/^cursor_down(n)$/;"	f
cursor_is_off	src/term.c	/^static int cursor_is_off = FALSE;$/;"	v	file:
cursor_off	src/term.c	/^cursor_off()$/;"	f
cursor_on	src/term.c	/^cursor_on()$/;"	f
cursor_pixel	src/gui.h	/^	Pixel		cursor_pixel;		\/* Pixel value of cursor *\/$/;"	m	struct:Gui
cursor_pos_info	src/buffer.c	/^cursor_pos_info()$/;"	f
cursor_row	src/gui.h	/^	int			cursor_row;			\/* Physical cursor row in GUI display *\/$/;"	m	struct:Gui
cursor_up	src/edit.c	/^cursor_up(n)$/;"	f
cursorcmd	src/cmdline.c	/^cursorcmd()$/;"	f	file:
cursupdate	src/screen.c	/^cursupdate()$/;"	f
curwin	src/globals.h	/^EXTERN WIN		*curwin;		\/* currently active window *\/$/;"	v
data_block	src/memline.c	/^struct data_block$/;"	s	file:
db_free	src/memline.c	/^	unsigned	db_free;		\/* free space available *\/$/;"	m	struct:data_block	file:
db_id	src/memline.c	/^	short_u		db_id;			\/* ID for data block: DATA_ID *\/$/;"	m	struct:data_block	file:
db_index	src/memline.c	/^	unsigned	db_index[1];	\/* index for start of line (actually bigger)$/;"	m	struct:data_block	file:
db_line_count	src/memline.c	/^	linenr_t	db_line_count;	\/* number of lines in this block *\/$/;"	m	struct:data_block	file:
db_txt_end	src/memline.c	/^	unsigned	db_txt_end;		\/* byte just after data block *\/$/;"	m	struct:data_block	file:
db_txt_start	src/memline.c	/^	unsigned	db_txt_start;	\/* byte where text starts *\/$/;"	m	struct:data_block	file:
dcnt	tools/mvi/mvi.c	/^static int cnt= 0, dcnt= 0, lcnt= 0;$/;"	v	file:
death	tools/mvi/mvi.c	/^static jmp_buf death;      \/* Place to jump to to have tmp deleted *\/$/;"	v	file:
debug	src/pty.c	45;"	d	file:
debug1	src/pty.c	46;"	d	file:
debugLabel	tools/ctags/ctags.c	/^static void debugLabel( tagType, tagName )$/;"	f	file:
debugLevel	tools/ctags/ctags.c	/^	int debugLevel;			\/* -D  debugging output *\/$/;"	m	struct:__anon17	file:
debugOpen	tools/ctags/ctags.c	/^static void debugOpen( name )$/;"	f	file:
debugPutc	tools/ctags/ctags.c	/^static void debugPutc( c, level )$/;"	f	file:
debugfp	src/globals.h	/^EXTERN FILE *debugfp INIT(=NULL);$/;"	v
dec	src/linefunc.c	/^dec(lp)$/;"	f
dec_cursor	src/linefunc.c	/^dec_cursor()$/;"	f
decl	src/linefunc.c	/^decl(lp)$/;"	f
decl_t	tools/ctags/ctags.c	/^} decl_t;$/;"	t	typeref:enum:__anon12	file:
declaration	tools/ctags/ctags.c	/^	decl_t	declaration;$/;"	m	struct:__anon15	file:
def_val	src/option.c	/^	char_u		*def_val;		\/* default value for variable (can be the same$/;"	m	struct:option	file:
define	tools/ctags/ctags.c	/^	char	define[MAXNAME];		\/* the name of the last define *\/$/;"	m	struct:__anon16	file:
defines	tools/ctags/ctags.c	/^		boolean	defines;	\/* -id  include tags for defines *\/$/;"	m	struct:__anon17::__anon18	file:
del_autocmd	src/option.c	/^del_autocmd(ap)$/;"	f	file:
del_autocmd_cmds	src/option.c	/^del_autocmd_cmds(ap)$/;"	f	file:
del_from_showcmd	src/normal.c	/^del_from_showcmd(len)$/;"	f	file:
del_termcode	src/term.c	/^del_termcode(name)$/;"	f
del_trailing_spaces	src/alloc.c	/^del_trailing_spaces(ptr)$/;"	f
del_typebuf	src/getchar.c	/^del_typebuf(len, offset)$/;"	f
delayed_redraw	src/msdos.c	/^static int delayed_redraw = FALSE;	\/* set when ctrl-C detected *\/$/;"	v	file:
delchar	src/misccmds.c	/^delchar(fixpos)$/;"	f
dellines	src/misccmds.c	/^dellines(nlines, dowindow, undo)$/;"	f
delmode	src/screen.c	/^delmode()$/;"	f
dflt_bold_fn	src/gui.h	/^	char_u		*dflt_bold_fn;		\/* Resource bold font *\/$/;"	m	struct:Gui
dflt_boldital_fn	src/gui.h	/^	char_u		*dflt_boldital_fn;	\/* Resource bold-italic font *\/$/;"	m	struct:Gui
dflt_font	src/gui.h	/^	char_u		*dflt_font;			\/* Resource font, used if 'font' not set *\/$/;"	m	struct:Gui
dflt_ital_fn	src/gui.h	/^	char_u		*dflt_ital_fn;		\/* Resource italic font *\/$/;"	m	struct:Gui
did_ai	src/globals.h	/^EXTERN int	   did_ai INIT(= FALSE);$/;"	v
did_cd	src/globals.h	/^EXTERN int		did_cd INIT(= FALSE);	\/* TRUE when :cd dir used *\/$/;"	v
did_emsg	src/globals.h	/^EXTERN int		did_emsg;					\/* set by emsg() for DoOneCmd() *\/$/;"	v
did_outofmem_msg	src/globals.h	/^EXTERN int		did_outofmem_msg INIT(= FALSE);$/;"	v
did_si	src/globals.h	/^EXTERN int		did_si INIT(= FALSE);$/;"	v
did_swapwrite_msg	src/globals.h	/^EXTERN int		did_swapwrite_msg INIT(= FALSE);$/;"	v
die	tools/mvi/mvi.c	/^die( text )$/;"	f	file:
digraphcount	src/digraph.c	/^static int		digraphcount = 0;			\/* number of added digraphs *\/$/;"	v	file:
digraphdefault	src/digraph.c	/^char_u	digraphdefault[][3] = 		\/* default HPUX digraphs *\/$/;"	v
digraphdefault	src/digraph.c	/^char_u	digraphdefault[][3] = 		\/* standard ISO digraphs *\/$/;"	v
digraphdefault	src/digraph.c	/^char_u	digraphdefault[][3] = 		\/* standard MSDOS digraphs *\/$/;"	v
digraphnew	src/digraph.c	/^static char_u	(*digraphnew)[3];			\/* pointer to added digraphs *\/$/;"	v	file:
directive	tools/ctags/ctags.c	/^	} directive;$/;"	m	struct:__anon22	typeref:struct:__anon22::__anon23	file:
dirent	src/unix.h	94;"	d
dirname	src/archie.c	/^dirname(buf, len)$/;"	f
dis_msg	src/ops.c	/^dis_msg(p, skip_esc)$/;"	f
display_dollar	src/screen.c	/^display_dollar(col)$/;"	f
display_showcmd	src/normal.c	/^display_showcmd()$/;"	f	file:
djgpp_rename	src/msdos.c	/^djgpp_rename(const char *OldFile, const char *NewFile)$/;"	f
dnet_ntoa	src/configure	/^dnet_ntoa()$/;"	f
do_Lower	src/regsub.c	/^do_Lower(d, c)$/;"	f	file:
do_Upper	src/regsub.c	/^do_Upper(d, c)$/;"	f	file:
do_addsub	src/ops.c	/^do_addsub(command, Prenum1)$/;"	f
do_align	src/cmdcmds.c	/^do_align(start, end, width, type)$/;"	f
do_arg_all	src/buffer.c	/^do_arg_all(count)$/;"	f
do_arglist	src/cmdline.c	/^do_arglist(str)$/;"	f	file:
do_ascii	src/cmdcmds.c	/^do_ascii()$/;"	f
do_autocmd	src/option.c	/^do_autocmd(arg, force)$/;"	f
do_autocmd_event	src/option.c	/^do_autocmd_event(event, pat, cmd, force)$/;"	f	file:
do_bang	src/cmdcmds.c	/^do_bang(addr_count, line1, line2, forceit, arg, do_in, do_out)$/;"	f
do_bufdel	src/buffer.c	/^do_bufdel(command, arg, addr_count, start_bnr, end_bnr, forceit)$/;"	f
do_buffer	src/buffer.c	/^do_buffer(action, start, dir, count, forceit)$/;"	f
do_buffer_all	src/buffer.c	/^do_buffer_all(count, all)$/;"	f
do_change	src/ops.c	/^do_change()$/;"	f
do_cmdline	src/cmdline.c	/^do_cmdline(cmdline, sourcing, repeating)$/;"	f
do_copy	src/cmdcmds.c	/^do_copy(line1, line2, n)$/;"	f
do_delete	src/ops.c	/^do_delete()$/;"	f
do_digraph	src/digraph.c	/^do_digraph(c)$/;"	f
do_dis	src/ops.c	/^do_dis(arg)$/;"	f
do_do_join	src/ops.c	/^do_do_join(count, insert_space, redraw)$/;"	f
do_doautocmd	src/option.c	/^do_doautocmd(arg)$/;"	f
do_ecmd	src/cmdline.c	/^do_ecmd(fnum, fname, sfname, command, hide, newlnum, set_help)$/;"	f
do_execbuf	src/ops.c	/^do_execbuf(c, colon, addcr)$/;"	f
do_file	src/cmdcmds.c	/^do_file(arg, forceit)$/;"	f
do_filter	src/cmdcmds.c	/^do_filter(line1, line2, buff, do_in, do_out)$/;"	f
do_fixdel	src/cmdcmds.c	/^do_fixdel()$/;"	f
do_format	src/ops.c	/^do_format()$/;"	f
do_gd	src/normal.c	/^do_gd(nchar)$/;"	f	file:
do_glob	src/csearch.c	/^do_glob(type, lp, up, cmd)$/;"	f
do_help	src/help.c	/^do_help(arg)$/;"	f
do_join	src/ops.c	/^do_join(insert_space, redraw)$/;"	f
do_jumps	src/mark.c	/^do_jumps()$/;"	f
do_lower	src/regsub.c	/^do_lower(d, c)$/;"	f	file:
do_make	src/cmdline.c	/^do_make(arg)$/;"	f	file:
do_map	src/getchar.c	/^do_map(maptype, keys, mode)$/;"	f
do_marks	src/mark.c	/^do_marks(arg)$/;"	f
do_modelines	src/buffer.c	/^do_modelines()$/;"	f
do_mouse	src/normal.c	/^do_mouse(c, dir, count, fix_indent)$/;"	f
do_move	src/cmdcmds.c	/^do_move(line1, line2, n)$/;"	f
do_one_cmd	src/cmdline.c	/^do_one_cmd(cmdlinep, cmdlinelenp, sourcing)$/;"	f	file:
do_outofmem_msg	src/alloc.c	/^do_outofmem_msg()$/;"	f
do_pending_operator	src/normal.c	/^do_pending_operator(c, nchar, finish_op, searchbuff, command_busy,$/;"	f
do_put	src/ops.c	/^do_put(dir, count, fix_indent)$/;"	f
do_record	src/ops.c	/^do_record(c)$/;"	f
do_redraw	src/globals.h	/^EXTERN int		do_redraw INIT(= FALSE);	\/* extra redraw once *\/$/;"	v
do_reindent	src/ops.c	/^do_reindent(how)$/;"	f
do_resize	src/archie.c	/^static int do_resize = FALSE;$/;"	v	file:
do_resize	src/unix.c	/^static int		do_resize = FALSE;$/;"	v	file:
do_retab	src/cmdcmds.c	/^do_retab(start, end, new_ts, force)$/;"	f
do_search	src/search.c	/^do_search(dirc, str, count, options)$/;"	f
do_set	src/option.c	/^do_set(arg)$/;"	f
do_shell	src/cmdcmds.c	/^do_shell(cmd)$/;"	f
do_shift	src/ops.c	/^do_shift(op, curs_top, amount)$/;"	f
do_source	src/cmdline.c	/^do_source(fname, check_other)$/;"	f
do_sub	src/csearch.c	/^do_sub(lp, up, cmd, nextcommand, use_old)$/;"	f
do_sub_msg	src/csearch.c	/^do_sub_msg()$/;"	f	file:
do_tag	src/tag.c	/^do_tag(tag, type, count)$/;"	f
do_tags	src/tag.c	/^do_tags()$/;"	f
do_tilde	src/ops.c	/^do_tilde()$/;"	f
do_upper	src/regsub.c	/^do_upper(d, c)$/;"	f	file:
do_version	src/version.c	/^do_version(arg)$/;"	f
do_viminfo	src/cmdcmds.c	/^do_viminfo(fp_in, fp_out, want_info, want_marks, force_read)$/;"	f	file:
do_window	src/window.c	/^do_window(nchar, Prenum)$/;"	f
do_write	src/cmdline.c	/^do_write(fname, append)$/;"	f	file:
do_yank	src/ops.c	/^do_yank(deleting, mess)$/;"	f
dofork	src/gui.h	/^	int			dofork;				\/* Use fork() when GUI is starting *\/$/;"	m	struct:Gui
dollar_vcol	src/globals.h	/^EXTERN colnr_t	dollar_vcol INIT(= 0);$/;"	v
domv	tools/mvi/mvi.c	/^domv( tmp, head, argv )$/;"	f	file:
dont_sleep	src/globals.h	/^EXTERN int		dont_sleep INIT(= FALSE);	\/* set when sleep() in emsg() not$/;"	v
dont_wait_return	src/globals.h	/^EXTERN int		dont_wait_return INIT(= 0);	\/* no need to wait for return *\/$/;"	v
dpy	src/gui.h	/^	Display		*dpy;				\/* X display *\/$/;"	m	struct:Gui
dragged_sb	src/gui.h	/^	int			dragged_sb;			\/* Which scrollbar being dragged, if any? *\/$/;"	m	struct:Gui
dragged_wp	src/gui.h	/^	struct window	*dragged_wp;	\/* Which WIN's sb being dragged, if any? *\/$/;"	m	struct:Gui	typeref:struct:Gui::window
drctv_state	tools/ctags/ctags.c	/^} drctv_state;$/;"	t	typeref:enum:__anon14	file:
dump	src/unix.c	/^	int		dump;		\/* Should this signal cause a core dump? *\/$/;"	m	struct:__anon6	file:
dying	src/gui.h	/^	int			dying;				\/* Is vim dying? Then output to terminal *\/$/;"	m	struct:Gui
e_abbr	src/globals.h	/^EXTERN char_u e_abbr[]		INIT(="No such abbreviation");$/;"	v
e_abort	src/globals.h	/^EXTERN char_u e_abort[]		INIT(="Command aborted");$/;"	v
e_ambmap	src/globals.h	/^EXTERN char_u e_ambmap[]	INIT(="Ambiguous mapping");$/;"	v
e_argreq	src/globals.h	/^EXTERN char_u e_argreq[]	INIT(="Argument required");$/;"	v
e_backslash	src/globals.h	/^EXTERN char_u e_backslash[]	INIT(="\\\\ should be followed by \/, ? or &");$/;"	v
e_curdir	src/globals.h	/^EXTERN char_u e_curdir[]	INIT(="Command not allowed from from .exrc\/.vimrc in current dir");$/;"	v
e_errorf	src/globals.h	/^EXTERN char_u e_errorf[]	INIT(="No errorfile name");$/;"	v
e_exists	src/globals.h	/^EXTERN char_u e_exists[]	INIT(="File exists (use ! to override)");$/;"	v
e_failed	src/globals.h	/^EXTERN char_u e_failed[] 	INIT(="Command failed");$/;"	v
e_internal	src/globals.h	/^EXTERN char_u e_internal[]	INIT(="Internal error");$/;"	v
e_interr	src/globals.h	/^EXTERN char_u e_interr[]	INIT(="Interrupted");$/;"	v
e_invaddr	src/globals.h	/^EXTERN char_u e_invaddr[]	INIT(="Invalid address");$/;"	v
e_invarg	src/globals.h	/^EXTERN char_u e_invarg[]	INIT(="Invalid argument");$/;"	v
e_invcmd	src/globals.h	/^EXTERN char_u e_invcmd[]	INIT(="Invalid command");$/;"	v
e_invrange	src/globals.h	/^EXTERN char_u e_invrange[]	INIT(="Invalid range");$/;"	v
e_markinval	src/globals.h	/^EXTERN char_u e_markinval[]	INIT(="Mark has invalid line number");$/;"	v
e_marknotset	src/globals.h	/^EXTERN char_u e_marknotset[]	INIT(="Mark not set");$/;"	v
e_nesting	src/globals.h	/^EXTERN char_u e_nesting[]	INIT(="Scripts nested too deep");$/;"	v
e_noalt	src/globals.h	/^EXTERN char_u e_noalt[]		INIT(="No alternate file");$/;"	v
e_nobang	src/globals.h	/^EXTERN char_u e_nobang[] 	INIT(="No ! allowed");$/;"	v
e_nogvim	src/globals.h	/^EXTERN char_u e_nogvim[]	INIT(="GUI cannot be used: Not enabled at compile time\\n");$/;"	v
e_nohebrew	src/globals.h	/^EXTERN char_u e_nohebrew[]	INIT(="Hebrew cannot be used: Not enabled at compile time\\n");$/;"	v
e_noinstext	src/globals.h	/^EXTERN char_u e_noinstext[]	INIT(="No inserted text yet");$/;"	v
e_nolastcmd	src/globals.h	/^EXTERN char_u e_nolastcmd[]	INIT(="No previous command line");$/;"	v
e_nomap	src/globals.h	/^EXTERN char_u e_nomap[]		INIT(="No such mapping");$/;"	v
e_nomatch	src/globals.h	/^EXTERN char_u e_nomatch[]	INIT(="No match");$/;"	v
e_nomore	src/globals.h	/^EXTERN char_u e_nomore[]	INIT(="No more files to edit");$/;"	v
e_noname	src/globals.h	/^EXTERN char_u e_noname[]	INIT(="No file name");$/;"	v
e_nopresub	src/globals.h	/^EXTERN char_u e_nopresub[]	INIT(="No previous substitute regular expression");$/;"	v
e_noprev	src/globals.h	/^EXTERN char_u e_noprev[]	INIT(="No previous command");$/;"	v
e_noprevre	src/globals.h	/^EXTERN char_u e_noprevre[]	INIT(="No previous regular expression");$/;"	v
e_norange	src/globals.h	/^EXTERN char_u e_norange[] 	INIT(="No range allowed");$/;"	v
e_noroom	src/globals.h	/^EXTERN char_u e_noroom[] 	INIT(="Not enough room");$/;"	v
e_notcreate	src/globals.h	/^EXTERN char_u e_notcreate[]	INIT(="Can't create file %s");$/;"	v
e_notmp	src/globals.h	/^EXTERN char_u e_notmp[]		INIT(="Can't get temp file name");$/;"	v
e_notopen	src/globals.h	/^EXTERN char_u e_notopen[]	INIT(="Can't open file %s");$/;"	v
e_notread	src/globals.h	/^EXTERN char_u e_notread[]	INIT(="Can't read file %s");$/;"	v
e_nowrtmsg	src/globals.h	/^EXTERN char_u e_nowrtmsg[]	INIT(="No write since last change (use ! to override)");$/;"	v
e_null	src/globals.h	/^EXTERN char_u e_null[]		INIT(="Null argument");$/;"	v
e_number	src/globals.h	/^EXTERN char_u e_number[]	INIT(="Number expected");$/;"	v
e_openerrf	src/globals.h	/^EXTERN char_u e_openerrf[]	INIT(="Can't open errorfile %s");$/;"	v
e_outofmem	src/globals.h	/^EXTERN char_u e_outofmem[]	INIT(="Out of memory!");$/;"	v
e_patnotf	src/globals.h	/^EXTERN char_u e_patnotf[]	INIT(="Pattern not found");$/;"	v
e_positive	src/globals.h	/^EXTERN char_u e_positive[]	INIT(="Argument must be positive");$/;"	v
e_quickfix	src/globals.h	/^EXTERN char_u e_quickfix[]	INIT(="No Errors");$/;"	v
e_re_corr	src/globals.h	/^EXTERN char_u e_re_corr[]	INIT(="Corrupted regexp program");$/;"	v
e_re_damg	src/globals.h	/^EXTERN char_u e_re_damg[]	INIT(="Damaged match string");$/;"	v
e_readerrf	src/globals.h	/^EXTERN char_u e_readerrf[]	INIT(="Error while reading errorfile");$/;"	v
e_readonly	src/globals.h	/^EXTERN char_u e_readonly[]	INIT(="'readonly' option is set (use ! to override)");$/;"	v
e_scroll	src/globals.h	/^EXTERN char_u e_scroll[]	INIT(="Invalid scroll size");$/;"	v
e_toocompl	src/globals.h	/^EXTERN char_u e_toocompl[]	INIT(="Command too complex");$/;"	v
e_toolong	src/globals.h	/^EXTERN char_u e_toolong[]	INIT(="Command too long");$/;"	v
e_toomany	src/globals.h	/^EXTERN char_u e_toomany[]	INIT(="Too many file names");$/;"	v
e_toombra	src/globals.h	/^EXTERN char_u e_toombra[]	INIT(="Too many (");$/;"	v
e_toomket	src/globals.h	/^EXTERN char_u e_toomket[]	INIT(="Too many )");$/;"	v
e_toomsbra	src/globals.h	/^EXTERN char_u e_toomsbra[]	INIT(="Too many [");$/;"	v
e_trailing	src/globals.h	/^EXTERN char_u e_trailing[]	INIT(="Trailing characters");$/;"	v
e_umark	src/globals.h	/^EXTERN char_u e_umark[]		INIT(="Unknown mark");$/;"	v
e_unknown	src/globals.h	/^EXTERN char_u e_unknown[]	INIT(="Unknown");$/;"	v
e_write	src/globals.h	/^EXTERN char_u e_write[]		INIT(="Error while writing");$/;"	v
e_zerocount	src/globals.h	/^EXTERN char_u e_zerocount[]	INIT(="Zero count");$/;"	v
echeck_abbr	src/edit.c	/^echeck_abbr(c)$/;"	f	file:
edit	src/edit.c	/^edit(initstr, startln, count)$/;"	f
edit_submode	src/globals.h	/^EXTERN char_u	*edit_submode INIT(= NULL);	\/* msg for CTRL-X submode *\/$/;"	v
edit_submode_extra	src/globals.h	/^EXTERN char_u	*edit_submode_extra INIT(= NULL);\/* extra info for msg *\/$/;"	v
edit_submode_highl	src/globals.h	/^EXTERN int		edit_submode_highl;			\/* extra info highlighted *\/$/;"	v
editemp	tools/mvi/mvi.c	/^editemp( tmp )$/;"	f	file:
eformat	src/quickfix.c	/^struct eformat$/;"	s	file:
empty	src/gui_at_sb.h	/^typedef struct {int empty;} ScrollbarClassPart;$/;"	m	struct:__anon3
empty_option	src/globals.h	/^EXTERN char_u	*empty_option INIT(= (char_u *)"");$/;"	v
emsg	src/message.c	/^emsg(s)$/;"	f
emsg2	src/message.c	/^emsg2(s, a1)$/;"	f
emsg_off	src/globals.h	/^EXTERN int		emsg_off INIT(= FALSE);		\/* don't display errors for now *\/$/;"	v
emsg_on_display	src/globals.h	/^EXTERN int		emsg_on_display INIT(= FALSE);	\/* there is an error message *\/$/;"	v
emsgn	src/message.c	/^emsgn(s, n)$/;"	f
end	src/gui.h	/^	FPOS		end;				\/* End of selected area *\/$/;"	m	struct:GuiSelection
end_visual_mode	src/normal.c	/^end_visual_mode()$/;"	f
end_word	src/search.c	/^end_word(count, type, stop, empty)$/;"	f
endp	src/regexp.h	/^	char_u		   *endp[NSUBEXP];$/;"	m	struct:regexp
endspaces	src/ops.c	/^	int			endspaces;$/;"	m	struct:block_def	file:
enter_buffer	src/buffer.c	/^enter_buffer(buf)$/;"	f	file:
enumValues	tools/ctags/ctags.c	/^		boolean	enumValues;	\/* -ie  include tags for enumeration value *\/$/;"	m	struct:__anon17::__anon18	file:
envsize	src/pty.c	/^static int	envsize = -1;	 \/* current size of environment *\/$/;"	v	file:
equal	src/macros.h	27;"	d
escape_chars	src/globals.h	/^EXTERN char_u	*escape_chars INIT(= (char_u *)" \\t\\\\\\"|");$/;"	v
event	src/option.c	/^	int		event;		\/* event number *\/$/;"	m	struct:event_name	file:
event_name	src/option.c	/^static struct event_name$/;"	s	file:
event_name2nr	src/option.c	/^event_name2nr(start, end)$/;"	f	file:
event_names	src/option.c	/^} event_names[] =$/;"	v	typeref:struct:event_name	file:
event_nr2name	src/option.c	/^event_nr2name(event)$/;"	f	file:
exit_with_usage	tools/xxd/xxd.c	/^exit_with_usage(pname)$/;"	f
exiting	src/globals.h	/^EXTERN int		exiting INIT(= FALSE);$/;"	v
expand_context	src/globals.h	/^EXTERN int		expand_context INIT(= CONTEXT_UNKNOWN);$/;"	v
expand_env	src/misccmds.c	/^expand_env(src, dst, dstlen)$/;"	f
expand_interactively	src/globals.h	/^EXTERN int		expand_interactively INIT(= FALSE);$/;"	v
expand_option_idx	src/option.c	/^static int expand_option_idx = -1;$/;"	v	file:
expand_option_name	src/option.c	/^static char_u expand_option_name[5] = {'t', '_', NUL, NUL, NUL};$/;"	v	file:
expand_pattern	src/globals.h	/^EXTERN char_u	*expand_pattern INIT(= NULL);$/;"	v
expand_rel_name	src/tag.c	/^expand_rel_name(fname, tag_fname)$/;"	f	file:
expandpath	src/msdos.c	/^expandpath(fl, path, fonly, donly, notf)$/;"	f	file:
extra_shell_arg	src/unix.c	/^static char_u	*extra_shell_arg = NULL;$/;"	v	file:
fatal	tools/ctags/ctags.c	/^static void fatal( msg )$/;"	f	file:
file	src/msdos.c	/^	char_u	**file;$/;"	m	struct:filelist	file:
file	tools/ctags/ctags.c	/^	struct { size_t line, tag, file; } max;$/;"	m	struct:__anon19::__anon20	file:
fileClose	tools/ctags/ctags.c	/^static void fileClose()$/;"	f	file:
fileCopyLine	tools/ctags/ctags.c	/^static int fileCopyLine( fp, seek )$/;"	f	file:
fileCopyLineShort	tools/ctags/ctags.c	/^static int fileCopyLineShort( fp, seek, limit )$/;"	f	file:
fileGetc	tools/ctags/ctags.c	/^static int fileGetc()$/;"	f	file:
fileList	tools/ctags/ctags.c	/^	const char *fileList;	\/* -L  name of file containing names of files *\/$/;"	m	struct:__anon17	file:
fileOpen	tools/ctags/ctags.c	/^static boolean fileOpen( name )$/;"	f	file:
fileUngetc	tools/ctags/ctags.c	/^static void fileUngetc( c )$/;"	f	file:
file_name_at_cursor	src/window.c	/^file_name_at_cursor(options)$/;"	f
file_pat_to_reg_pat	src/option.c	/^file_pat_to_reg_pat(pat, pat_end, allow_directories)$/;"	f
fileinfo	src/buffer.c	/^fileinfo(fullname, shorthelp, dont_truncate)$/;"	f
filelist	src/msdos.c	/^typedef struct filelist$/;"	s	file:
filemark	src/structs.h	/^struct filemark$/;"	s
filemess	src/fileio.c	/^filemess(buf, name, s)$/;"	f
fill_breakat_flags	src/option.c	/^fill_breakat_flags()$/;"	f	file:
fill_inbuf	src/archie.c	/^fill_inbuf()$/;"	f	file:
fill_inbuf	src/unix.c	/^fill_inbuf(exit_on_error)$/;"	f	file:
find_builtin_term	src/term.c	/^find_builtin_term(term)$/;"	f	file:
find_end_event	src/option.c	/^find_end_event(arg)$/;"	f	file:
find_end_of_word	src/normal.c	/^find_end_of_word(pos)$/;"	f	file:
find_first_blank	src/search.c	/^find_first_blank(posp)$/;"	f	file:
find_help_tags	src/help.c	/^find_help_tags(arg, num_matches, matches)$/;"	f
find_ident_under_cursor	src/normal.c	/^find_ident_under_cursor(string, find_type)$/;"	f
find_key_option	src/option.c	/^find_key_option(arg)$/;"	f	file:
find_last_paren	src/misccmds.c	/^find_last_paren(l)$/;"	f	file:
find_match	src/misccmds.c	/^find_match(lookfor, ourscope, ind_maxparen, ind_maxcomment)$/;"	f	file:
find_match_paren	src/misccmds.c	/^find_match_paren(ind_maxparen, ind_maxcomment)		\/* XXX *\/$/;"	f	file:
find_pattern_in_path	src/search.c	/^find_pattern_in_path(ptr, len, whole, skip_comments,$/;"	f
find_special_key_in_table	src/tables.c	/^find_special_key_in_table(c)$/;"	f
find_start_brace	src/misccmds.c	/^find_start_brace(ind_maxcomment)			\/* XXX *\/$/;"	f	file:
find_start_comment	src/misccmds.c	/^find_start_comment(ind_maxcomment)			\/* XXX *\/$/;"	f	file:
find_start_of_word	src/normal.c	/^find_start_of_word(pos)$/;"	f	file:
find_tags	src/tag.c	/^find_tags(tag, prog, num_file, file, help_only)$/;"	f
find_termcode	src/term.c	/^find_termcode(name)$/;"	f
findenv	src/pty.c	/^findenv(name)$/;"	f	file:
findmatch	src/search.c	/^findmatch(initc)$/;"	f
findmatchlimit	src/search.c	/^findmatchlimit(initc, flags, maxtravel)$/;"	f
findoption	src/option.c	/^findoption(arg)$/;"	f	file:
findpar	src/search.c	/^findpar(dir, count, what, both)$/;"	f
findsent	src/search.c	/^findsent(dir, count)$/;"	f
findswapname	src/memline.c	/^findswapname(buf, dirp, old_fname)$/;"	f	file:
finish_viminfo_history	src/cmdline.c	/^finish_viminfo_history()$/;"	f
first_autopat	src/option.c	/^static AutoPat *first_autopat[NUM_EVENTS] =$/;"	v	file:
first_match	src/edit.c	/^struct Completion *first_match = NULL;$/;"	v	typeref:struct:Completion
firstbuf	src/globals.h	/^EXTERN BUF		*firstbuf INIT(= NULL);	\/* first buffer *\/$/;"	v
firstwin	src/globals.h	/^EXTERN WIN		*firstwin;		\/* first window *\/$/;"	v
fix_fname	src/buffer.c	/^fix_fname(fname)$/;"	f
fixedtitle	src/unix.c	/^static char_u	*fixedtitle = (char_u *)"Thanks for flying Vim";$/;"	v	file:
fixthisline	src/edit.c	/^fixthisline(get_the_indent)$/;"	f
flags	src/option.c	/^	short 		flags;			\/* see below *\/$/;"	m	struct:option	file:
flags	tools/mvi/mvi.c	/^flags( argc, argv )$/;"	f	file:
flush_buffers	src/getchar.c	/^flush_buffers(typeahead)$/;"	f
flushbuf	src/term.c	/^flushbuf()$/;"	f
fm_getname	src/mark.c	/^fm_getname(fmark)$/;"	f
fmark	src/structs.h	/^	struct filemark fmark;				\/* cursor position *\/$/;"	m	struct:taggy	typeref:struct:taggy::filemark
fmarks_check_names	src/mark.c	/^fmarks_check_names(buf)$/;"	f
fmt_end_block	src/ops.c	/^fmt_end_block(lnum, leader_len, leader_flags)$/;"	f	file:
fmtstr	src/quickfix.c	/^	char_u			*fmtstr;		\/* pre-formatted part of 'errorformat' *\/$/;"	m	struct:eformat	file:
fname	src/edit.c	/^	char_u				*fname;$/;"	m	struct:Completion	file:
fname_case	src/archie.c	/^fname_case(name)$/;"	f
fname_case	src/msdos.c	/^fname_case(name)$/;"	f
fname_expand	src/buffer.c	/^fname_expand(fname, sfname)$/;"	f
fnamecmp	src/vim.h	503;"	d
fnamecmp	src/vim.h	506;"	d
fnamecmp_ino	src/memline.c	/^fnamecmp_ino(fname_c, fname_s, ino_block0)$/;"	f	file:
fnamencmp	src/vim.h	504;"	d
fnamencmp	src/vim.h	507;"	d
fnum	src/structs.h	/^	int				fnum;			\/* file number *\/$/;"	m	struct:filemark
fo_do_comments	src/globals.h	/^EXTERN int		fo_do_comments INIT(= FALSE);$/;"	v
forceit	src/cmdline.c	/^static int			forceit;$/;"	v	file:
foreground	src/gui_at_sb.h	/^    Pixel	  foreground;	\/* thumb foreground color *\/$/;"	m	struct:__anon2
found_version	src/globals.h	/^EXTERN int		found_version INIT(= 0);$/;"	v
fp	src/search.c	/^	FILE		*fp;		\/* File pointer *\/$/;"	m	struct:SearchedFile	file:
fp	tools/ctags/ctags.c	/^	FILE	*fp;			\/* stream used for reading the file *\/$/;"	m	struct:__anon21	file:
fp	tools/ctags/ctags.c	/^	FILE *fp;$/;"	m	struct:__anon19	file:
fpos	src/structs.h	/^struct fpos$/;"	s
free_buf_options	src/buffer.c	/^free_buf_options(buf)$/;"	f	file:
free_buff	src/getchar.c	/^free_buff(buf)$/;"	f	file:
free_completions	src/edit.c	/^free_completions()$/;"	f	file:
free_string_option	src/option.c	/^free_string_option(p)$/;"	f
free_yank	src/ops.c	/^free_yank(n)$/;"	f	file:
free_yank_all	src/ops.c	/^free_yank_all()$/;"	f	file:
fstatfs	src/memfile.c	59;"	d	file:
full_screen	src/globals.h	/^EXTERN int		full_screen INIT(= TRUE);$/;"	v
fullname	src/option.c	/^	char		*fullname;		\/* full option name *\/$/;"	m	struct:option	file:
fullpathcmp	src/misccmds.c	/^fullpathcmp(s1, s2)$/;"	f
funcPtr	tools/ctags/ctags.c	/^	boolean	funcPtr;		\/* whether 'name' is a function pointer *\/$/;"	m	struct:__anon15	file:
functions	tools/ctags/ctags.c	/^		boolean	functions;	\/* -if  include tags for functions *\/$/;"	m	struct:__anon17::__anon18	file:
fwd_word	src/search.c	/^fwd_word(count, type, eol)$/;"	f
gather_termleader	src/term.c	/^gather_termleader()$/;"	f	file:
gc	src/gui_at_sb.h	/^    GC		  gc;		\/* a (shared) gc *\/$/;"	m	struct:__anon2
gchar	src/misccmds.c	/^gchar(pos)$/;"	f
gchar_cursor	src/misccmds.c	/^gchar_cursor()$/;"	f
geom	src/gui.h	/^	char_u		*geom;				\/* Geometry, eg "80x24" *\/$/;"	m	struct:Gui
getNextListFile	tools/ctags/ctags.c	/^static const char *getNextListFile( fp )$/;"	f	file:
get_address	src/cmdline.c	/^get_address(ptr)$/;"	f	file:
get_bufcont	src/getchar.c	/^get_bufcont(buffer, dozero)$/;"	f	file:
get_bytes_from_buf	src/term.c	/^get_bytes_from_buf(buf, bytes, num_bytes)$/;"	f	file:
get_c_indent	src/misccmds.c	/^get_c_indent()$/;"	f
get_file_name_in_path	src/window.c	/^get_file_name_in_path(ptr, col, options)$/;"	f
get_highlight_default	src/option.c	/^get_highlight_default()$/;"	f
get_indent	src/misccmds.c	/^get_indent()$/;"	f
get_indent_lnum	src/misccmds.c	/^get_indent_lnum(lnum)$/;"	f
get_indent_nolabel	src/misccmds.c	/^get_indent_nolabel(lnum)				\/* XXX *\/$/;"	f	file:
get_indent_str	src/misccmds.c	/^get_indent_str(ptr)$/;"	f	file:
get_inserted	src/getchar.c	/^get_inserted()$/;"	f
get_key_name	src/tables.c	/^get_key_name(i)$/;"	f
get_last_insert	src/edit.c	/^get_last_insert()$/;"	f
get_leader_len	src/misccmds.c	/^get_leader_len(line, flags)$/;"	f
get_lisp_indent	src/misccmds.c	/^get_lisp_indent()$/;"	f
get_literal	src/edit.c	/^get_literal()$/;"	f
get_long_from_buf	src/term.c	/^get_long_from_buf(buf, val)$/;"	f
get_mouse_button	src/tables.c	/^get_mouse_button(code, is_click, is_drag)$/;"	f
get_mouse_class	src/normal.c	/^get_mouse_class(c)$/;"	f	file:
get_names	src/memline.c	/^get_names(names, fname)$/;"	f	file:
get_number	src/misccmds.c	/^get_number()$/;"	f
get_pseudo_mouse_code	src/tables.c	/^get_pseudo_mouse_code(button, is_click, is_drag)$/;"	f
get_recorded	src/getchar.c	/^get_recorded()$/;"	f
get_register_name	src/ops.c	/^get_register_name(num)$/;"	f
get_special_key_code	src/tables.c	/^get_special_key_code(name)$/;"	f
get_special_key_name	src/tables.c	/^get_special_key_name(c, modifiers)$/;"	f
get_stty	src/unix.c	/^get_stty()$/;"	f
get_tagfname	src/tag.c	/^get_tagfname(first, buf)$/;"	f	file:
get_termcode	src/term.c	/^get_termcode(i)$/;"	f
get_varp	src/option.c	/^get_varp(p)$/;"	f	file:
get_viminfo_parameter	src/option.c	/^get_viminfo_parameter(type)$/;"	f
get_x11_icon	src/unix.c	/^get_x11_icon(test_only)$/;"	f	file:
get_x11_title	src/unix.c	/^get_x11_title(test_only)$/;"	f	file:
get_x11_windis	src/unix.c	/^get_x11_windis()$/;"	f	file:
get_yank_buffer	src/ops.c	/^get_yank_buffer(writing)$/;"	f	file:
getargcmd	src/cmdline.c	/^getargcmd(argp)$/;"	f	file:
getchr	src/regexp.c	/^getchr()$/;"	f	file:
getcmdline	src/cmdline.c	/^getcmdline(firstc, count)$/;"	f
getcwd	src/vim.h	87;"	d
getdigits	src/misccmds.c	/^getdigits(pp)$/;"	f
getdigraph	src/digraph.c	/^getdigraph(char1, char2, meta)$/;"	f
getexactdigraph	src/digraph.c	/^getexactdigraph(char1, char2, meta)$/;"	f	file:
getfile	src/cmdline.c	/^getfile(fnum, fname, sfname, setpm, lnum)$/;"	f
gethostname	src/unix.c	1037;"	d	file:
getlinecol	src/term.c	/^getlinecol()$/;"	f
getmark	src/mark.c	/^getmark(c, changefile)$/;"	f
getout	src/main.c	/^getout(r)$/;"	f
getperm	src/archie.c	/^getperm(name)$/;"	f
getperm	src/msdos.c	/^getperm(name)$/;"	f
getperm	src/unix.c	/^getperm(name)$/;"	f
gettail	src/misccmds.c	/^gettail(fname)$/;"	f
getvcol	src/charset.c	/^getvcol(wp, pos, start, cursor, end)$/;"	f
gid_t	src/conf_os2.h	83;"	d
give_warning	src/search.c	/^give_warning(message)$/;"	f	file:
global_busy	src/globals.h	/^EXTERN int		global_busy INIT(= 0);		\/* set when :global is executing *\/$/;"	v
gotName	tools/ctags/ctags.c	/^	boolean	gotName;		\/* whether a name has yet been parsed *\/$/;"	m	struct:__anon15	file:
got_int	src/globals.h	/^EXTERN int		got_int INIT(= FALSE);		\/* set to TRUE when interrupt$/;"	v
got_x_error	src/unix.c	/^int			got_x_error = FALSE;$/;"	v
gotchars	src/getchar.c	/^gotchars(s, len)$/;"	f	file:
goto_endofbuf	src/misccmds.c	/^goto_endofbuf(pos)$/;"	f
gotocmdline	src/cmdline.c	/^gotocmdline(clr)$/;"	f
gui_convert_selection	src/ops.c	/^gui_convert_selection(str, len)$/;"	f
gui_free_selection	src/ops.c	/^gui_free_selection()$/;"	f
gui_get_selection	src/ops.c	/^gui_get_selection()$/;"	f
gui_yank_selection	src/ops.c	/^gui_yank_selection(type, str, len)$/;"	f
halfpage	src/edit.c	/^halfpage(flag, Prenum)$/;"	f
handleDirective	tools/ctags/ctags.c	/^static boolean handleDirective( c )$/;"	f	file:
has_format_option	src/option.c	/^has_format_option(x)$/;"	f
have_dollars	src/unix.c	/^have_dollars(num, file)$/;"	f	file:
have_wildcard	src/archie.c	/^have_wildcard(num, file)$/;"	f	file:
have_wildcard	src/unix.c	/^have_wildcard(num, file)$/;"	f	file:
header	tools/ctags/ctags.c	/^	int		header;			\/* boolean: is the current file a header file? *\/$/;"	m	struct:__anon21	file:
headerExt	tools/ctags/ctags.c	/^	const char *headerExt[MAX_HEADER_EXTENSIONS];	\/* -h  header extensions *\/$/;"	m	struct:__anon17	file:
height	src/gui.h	/^	int			height;				\/* Height of scroll bar (num rows) *\/$/;"	m	struct:GuiScrollbar
help_compare	src/help.c	/^help_compare(s1, s2)$/;"	f	file:
help_fname	src/Makefile	/^	-@echo 'char_u *help_fname = (char_u *)"$(VIM_HLP)";' >> pathdef.c$/;"	m
help_fname	src/Makefile	/^	-@echo 'char_u *help_fname = (char_u *)VIM_HLP;' >> pathdef.c$/;"	m
help_fname	src/pathdef.c	/^char_u *help_fname = (char_u *)"\/usr\/local\/share\/vim\/vim_help.txt";$/;"	v
help_fname	src/pathdef.c	/^char_u *help_fname = (char_u *)VIM_HLP;$/;"	v
help_heuristic	src/help.c	/^help_heuristic(matched_string, offset)$/;"	f
help_save_isk	src/globals.h	/^EXTERN char_u	*help_save_isk INIT(= NULL);\/* 'isk' saved by do_help() *\/$/;"	v
help_save_ts	src/globals.h	/^EXTERN long		help_save_ts INIT(= 0);		\/* 'ts' saved by do_help() *\/$/;"	v
hexx	tools/xxd/xxd.c	/^char hexxa[] = "0123456789abcdef0123456789ABCDEF", *hexx = hexxa;$/;"	v
hexxa	tools/xxd/xxd.c	/^char hexxa[] = "0123456789abcdef0123456789ABCDEF", *hexx = hexxa;$/;"	v
highlight	src/globals.h	/^EXTERN char_u	*highlight INIT(= NULL);	\/* string for start of highlighting *\/$/;"	v
highlight_attr	src/screen.c	/^static int 		highlight_attr = 0;	\/* attributes when highlighting on *\/$/;"	v	file:
highlight_mask	src/gui.h	/^	long_u		highlight_mask;		\/* Highlight attribute mask *\/$/;"	m	struct:Gui
highlight_match	src/globals.h	/^EXTERN int		highlight_match INIT(= FALSE);	\/* show search match pos *\/$/;"	v
hisidx	src/cmdline.c	/^static int			hisidx[2] = {-1, -1};			\/* last entered entry *\/$/;"	v	file:
hislen	src/cmdline.c	/^static int			hislen = 0; 		\/* actual lengt of history tables *\/$/;"	v	file:
history	src/cmdline.c	/^static char_u		**(history[2]) = {NULL, NULL};	\/* history tables *\/$/;"	v	file:
hkmap	src/edit.c	/^hkmap(c)$/;"	f
home_replace	src/misccmds.c	/^home_replace(buf, src, dst, dstlen)$/;"	f
home_replace_save	src/misccmds.c	/^home_replace_save(buf, src)$/;"	f
homedir	src/misccmds.c	/^static char_u	*homedir = NULL;$/;"	v	file:
hpux	src/pty.c	79;"	d	file:
huntype	tools/xxd/xxd.c	/^huntype(fpi, fpo, fperr, pname, cols, hextype, base_off)$/;"	f
id	src/gui.h	/^	Widget		id;					\/* Manage this to enable item *\/$/;"	m	struct:GuiMenu
id	src/gui.h	/^	Widget		id[2];				\/* Id of real scroll bar (left & right) *\/$/;"	m	struct:GuiScrollbar
ifdef	tools/ctags/ctags.c	/^		} ifdef[CPP_NESTING_LEVEL];$/;"	m	struct:__anon22::__anon23	typeref:struct:__anon22::__anon23::__anon24	file:
ignore	tools/ctags/ctags.c	/^			boolean ignore;$/;"	m	struct:__anon22::__anon23::__anon24	file:
illegal_char	src/option.c	/^illegal_char(errbuf, c)$/;"	f	file:
inEnumBody	tools/ctags/ctags.c	/^	boolean	inEnumBody;		\/* currently within enumeration value list *\/$/;"	m	struct:__anon15	file:
in_cinkeys	src/edit.c	/^in_cinkeys(keytyped, when, line_is_empty)$/;"	f
in_focus	src/gui.h	/^	int			in_focus;			\/* Vim has input focus *\/$/;"	m	struct:Gui
in_use	src/gui.h	/^	int			in_use;				\/* Is the GUI being used? *\/$/;"	m	struct:Gui
inbuf	src/archie.c	/^static unsigned char		inbuf[INBUFLEN];	\/* internal typeahead buffer *\/$/;"	v	file:
inbuf	src/unix.c	/^static char_u	inbuf[INBUFLEN + MAX_KEY_CODE_LEN];$/;"	v	file:
inbufcount	src/archie.c	/^static int					inbufcount = 0;		\/* number of chars in inbuf[] *\/$/;"	v	file:
inbufcount	src/unix.c	/^static int		inbufcount = 0;		\/* number of chars in inbuf[] *\/$/;"	v	file:
inc	src/linefunc.c	/^inc(lp)$/;"	f
inc_cursor	src/linefunc.c	/^inc_cursor()$/;"	f
inchar	src/getchar.c	/^inchar(buf, maxlen, wait_time)$/;"	f	file:
incl	src/linefunc.c	/^incl(lp)$/;"	f
include	tools/ctags/ctags.c	/^	} include;$/;"	m	struct:__anon17	typeref:struct:__anon17::__anon18	file:
info_pointer	src/structs.h	/^struct info_pointer$/;"	s
info_t	src/structs.h	/^typedef struct m_info info_t;$/;"	t	typeref:struct:m_info
inindent	src/misccmds.c	/^inindent(extra)$/;"	f
initStatement	tools/ctags/ctags.c	/^static void initStatement( st )$/;"	f	file:
init_chartab	src/charset.c	/^init_chartab()$/;"	f
init_history	src/cmdline.c	/^init_history()$/;"	f	file:
init_homedir	src/misccmds.c	/^init_homedir()$/;"	f
init_typebuf	src/getchar.c	/^init_typebuf()$/;"	f	file:
init_yank	src/ops.c	/^init_yank()$/;"	f
initchr	src/regexp.c	/^initchr(str)$/;"	f	file:
initpty	src/pty.c	/^initpty(f)$/;"	f	file:
inmacro	src/search.c	/^inmacro(opt, s)$/;"	f	file:
ins_char	src/misccmds.c	/^ins_char(c)$/;"	f
ins_str	src/misccmds.c	/^ins_str(s)$/;"	f
ins_typebuf	src/getchar.c	/^ins_typebuf(str, noremap, offset, nottyped)$/;"	f
insert_special	src/edit.c	/^insert_special(c, allow_modmask)$/;"	f	file:
insertbuf	src/ops.c	/^insertbuf(c)$/;"	f
insertchar	src/edit.c	/^insertchar(c, force_formatting, second_indent)$/;"	f
int_u	src/vim.h	/^typedef unsigned int	int_u;$/;"	t
invert_gc	src/gui.h	/^	GC			invert_gc;$/;"	m	struct:Gui
ip_bnum	src/structs.h	/^	blocknr_t	ip_bnum;		\/* block number *\/$/;"	m	struct:info_pointer
ip_high	src/structs.h	/^	linenr_t	ip_high;		\/* highest lnum in this block *\/$/;"	m	struct:info_pointer
ip_index	src/structs.h	/^	int			ip_index;		\/* index for block with current lnum *\/$/;"	m	struct:info_pointer
ip_low	src/structs.h	/^	linenr_t	ip_low;			\/* lowest lnum in this block *\/$/;"	m	struct:info_pointer
isComment	tools/ctags/ctags.c	/^static Comment isComment()$/;"	f	file:
isFileHeader	tools/ctags/ctags.c	/^static boolean isFileHeader( name )$/;"	f	file:
isFullName	src/msdos.c	/^isFullName(fname)$/;"	f
isFullName	src/unix.c	/^isFullName(fname)$/;"	f
isSourceFile	tools/ctags/ctags.c	/^static boolean isSourceFile( filename )$/;"	f	file:
is_backslash	src/cmdline.c	/^is_backslash(str)$/;"	f	file:
is_builtin_term	src/term.c	/^is_builtin_term(name)$/;"	f	file:
is_cinword	src/misccmds.c	/^is_cinword(line)$/;"	f	file:
is_click	src/tables.c	/^	int		is_click;			\/* Is it a mouse button click event? *\/$/;"	m	struct:__anon5	file:
is_ctrl_x_key	src/edit.c	/^is_ctrl_x_key(c)$/;"	f
is_drag	src/tables.c	/^	int		is_drag;			\/* Is it a mouse drag event? *\/$/;"	m	struct:__anon5	file:
is_fastterm	src/unix.c	/^is_fastterm(name)$/;"	f
is_in_history	src/cmdline.c	/^is_in_history(type, str, move_to_front)$/;"	f	file:
is_input_buf_empty	src/unix.c	/^is_input_buf_empty()$/;"	f
is_input_buf_full	src/unix.c	/^is_input_buf_full()$/;"	f
is_iris_ansi	src/unix.c	/^is_iris_ansi(name)$/;"	f
is_showcmd_clear	src/normal.c	/^static int		is_showcmd_clear = TRUE;$/;"	v	file:
is_xterm	src/unix.c	/^is_xterm(name)$/;"	f
is_yank_buffer	src/ops.c	/^is_yank_buffer(c, writing)$/;"	f
isbreak	src/macros.h	68;"	d
iscase	src/misccmds.c	/^iscase(s)$/;"	f
iscomment	src/misccmds.c	/^iscomment(p)$/;"	f	file:
isdefault	src/misccmds.c	/^isdefault(s)$/;"	f	file:
isdo	src/misccmds.c	/^isdo(p)$/;"	f	file:
iselse	src/misccmds.c	/^iselse(p)$/;"	f	file:
isfilechar	src/charset.c	/^isfilechar(c)$/;"	f
isfuncdecl	src/misccmds.c	/^isfuncdecl(s)$/;"	f	file:
isidchar	src/charset.c	/^isidchar(c)$/;"	f
isident	tools/ctags/ctags.c	142;"	d	file:
isident1	tools/ctags/ctags.c	146;"	d	file:
isif	src/misccmds.c	/^isif(p)$/;"	f	file:
islabel	src/misccmds.c	/^islabel(ind_maxcomment)			\/* XXX *\/$/;"	f
ismult	src/regexp.c	/^ismult(c)$/;"	f	file:
ispathsep	src/misccmds.c	/^ispathsep(c)$/;"	f
ispreproc	src/misccmds.c	/^ispreproc(s)$/;"	f	file:
isprintchar	src/charset.c	/^isprintchar(c)$/;"	f
isspacetab	tools/ctags/ctags.c	148;"	d	file:
isterminated	src/misccmds.c	/^isterminated(s)$/;"	f	file:
istermoption	src/option.c	/^istermoption(p)$/;"	f	file:
iswhileofdo	src/misccmds.c	/^iswhileofdo(p, lnum, ind_maxparen)			\/* XXX *\/$/;"	f	file:
iswordchar	src/charset.c	/^iswordchar(c)$/;"	f
ital_font	src/gui.h	/^	XFontStruct	*ital_font;$/;"	m	struct:Gui
ital_pixel	src/gui.h	/^	Pixel		ital_pixel;			\/* Pixel value of ital text *\/$/;"	m	struct:Gui
jumpProc	src/gui_at_sb.h	/^    XtCallbackList jumpProc;	\/* same as thumbProc but pass data by ref *\/$/;"	m	struct:__anon2
jump_to_mouse	src/screen.c	/^jump_to_mouse(flags)$/;"	f
jumpto_tag	src/tag.c	/^jumpto_tag(lbuf,$/;"	f	file:
keep_help_flag	src/globals.h	/^EXTERN int		keep_help_flag INIT(= FALSE); \/* doing :ta from help file *\/$/;"	v
keep_msg	src/globals.h	/^EXTERN char_u	*keep_msg INIT(= NULL);		\/* msg to be shown after redraw *\/$/;"	v
keep_msg_highlight	src/globals.h	/^EXTERN int		keep_msg_highlight INIT(= 0);\/* highlight for keep_msg *\/$/;"	v
key	src/tables.c	/^	int		key;		\/* Special key code or ascii value *\/$/;"	m	struct:key_name_entry	file:
key_name_entry	src/tables.c	/^static struct key_name_entry$/;"	s	file:
key_names_table	src/tables.c	/^} key_names_table[] =$/;"	v	typeref:struct:key_name_entry	file:
lalloc	src/alloc.c	/^lalloc(size, message)$/;"	f
langmap_init	src/option.c	/^langmap_init()$/;"	f	file:
langmap_mapchar	src/globals.h	/^EXTERN char_u	langmap_mapchar[256];	\/* mapping for language keys *\/$/;"	v
langmap_set	src/option.c	/^langmap_set()$/;"	f	file:
last_cmdline	src/globals.h	/^EXTERN char_u	*last_cmdline INIT(= NULL);	\/* last command line (for ":) *\/$/;"	v
last_insert	src/edit.c	/^static char_u	*last_insert = NULL;$/;"	v	file:
last_insert_skip	src/edit.c	/^static int		last_insert_skip;$/;"	v	file:
last_magic	src/search.c	/^static int		last_magic = TRUE;$/;"	v	file:
last_no_scs	src/search.c	/^static int		last_no_scs = FALSE;$/;"	v	file:
last_pattern	src/search.c	/^static char_u	*last_pattern = NULL;$/;"	v	file:
last_recorded_len	src/getchar.c	/^static int		last_recorded_len = 0;	\/* number of last recorded chars *\/$/;"	v	file:
last_status	src/window.c	/^last_status()$/;"	f
lastbuf	src/globals.h	/^EXTERN BUF		*lastbuf INIT(= NULL);	\/* last buffer *\/$/;"	v
lasticon	src/buffer.c	/^static char_u *lasticon = NULL;$/;"	v	file:
lasttitle	src/buffer.c	/^static char_u *lasttitle = NULL;$/;"	v	file:
lastwin	src/globals.h	/^EXTERN WIN		*lastwin;		\/* last window *\/$/;"	v
lbr_chartabsize	src/charset.c	/^lbr_chartabsize(s, col)$/;"	f
lcnt	tools/mvi/mvi.c	/^static int cnt= 0, dcnt= 0, lcnt= 0;$/;"	v	file:
len	src/term.c	/^	int		len;			\/* STRLEN(code) *\/$/;"	m	struct:termcode	file:
length	src/gui_at_sb.h	/^    Dimension	  length;	\/* either height or width *\/$/;"	m	struct:__anon2
level	tools/ctags/ctags.c	/^		int			level;		\/* level 0 is not used *\/$/;"	m	struct:__anon22::__anon23	file:
line	tools/ctags/ctags.c	/^	struct { size_t line, tag, file; } max;$/;"	m	struct:__anon19::__anon20	file:
line1	src/cmdline.c	/^static linenr_t 	line1, line2;$/;"	v	file:
line2	src/cmdline.c	/^static linenr_t 	line1, line2;$/;"	v	file:
lineBreak	tools/ctags/ctags.c	/^static void lineBreak() {}$/;"	f	file:
lineNumber	tools/ctags/ctags.c	/^	long	lineNumber;		\/* line number in the current file *\/$/;"	m	struct:__anon21	file:
lineNumber	tools/ctags/ctags.c	/^	long	lineNumber;		\/* line number of tag *\/$/;"	m	struct:__anon13	file:
line_breakcheck	src/misccmds.c	/^line_breakcheck()$/;"	f
lineclear	src/screen.c	/^lineclear(p)$/;"	f	file:
lineempty	src/macros.h	32;"	d
linenr_t	src/structs.h	/^typedef long			linenr_t;$/;"	t
linenr_t	src/vim.h	/^typedef long		linenr_t;		\/* line number type *\/$/;"	t
lines_left	src/message.c	/^static int	lines_left = -1;			\/* lines left for listing *\/$/;"	v	file:
linetabsize	src/charset.c	/^linetabsize(s)$/;"	f
linewhite	src/search.c	/^linewhite(lnum)$/;"	f
listdigraphs	src/digraph.c	/^listdigraphs()$/;"	f
lnum	src/search.c	/^	linenr_t	lnum;		\/* Line we were up to in file *\/$/;"	m	struct:SearchedFile	file:
lnum	src/structs.h	/^	linenr_t		lnum;			\/* line number *\/$/;"	m	struct:fpos
location	tools/ctags/ctags.c	/^	long	location;		\/* file position of line containing name *\/$/;"	m	struct:__anon13	file:
longVersion	src/version.c	/^char		   *longVersion = "VIM - Vi IMproved 4.0 (1996 May 29)";$/;"	v
longVersion	src/version.c	/^char		   *longVersion = "VIM - Vi IMproved 4.0 (1996 May 29, compiled " __DATE__ " " __TIME__ ")";$/;"	v
long_to_char	src/memline.c	/^long_to_char(n, s)$/;"	f	file:
long_u	src/vim.h	/^typedef unsigned long	long_u;$/;"	t
lowest_marked	src/memline.c	/^static linenr_t	lowest_marked = 0;$/;"	v	file:
lt	src/macros.h	21;"	d
ltoreq	src/macros.h	24;"	d
m_block	src/structs.h	/^struct m_block$/;"	s
m_info	src/structs.h	/^struct m_info$/;"	s
m_keylen	src/getchar.c	/^	int				 m_keylen;		\/* strlen(m_keys) *\/$/;"	m	struct:mapblock	file:
m_keys	src/getchar.c	/^	char_u			*m_keys;		\/* mapped from *\/$/;"	m	struct:mapblock	file:
m_mode	src/getchar.c	/^	int 			 m_mode;		\/* valid mode *\/$/;"	m	struct:mapblock	file:
m_next	src/getchar.c	/^	struct mapblock *m_next;		\/* next mapblock *\/$/;"	m	struct:mapblock	typeref:struct:mapblock::mapblock	file:
m_next	src/structs.h	/^	info_t	*m_next;	\/* pointer to next free chunk in the list *\/$/;"	m	struct:m_info
m_noremap	src/getchar.c	/^	int				 m_noremap;		\/* if non-zero no re-mapping for m_str *\/$/;"	m	struct:mapblock	file:
m_size	src/structs.h	/^	long_u	 m_size;	\/* size of the chunk (including m_info) *\/$/;"	m	struct:m_info
m_str	src/getchar.c	/^	char_u			*m_str; 		\/* mapped to *\/$/;"	m	struct:mapblock	file:
main	doc/doctags.c	/^main(argc, argv)$/;"	f
main	macros/maze/maze.c	/^char*M,A,Z,E=40,J[40],T[40];main(C){for(*J=A=scanf(M="%d",&C);$/;"	f
main	macros/maze/mazeansi.c	/^char*M,A,Z,E=40,J[80],T[3];main(C){for(M=J+E,*J=A=scanf("%d",&$/;"	f
main	src/addcr.c	/^main(argc, argv)$/;"	f
main	src/main.c	/^main(argc, argv)$/;"	f
main	src/mk_os2pd.c	/^main(argc, argv)$/;"	f
main	src/mkcmdtab.c	/^main(argc, argv)$/;"	f
main	tools/ctags/ctags.c	/^extern int main( argc, argv )$/;"	f
main	tools/mvi/mvi.c	/^main( argc, argv )$/;"	f
main	tools/xxd/xxd.c	/^main(argc, argv)$/;"	f
makeDefineTag	tools/ctags/ctags.c	/^static void makeDefineTag( tag, scope )$/;"	f	file:
makeTag	tools/ctags/ctags.c	/^static void makeTag( tag, scope, tagType )$/;"	f	file:
make_cmd_chars	src/cmdline.c	/^static char *(make_cmd_chars[6]) =$/;"	v	file:
make_cyclic	src/edit.c	/^make_cyclic()$/;"	f	file:
make_windows	src/window.c	/^make_windows(count)$/;"	f
makemap	src/getchar.c	/^makemap(fd)$/;"	f
makeset	src/option.c	/^makeset(fd)$/;"	f
makeswapname	src/memline.c	/^makeswapname(buf, dir_name)$/;"	f	file:
maketitle	src/buffer.c	/^maketitle()$/;"	f
map_clear	src/getchar.c	/^map_clear(modec, force, abbr)$/;"	f
map_free	src/getchar.c	/^map_free(mprev)$/;"	f	file:
mapblock	src/getchar.c	/^struct mapblock$/;"	s	file:
maplist	src/getchar.c	/^static struct mapblock maplist = {NULL, NULL, 0, NULL, 0, 0};$/;"	v	typeref:struct:mapblock	file:
mark	src/structs.h	/^	FPOS			mark;			\/* cursor position *\/$/;"	m	struct:filemark
mark_adjust	src/mark.c	/^mark_adjust(line1, line2, amount, amount_after)$/;"	f
match	tools/ctags/ctags.c	1509;"	d	file:
matched	src/search.c	/^	int			matched;	\/* Found a match in this file *\/$/;"	m	struct:SearchedFile	file:
max	src/gui.h	/^	int			max;				\/* Number of lines in buffer *\/$/;"	m	struct:GuiScrollbar
max	src/gui_at_sb.h	/^    float	  max;		\/* Maximum value for top *\/$/;"	m	struct:__anon2
max	tools/ctags/ctags.c	/^	struct { size_t line, tag, file; } max;$/;"	m	struct:__anon19	typeref:struct:__anon19::__anon20	file:
maxfiles	src/msdos.c	/^	int		maxfiles;$/;"	m	struct:filelist	file:
may_core_dump	src/unix.c	/^may_core_dump()$/;"	f	file:
mb_info	src/structs.h	/^	info_t			mb_info;	\/* head of free chuck list for this block *\/$/;"	m	struct:m_block
mb_next	src/structs.h	/^	struct m_block	*mb_next;	\/* pointer to next allocated block *\/$/;"	m	struct:m_block	typeref:struct:m_block::m_block
mch_avail_mem	src/msdos.c	/^mch_avail_mem(special)$/;"	f
mch_avail_mem	src/unix.c	/^mch_avail_mem(special)$/;"	f
mch_breakcheck	src/archie.c	/^mch_breakcheck()$/;"	f
mch_breakcheck	src/msdos.c	/^mch_breakcheck()$/;"	f
mch_breakcheck	src/unix.c	/^mch_breakcheck()$/;"	f
mch_can_restore_icon	src/archie.c	/^mch_can_restore_icon()$/;"	f
mch_can_restore_icon	src/msdos.c	/^mch_can_restore_icon()$/;"	f
mch_can_restore_icon	src/unix.c	/^mch_can_restore_icon()$/;"	f
mch_can_restore_title	src/archie.c	/^mch_can_restore_title()$/;"	f
mch_can_restore_title	src/msdos.c	/^mch_can_restore_title()$/;"	f
mch_can_restore_title	src/unix.c	/^mch_can_restore_title()$/;"	f
mch_char_avail	src/msdos.c	/^mch_char_avail()$/;"	f
mch_char_avail	src/unix.c	/^mch_char_avail()$/;"	f
mch_check_input	src/archie.c	/^mch_check_input()$/;"	f
mch_check_input	src/msdos.c	/^mch_check_input()$/;"	f
mch_check_input	src/unix.c	/^mch_check_input()$/;"	f
mch_check_win	src/archie.c	/^mch_check_win(argc, argv)$/;"	f
mch_check_win	src/msdos.c	/^mch_check_win(argc, argv)$/;"	f
mch_check_win	src/unix.c	/^mch_check_win(argc, argv)$/;"	f
mch_delay	src/archie.c	/^mch_delay(msec, ignoreinput)$/;"	f
mch_delay	src/msdos.c	/^mch_delay(msec, ignoreinput)$/;"	f
mch_delay	src/unix.c	/^mch_delay(msec, ignoreinput)$/;"	f
mch_dirname	src/msdos.c	/^mch_dirname(buf, len)$/;"	f
mch_dirname	src/unix.c	/^mch_dirname(buf, len)$/;"	f
mch_get_host_name	src/archie.c	/^mch_get_host_name(s, len)$/;"	f
mch_get_host_name	src/msdos.c	/^mch_get_host_name(s, len)$/;"	f
mch_get_host_name	src/unix.c	/^mch_get_host_name(s, len)$/;"	f
mch_get_pid	src/archie.c	/^mch_get_pid()$/;"	f
mch_get_pid	src/msdos.c	/^mch_get_pid()$/;"	f
mch_get_pid	src/unix.c	/^mch_get_pid()$/;"	f
mch_get_user_name	src/archie.c	/^mch_get_user_name(s, len)$/;"	f
mch_get_user_name	src/msdos.c	/^mch_get_user_name(s, len)$/;"	f
mch_get_user_name	src/unix.c	/^mch_get_user_name(s, len)$/;"	f
mch_get_winsize	src/archie.c	/^mch_get_winsize()$/;"	f
mch_get_winsize	src/msdos.c	/^mch_get_winsize()$/;"	f
mch_get_winsize	src/unix.c	/^mch_get_winsize()$/;"	f
mch_has_wildcard	src/archie.c	/^mch_has_wildcard(p)$/;"	f
mch_has_wildcard	src/msdos.c	/^mch_has_wildcard(s)$/;"	f
mch_has_wildcard	src/unix.c	/^mch_has_wildcard(p)$/;"	f
mch_inchar	src/archie.c	/^mch_inchar(buf, maxlen, time)$/;"	f
mch_inchar	src/msdos.c	/^mch_inchar(buf, maxlen, time)$/;"	f
mch_inchar	src/unix.c	/^mch_inchar(buf, maxlen, wtime)$/;"	f
mch_isdir	src/archie.c	/^mch_isdir(name)$/;"	f
mch_isdir	src/msdos.c	/^mch_isdir(name)$/;"	f
mch_isdir	src/unix.c	/^mch_isdir(name)$/;"	f
mch_resettitle	src/archie.c	/^mch_resettitle()$/;"	f
mch_resize	src/unix.c	/^mch_resize()$/;"	f
mch_restore_title	src/msdos.c	/^mch_restore_title(which)$/;"	f
mch_restore_title	src/unix.c	/^mch_restore_title(which)$/;"	f
mch_screenmode	src/msdos.c	/^mch_screenmode(arg)$/;"	f
mch_screenmode	src/unix.c	/^mch_screenmode(arg)$/;"	f
mch_set_winsize	src/archie.c	/^mch_set_winsize()$/;"	f
mch_set_winsize	src/msdos.c	/^mch_set_winsize()$/;"	f
mch_set_winsize	src/unix.c	/^mch_set_winsize()$/;"	f
mch_setmouse	src/msdos.c	/^mch_setmouse(on)$/;"	f
mch_setmouse	src/unix.c	/^mch_setmouse(on)$/;"	f
mch_settitle	src/archie.c	/^mch_settitle(str)$/;"	f
mch_settitle	src/msdos.c	/^mch_settitle(title, icon)$/;"	f
mch_settitle	src/unix.c	/^mch_settitle(title, icon)$/;"	f
mch_settmode	src/archie.c	/^mch_settmode(raw)$/;"	f
mch_settmode	src/msdos.c	/^mch_settmode(raw)$/;"	f
mch_settmode	src/unix.c	/^mch_settmode(raw)$/;"	f
mch_suspend	src/archie.c	/^mch_suspend()$/;"	f
mch_suspend	src/msdos.c	/^mch_suspend()$/;"	f
mch_suspend	src/unix.c	/^mch_suspend()$/;"	f
mch_windexit	src/archie.c	/^mch_windexit(r)$/;"	f
mch_windexit	src/msdos.c	/^mch_windexit(r)$/;"	f
mch_windexit	src/unix.c	/^mch_windexit(r)$/;"	f
mch_windinit	src/archie.c	/^mch_windinit()$/;"	f
mch_windinit	src/msdos.c	/^mch_windinit()$/;"	f
mch_windinit	src/unix.c	/^mch_windinit()$/;"	f
mch_write	src/archie.c	/^mch_write(s, len)$/;"	f
mch_write	src/msdos.c	/^mch_write(s, len)$/;"	f
mch_write	src/unix.c	/^mch_write(s, len)$/;"	f
memfile	src/structs.h	/^struct memfile$/;"	s
memline	src/structs.h	/^struct memline$/;"	s
menu_bg_pixel	src/gui.h	/^	Pixel		menu_bg_pixel;		\/* Pixel value of menu backgound *\/$/;"	m	struct:Gui
menu_fg_pixel	src/gui.h	/^	Pixel		menu_fg_pixel;		\/* Pixel value of menu foregound *\/$/;"	m	struct:Gui
menu_height	src/gui.h	/^	int			menu_height;		\/* Height of the menu bar *\/$/;"	m	struct:Gui
menu_is_active	src/gui.h	/^	int			menu_is_active;		\/* TRUE if menu is present *\/$/;"	m	struct:Gui
mf_alloc_bhdr	src/memfile.c	/^mf_alloc_bhdr(mfp, page_count)$/;"	f	file:
mf_blocknr_max	src/structs.h	/^	blocknr_t	mf_blocknr_max;		\/* highest positive block number + 1*\/$/;"	m	struct:memfile
mf_blocknr_min	src/structs.h	/^	blocknr_t	mf_blocknr_min;		\/* lowest negative block number - 1 *\/$/;"	m	struct:memfile
mf_close	src/memfile.c	/^mf_close(mfp, del_file)$/;"	f
mf_dirty	src/structs.h	/^	int			mf_dirty;			\/* Set to TRUE if there are dirty blocks *\/$/;"	m	struct:memfile
mf_do_open	src/memfile.c	/^mf_do_open(mfp, fname, trunc_file)$/;"	f	file:
mf_fd	src/structs.h	/^	int			mf_fd;				\/* file descriptor *\/$/;"	m	struct:memfile
mf_find_hash	src/memfile.c	/^mf_find_hash(mfp, nr)$/;"	f	file:
mf_fname	src/structs.h	/^	char_u		*mf_fname;			\/* name of the file *\/$/;"	m	struct:memfile
mf_free	src/memfile.c	/^mf_free(mfp, hp)$/;"	f
mf_free_bhdr	src/memfile.c	/^mf_free_bhdr(hp)$/;"	f	file:
mf_free_first	src/structs.h	/^	BHDR		*mf_free_first;		\/* first block_hdr in free list *\/$/;"	m	struct:memfile
mf_fullname	src/memfile.c	/^mf_fullname(mfp)$/;"	f
mf_get	src/memfile.c	/^mf_get(mfp, nr, page_count)$/;"	f
mf_hash	src/structs.h	/^	BHDR		*mf_hash[MEMHASHSIZE];	\/* array of hash lists *\/$/;"	m	struct:memfile
mf_infile_count	src/structs.h	/^	blocknr_t	mf_infile_count;	\/* number of pages in the file *\/$/;"	m	struct:memfile
mf_ins_free	src/memfile.c	/^mf_ins_free(mfp, hp)$/;"	f	file:
mf_ins_hash	src/memfile.c	/^mf_ins_hash(mfp, hp)$/;"	f	file:
mf_ins_used	src/memfile.c	/^mf_ins_used(mfp, hp)$/;"	f	file:
mf_need_trans	src/memfile.c	/^mf_need_trans(mfp)$/;"	f
mf_neg_count	src/structs.h	/^	blocknr_t	mf_neg_count;		\/* number of negative blocks numbers *\/$/;"	m	struct:memfile
mf_new	src/memfile.c	/^mf_new(mfp, negative, page_count)$/;"	f
mf_open	src/memfile.c	/^mf_open(fname, trunc_file)$/;"	f
mf_open_file	src/memfile.c	/^mf_open_file(mfp, fname)$/;"	f
mf_page_size	src/structs.h	/^	unsigned	mf_page_size;		\/* number of bytes in a page *\/$/;"	m	struct:memfile
mf_put	src/memfile.c	/^mf_put(mfp, hp, dirty, infile)$/;"	f
mf_read	src/memfile.c	/^mf_read(mfp, hp)$/;"	f	file:
mf_release	src/memfile.c	/^mf_release(mfp, page_count)$/;"	f	file:
mf_release_all	src/memfile.c	/^mf_release_all()$/;"	f
mf_rem_free	src/memfile.c	/^mf_rem_free(mfp)$/;"	f	file:
mf_rem_hash	src/memfile.c	/^mf_rem_hash(mfp, hp)$/;"	f	file:
mf_rem_used	src/memfile.c	/^mf_rem_used(mfp, hp)$/;"	f	file:
mf_set_xfname	src/memfile.c	/^mf_set_xfname(mfp)$/;"	f
mf_statistics	src/memfile.c	/^mf_statistics()$/;"	f
mf_sync	src/memfile.c	/^mf_sync(mfp, all, check_char, do_fsync)$/;"	f
mf_trans	src/structs.h	/^	NR_TRANS	*mf_trans[MEMHASHSIZE];	\/* array of trans lists *\/$/;"	m	struct:memfile
mf_trans_add	src/memfile.c	/^mf_trans_add(mfp, hp)$/;"	f	file:
mf_trans_del	src/memfile.c	/^mf_trans_del(mfp, old_nr)$/;"	f
mf_used_count	src/structs.h	/^	unsigned	mf_used_count;		\/* number of pages in used list *\/$/;"	m	struct:memfile
mf_used_count_max	src/structs.h	/^	unsigned	mf_used_count_max;	\/* maximum number of pages in memory *\/$/;"	m	struct:memfile
mf_used_first	src/structs.h	/^	BHDR		*mf_used_first;		\/* mru block_hdr in used list *\/$/;"	m	struct:memfile
mf_used_last	src/structs.h	/^	BHDR		*mf_used_last;		\/* lru block_hdr in used list *\/$/;"	m	struct:memfile
mf_write	src/memfile.c	/^mf_write(mfp, hp)$/;"	f	file:
mf_xfname	src/structs.h	/^	char_u		*mf_xfname;			\/* idem, full path *\/$/;"	m	struct:memfile
min_rows	src/window.c	/^min_rows()$/;"	f
min_thumb	src/gui_at_sb.h	/^    Dimension	  min_thumb;	\/* minium size for the thumb. *\/$/;"	m	struct:__anon2
mktemp	src/cmdcmds.c	19;"	d	file:
ml_add_stack	src/memline.c	/^ml_add_stack(buf)$/;"	f	file:
ml_append	src/memline.c	/^ml_append(lnum, line, len, newfile)$/;"	f
ml_append_int	src/memline.c	/^ml_append_int(buf, lnum, line, len, newfile)$/;"	f	file:
ml_clearmarked	src/memline.c	/^ml_clearmarked()$/;"	f
ml_close	src/memline.c	/^ml_close(buf, del_file)$/;"	f
ml_close_all	src/memline.c	/^ml_close_all(del_file)$/;"	f
ml_close_notmod	src/memline.c	/^ml_close_notmod()$/;"	f
ml_delete	src/memline.c	/^ml_delete(lnum, message)$/;"	f
ml_delete_int	src/memline.c	/^ml_delete_int(buf, lnum, message)$/;"	f	file:
ml_find_line	src/memline.c	/^ml_find_line(buf, lnum, action)$/;"	f	file:
ml_firstmarked	src/memline.c	/^ml_firstmarked()$/;"	f
ml_flags	src/structs.h	/^	int			ml_flags;$/;"	m	struct:memline
ml_flush_line	src/memline.c	/^ml_flush_line(buf)$/;"	f	file:
ml_get	src/memline.c	/^ml_get(lnum)$/;"	f
ml_get_buf	src/memline.c	/^ml_get_buf(buf, lnum, will_change)$/;"	f
ml_get_curline	src/memline.c	/^ml_get_curline()$/;"	f
ml_get_cursor	src/memline.c	/^ml_get_cursor()$/;"	f
ml_get_pos	src/memline.c	/^ml_get_pos(pos)$/;"	f
ml_has_mark	src/memline.c	/^ml_has_mark(lnum)$/;"	f
ml_line_alloced	src/memline.c	/^ml_line_alloced()$/;"	f
ml_line_count	src/structs.h	/^	linenr_t	ml_line_count;	\/* number of lines in the buffer *\/$/;"	m	struct:memline
ml_line_lnum	src/structs.h	/^	linenr_t	ml_line_lnum;	\/* line number of cached line, 0 if not valid *\/$/;"	m	struct:memline
ml_line_ptr	src/structs.h	/^	char_u		*ml_line_ptr;	\/* pointer to cached line *\/$/;"	m	struct:memline
ml_lineadd	src/memline.c	/^ml_lineadd(buf, count)$/;"	f	file:
ml_locked	src/structs.h	/^	BHDR		*ml_locked;		\/* block used by last ml_get *\/$/;"	m	struct:memline
ml_locked_high	src/structs.h	/^	linenr_t	ml_locked_high;	\/* last line in ml_locked *\/$/;"	m	struct:memline
ml_locked_lineadd	src/structs.h	/^	int			ml_locked_lineadd;	\/* number of lines inserted in ml_locked *\/$/;"	m	struct:memline
ml_locked_low	src/structs.h	/^	linenr_t	ml_locked_low;	\/* first line in ml_locked *\/$/;"	m	struct:memline
ml_mfp	src/structs.h	/^	MEMFILE		*ml_mfp;		\/* pointer to associated memfile *\/$/;"	m	struct:memline
ml_new_data	src/memline.c	/^ml_new_data(mfp, negative, page_count)$/;"	f	file:
ml_new_ptr	src/memline.c	/^ml_new_ptr(mfp)$/;"	f	file:
ml_open	src/memline.c	/^ml_open()$/;"	f
ml_open_file	src/memline.c	/^ml_open_file(buf)$/;"	f	file:
ml_open_files	src/memline.c	/^ml_open_files()$/;"	f
ml_preserve	src/memline.c	/^ml_preserve(buf, message)$/;"	f
ml_recover	src/memline.c	/^ml_recover()$/;"	f
ml_replace	src/memline.c	/^ml_replace(lnum, line, copy)$/;"	f
ml_setmarked	src/memline.c	/^ml_setmarked(lnum)$/;"	f
ml_setname	src/memline.c	/^ml_setname()$/;"	f
ml_stack	src/structs.h	/^	IPTR		*ml_stack;		\/* stack of pointer blocks (array of IPTRs) *\/$/;"	m	struct:memline
ml_stack_size	src/structs.h	/^	int			ml_stack_size;	\/* total number of entries in ml_stack *\/$/;"	m	struct:memline
ml_stack_top	src/structs.h	/^	int			ml_stack_top;	\/* current top if ml_stack *\/$/;"	m	struct:memline
ml_sync_all	src/memline.c	/^ml_sync_all(check_file, check_char)$/;"	f
ml_timestamp	src/memline.c	/^ml_timestamp(buf)$/;"	f
mod_mask	src/globals.h	/^EXTERN int		mod_mask INIT(= 0x0);			\/* current key modifiers *\/$/;"	v
mod_mask	src/tables.c	/^	int		mod_mask;		\/* Bit-mask for particular key modifier *\/$/;"	m	struct:__anon4	file:
mod_mask_table	src/tables.c	/^} mod_mask_table[] =$/;"	v	typeref:struct:__anon4	file:
mode	src/gui.h	/^	short_u		mode;				\/* Select by char, word, or line. *\/$/;"	m	struct:GuiSelection
mode_t	src/conf_os2.h	68;"	d
modes	src/gui.h	/^	int			modes;				\/* Which modes is this menu visible for? *\/$/;"	m	struct:GuiMenu
modified	src/globals.h	/^EXTERN int		modified INIT(= FALSE);			\/* buffer was modified since$/;"	v
modname	src/fileio.c	/^modname(fname, ext)$/;"	f
moreenv	src/pty.c	/^moreenv()$/;"	f	file:
mouse_active	src/msdos.c	/^static int mouse_active;			\/* mouse enabled *\/$/;"	v	file:
mouse_area	src/msdos.c	/^mouse_area()$/;"	f	file:
mouse_avail	src/msdos.c	/^static int mouse_avail = FALSE;		\/* mouse present *\/$/;"	v	file:
mouse_click	src/msdos.c	/^static int mouse_click = 0;			\/* mouse status *\/$/;"	v	file:
mouse_click_count	src/msdos.c	/^static int mouse_click_count = 0;	\/* count for multi-clicks *\/$/;"	v	file:
mouse_click_time	src/msdos.c	/^static long mouse_click_time = 0;	\/* biostime() of last click *\/$/;"	v	file:
mouse_click_x	src/msdos.c	/^static int mouse_click_x = 0;		\/* x of previous mouse click *\/$/;"	v	file:
mouse_click_y	src/msdos.c	/^static int mouse_click_y = 0;		\/* y of previous mouse click *\/$/;"	v	file:
mouse_col	src/globals.h	/^EXTERN int		mouse_col;$/;"	v
mouse_has	src/term.c	/^mouse_has(c)$/;"	f
mouse_hidden	src/msdos.c	/^static int mouse_hidden;			\/* mouse not shown *\/$/;"	v	file:
mouse_last_click	src/msdos.c	/^static int mouse_last_click = 0;	\/* previous status at click *\/$/;"	v	file:
mouse_past_bottom	src/globals.h	/^EXTERN int		mouse_past_bottom INIT(= FALSE);\/* mouse below last line *\/$/;"	v
mouse_past_eol	src/globals.h	/^EXTERN int		mouse_past_eol INIT(= FALSE);	\/* mouse right of line *\/$/;"	v
mouse_row	src/globals.h	/^EXTERN int		mouse_row;$/;"	v
mouse_table	src/tables.c	/^} mouse_table[] =$/;"	v	typeref:struct:__anon5	file:
mouse_topline	src/msdos.c	/^static linenr_t mouse_topline = 0;	\/* topline at previous mouse click *\/$/;"	v	file:
mouse_x	src/msdos.c	/^static int mouse_x = -1;			\/* mouse x coodinate *\/$/;"	v	file:
mouse_y	src/msdos.c	/^static int mouse_y = -1;			\/* mouse y coodinate *\/$/;"	v	file:
movemark	src/mark.c	/^movemark(count)$/;"	f
mr_pattern	src/search.c	/^static char_u	*mr_pattern = NULL;		\/* pattern used by myregcomp() *\/$/;"	v	file:
msg	src/message.c	/^msg(s)$/;"	f
msg_add_fname	src/fileio.c	/^msg_add_fname(buf, fname)$/;"	f	file:
msg_add_lines	src/fileio.c	/^msg_add_lines(insert_space, lnum, nchars)$/;"	f	file:
msg_add_textmode	src/fileio.c	/^msg_add_textmode(textmode)$/;"	f	file:
msg_buf	src/globals.h	/^EXTERN char_u	msg_buf[MSG_BUF_LEN];	\/* small buffer for messages *\/$/;"	v
msg_check	src/message.c	/^msg_check()$/;"	f
msg_check_screen	src/message.c	/^msg_check_screen()$/;"	f	file:
msg_clr_eos	src/message.c	/^msg_clr_eos()$/;"	f
msg_col	src/globals.h	/^EXTERN int		msg_col;$/;"	v
msg_didany	src/globals.h	/^EXTERN int		msg_didany INIT(= FALSE);	\/* msg_outstr() was used at all *\/$/;"	v
msg_didout	src/globals.h	/^EXTERN int		msg_didout INIT(= FALSE);	\/* msg_outstr() was used in line *\/$/;"	v
msg_end	src/message.c	/^msg_end()$/;"	f
msg_highlight	src/globals.h	/^EXTERN int		msg_highlight INIT(= FALSE);\/* message should be highlighted *\/$/;"	v
msg_home_replace	src/message.c	/^msg_home_replace(fname)$/;"	f
msg_moremsg	src/message.c	/^msg_moremsg(full)$/;"	f
msg_outchar	src/message.c	/^msg_outchar(c)$/;"	f
msg_outnum	src/message.c	/^msg_outnum(n)$/;"	f
msg_outstr	src/message.c	/^msg_outstr(s)$/;"	f
msg_outtrans	src/message.c	/^msg_outtrans(str)$/;"	f
msg_outtrans_len	src/message.c	/^msg_outtrans_len(str, len)$/;"	f
msg_outtrans_special	src/message.c	/^msg_outtrans_special(str, all)$/;"	f
msg_pos	src/message.c	/^msg_pos(row, col)$/;"	f
msg_prt_line	src/message.c	/^msg_prt_line(s)$/;"	f
msg_row	src/globals.h	/^EXTERN int		msg_row;$/;"	v
msg_screen_outchar	src/message.c	/^msg_screen_outchar(c)$/;"	f	file:
msg_scroll	src/globals.h	/^EXTERN int		msg_scroll INIT(= FALSE);	\/* msg_start() will scroll *\/$/;"	v
msg_scrolled	src/globals.h	/^EXTERN int		msg_scrolled; $/;"	v
msg_start	src/message.c	/^msg_start()$/;"	f
msg_trunc	src/message.c	/^msg_trunc(s)$/;"	f
msgmore	src/misccmds.c	/^msgmore(n)$/;"	f
must_redraw	src/globals.h	/^EXTERN int		must_redraw INIT(= 0);		\/* type of redraw necessary *\/$/;"	v
myregcomp	src/search.c	/^myregcomp(pat, sub_cmd, which_pat, options)$/;"	f
name	src/gui.h	/^	char_u		*name;				\/* Name shown in menu *\/$/;"	m	struct:GuiMenu
name	src/option.c	/^	char	*name;		\/* event name *\/$/;"	m	struct:event_name	file:
name	src/search.c	/^	char_u		*name;		\/* Full name of file *\/$/;"	m	struct:SearchedFile	file:
name	src/tables.c	/^	char_u	*name;		\/* Name of key *\/$/;"	m	struct:key_name_entry	file:
name	src/tables.c	/^	char_u	name;			\/* Single letter name of modifier *\/$/;"	m	struct:__anon4	file:
name	src/term.c	/^	char_u	name[2];		\/* termcap name of entry *\/$/;"	m	struct:termcode	file:
name	src/unix.c	/^	char	*name;		\/* Signal name (not char_u!). *\/$/;"	m	struct:__anon6	file:
name	tools/ctags/ctags.c	/^	char	*name;			\/* the name of the token *\/$/;"	m	struct:__anon13	file:
name	tools/ctags/ctags.c	/^	char	name[MAXNAME];			\/* the name of the last NAME token *\/$/;"	m	struct:__anon16	file:
name	tools/ctags/ctags.c	/^	const char *name;		\/* name of the current file *\/$/;"	m	struct:__anon21	file:
name	tools/ctags/ctags.c	/^	const char *name;$/;"	m	struct:__anon19	file:
name_to_mod_mask	src/tables.c	/^name_to_mod_mask(c)$/;"	f
namedfm	src/mark.c	/^static struct filemark namedfm[NMARKS + EXTRA_MARKS];	\/* marks with file nr *\/$/;"	v	typeref:struct:filemark	file:
namedfm_names	src/mark.c	/^static char_u *namedfm_names[NMARKS + EXTRA_MARKS];		\/* name for namedfm[] *\/$/;"	v	file:
need_check_timestamps	src/globals.h	/^EXTERN int		need_check_timestamps INIT(= FALSE);	\/* got STOP signal *\/$/;"	v
need_fileinfo	src/globals.h	/^EXTERN int		need_fileinfo INIT(= FALSE);\/* do fileinfo() after redraw *\/$/;"	v
need_gather	src/term.c	/^static int		need_gather = FALSE;			\/* need to fill termleader[] *\/$/;"	v	file:
need_sleep	src/globals.h	/^EXTERN int		need_sleep INIT(= FALSE);	\/* call sleep() before redraw *\/$/;"	v
need_start_insertmode	src/globals.h	/^EXTERN int		need_start_insertmode INIT(= FALSE);$/;"	v
need_wait_return	src/globals.h	/^EXTERN int		need_wait_return INIT(= 0);	\/* need to wait for return later *\/$/;"	v
new_insert_skip	src/edit.c	/^static int		new_insert_skip;$/;"	v	file:
new_last_cmdline	src/globals.h	/^EXTERN char_u	*new_last_cmdline INIT(= NULL);	\/* new value for last_cmdline *\/$/;"	v
new_sb	src/gui.h	/^	int			new_sb[3];			\/* Which scrollbar boxes are new? *\/$/;"	m	struct:Gui
newenv	src/pty.c	/^newenv()$/;"	f	file:
next	src/edit.c	/^	struct Completion	*next;$/;"	m	struct:Completion	typeref:struct:Completion::Completion	file:
next	src/gui.h	/^	struct GuiMenu *next;			\/* Next item in menu *\/$/;"	m	struct:GuiMenu	typeref:struct:GuiMenu::GuiMenu
next	src/option.c	/^	struct AutoCmd	*next;					\/* Next AutoCmd in list *\/$/;"	m	struct:AutoCmd	typeref:struct:AutoCmd::AutoCmd	file:
next	src/option.c	/^	struct AutoPat	*next;					\/* next AutoPat in AutoPat list *\/$/;"	m	struct:AutoPat	typeref:struct:AutoPat::AutoPat	file:
next	src/quickfix.c	/^	struct eformat	*next;			\/* pointer to next (NULL if last) *\/$/;"	m	struct:eformat	typeref:struct:eformat::eformat	file:
nextToken	tools/ctags/ctags.c	/^static boolean nextToken( st )$/;"	f	file:
nextchr	src/regexp.c	/^static int		nextchr;	\/* used for ungetchr() *\/$/;"	v	file:
nextwild	src/cmdline.c	/^nextwild(type)$/;"	f	file:
nfiles	src/msdos.c	/^	int		nfiles;$/;"	m	struct:filelist	file:
no_abbr	src/globals.h	/^EXTERN int		no_abbr INIT(= TRUE);	\/* TRUE when no abbreviations loaded *\/$/;"	v
no_abbr_cnt	src/getchar.c	/^static int		no_abbr_cnt = 0;	\/* nr of chars without abbrev. in typebuf *\/$/;"	v	file:
no_lines_msg	src/globals.h	/^EXTERN char_u no_lines_msg[]		INIT(="--No lines in buffer--");$/;"	v
no_mapping	src/globals.h	/^EXTERN int		no_mapping INIT(= FALSE);	\/* currently no mapping allowed *\/$/;"	v
no_smartcase	src/globals.h	/^EXTERN int		no_smartcase INIT(= FALSE);	\/* don't use 'smartcase' once *\/$/;"	v
no_viminfo	src/cmdcmds.c	/^no_viminfo()$/;"	f	file:
no_wait_return	src/globals.h	/^EXTERN int		no_wait_return INIT(= 0);	\/* don't wait for return now *\/$/;"	v
noremap	src/gui.h	/^	int			noremap[4];			\/* A noremap flag for each mode *\/$/;"	m	struct:GuiMenu
noremapbuf	src/getchar.c	/^static char_u	*noremapbuf = NULL;       \/* flags for typeahead characters *\/$/;"	v	file:
noremapbuf_init	src/getchar.c	/^static char_u	noremapbuf_init[TYPELEN_INIT];		\/* initial noremapbuf *\/$/;"	v	file:
norm_font	src/gui.h	/^	XFontStruct	*norm_font;$/;"	m	struct:Gui
norm_pixel	src/gui.h	/^	Pixel		norm_pixel;			\/* Pixel value of normal text *\/$/;"	m	struct:Gui
normal	src/normal.c	/^normal()$/;"	f
nr_trans	src/structs.h	/^struct nr_trans$/;"	s
nt_new_bnum	src/structs.h	/^	blocknr_t	nt_new_bnum;			\/* new, positive, number *\/$/;"	m	struct:nr_trans
nt_next	src/structs.h	/^	NR_TRANS	*nt_next;			\/* next nr_trans in hash list *\/$/;"	m	struct:nr_trans
nt_old_bnum	src/structs.h	/^	blocknr_t	nt_old_bnum;			\/* old, negative, number *\/$/;"	m	struct:nr_trans
nt_prev	src/structs.h	/^	NR_TRANS	*nt_prev;			\/* previous nr_trans in hash list *\/$/;"	m	struct:nr_trans
numTags	tools/ctags/ctags.c	/^	size_t numTags;$/;"	m	struct:__anon19	file:
num_cols	src/gui.h	/^	int			num_cols;			\/* Number of columns *\/$/;"	m	struct:Gui
num_rows	src/gui.h	/^	int			num_rows;			\/* Number of rows *\/$/;"	m	struct:Gui
num_scrollbars	src/gui.h	/^	int			num_scrollbars;		\/* Number of scrollbars (= #windows + 1) *\/$/;"	m	struct:Gui
off_t	src/conf_os2.h	71;"	d
old_char	src/getchar.c	/^static int old_char = -1;		\/* ungotten character *\/$/;"	v	file:
old_highlight	src/screen.c	/^static char_u	*old_highlight = NULL;$/;"	v	file:
old_highlight_attr	src/screen.c	/^static int		old_highlight_attr = 0;$/;"	v	file:
old_indent	src/globals.h	/^EXTERN int		old_indent INIT(= 0);	\/* for ^^D command in insert mode *\/$/;"	v
old_redobuff	src/getchar.c	/^static struct buffheader old_redobuff = {{NULL, {NUL}}, NULL, 0, 0};$/;"	v	typeref:struct:buffheader	file:
old_showcmd_buf	src/normal.c	/^static char_u	old_showcmd_buf[SHOWCMD_COLS + 1];	\/* For push_showcmd() *\/$/;"	v	file:
old_sub	src/csearch.c	/^	static char_u   *old_sub = NULL;$/;"	v	file:
old_unhighlight	src/screen.c	/^static char_u	*old_unhighlight = NULL;$/;"	v	file:
oldicon	src/unix.c	/^static char_u	*oldicon = NULL;$/;"	v	file:
oldtitle	src/unix.c	/^static char_u	*oldtitle = NULL;$/;"	v	file:
one_adjust	src/mark.c	507;"	d	file:
one_adjust_nodel	src/mark.c	522;"	d	file:
oneleft	src/edit.c	/^oneleft()$/;"	f
onepage	src/edit.c	/^onepage(dir, count)$/;"	f
oneright	src/edit.c	/^oneright()$/;"	f
only_one_window	src/window.c	/^only_one_window()$/;"	f
op_block_mode	src/ops.h	/^EXTERN int		op_block_mode INIT(= FALSE);$/;"	v
op_empty	src/ops.h	/^EXTERN int		op_empty;				\/* op_start and op_end the same *\/$/;"	v
op_end_adjusted	src/ops.h	/^EXTERN int		op_end_adjusted;		\/* backuped op_end one char *\/$/;"	v
op_end_vcol	src/ops.h	/^EXTERN colnr_t	op_end_vcol;			\/* end col for block mode operator *\/$/;"	v
op_inclusive	src/ops.h	/^EXTERN int		op_inclusive;			\/* TRUE if char motion is inclusive *\/$/;"	v
op_is_VIsual	src/ops.h	/^EXTERN int		op_is_VIsual;			\/* opeartor on visual area *\/$/;"	v
op_line_count	src/ops.h	/^EXTERN long		op_line_count;			\/* number of lines from op_start to$/;"	v
op_motion_type	src/ops.h	/^EXTERN int		op_motion_type;			\/* type of the current cursor motion *\/$/;"	v
op_start_vcol	src/ops.h	/^EXTERN colnr_t	op_start_vcol;			\/* start col for block mode operator *\/$/;"	v
op_type	src/ops.h	/^EXTERN int		op_type INIT(= NOP);	\/* current pending operator type *\/$/;"	v
opchars	src/ops.h	/^EXTERN char_u *opchars INIT(= (char_u *)"dyc<>!~=Q:UuJ");$/;"	v
open_buffer	src/buffer.c	/^open_buffer()$/;"	f
opendir	src/configure	/^opendir()$/;"	f
openscript	src/getchar.c	/^openscript(name)$/;"	f
opnum	src/normal.c	/^static linenr_t	opnum = 0;$/;"	v	file:
option	src/option.c	/^struct option$/;"	s	file:
option_changed	src/option.c	/^option_changed(p)$/;"	f	file:
option_expand	src/option.c	/^option_expand(opt_idx)$/;"	f	file:
option_value2string	src/option.c	/^option_value2string(op)$/;"	f	file:
options	src/option.c	/^static struct option options[] =$/;"	v	typeref:struct:option	file:
orientation	src/gui_at_sb.h	/^    XtOrientation orientation;	\/* horizontal or vertical *\/$/;"	m	struct:__anon2
origin_end_col	src/gui.h	/^	short_u		origin_end_col;$/;"	m	struct:GuiSelection
origin_row	src/gui.h	/^	short_u		origin_row;$/;"	m	struct:GuiSelection
origin_start_col	src/gui.h	/^	short_u		origin_start_col;$/;"	m	struct:GuiSelection
original	src/edit.c	/^	int					original;$/;"	m	struct:Completion	file:
original_text	src/edit.c	/^static char_u	*original_text = NULL;$/;"	v	file:
ospeed	src/archie.c	/^short ospeed;$/;"	v
ospeed	src/term.c	/^short ospeed;$/;"	v
otherfile	src/buffer.c	/^otherfile(fname)$/;"	f
outbuf	src/term.c	/^static char_u			outbuf[BSIZE];$/;"	v	file:
outchar	src/term.c	/^outchar(c)$/;"	f
outchar_nf	src/term.c	/^outchar_nf(c)$/;"	f	file:
outline	tools/xxd/xxd.c	/^outline(fp, l, nz)$/;"	f	file:
outnum	src/term.c	/^outnum(n)$/;"	f
outstr	src/term.c	/^outstr(s)$/;"	f
outstrn	src/term.c	/^outstrn(s)$/;"	f
overstrike	src/cmdline.c	/^static int		overstrike = FALSE;	\/* typing mode *\/$/;"	v	file:
owned	src/gui.h	/^	int			owned;				\/* Flag: do we own the selection? *\/$/;"	m	struct:GuiSelection
p_aleph	src/option.h	/^EXTERN int		p_aleph;	\/* Hebrew 'Aleph' encoding *\/$/;"	v
p_aw	src/option.h	/^EXTERN int		p_aw;		\/* auto-write *\/$/;"	v
p_bdir	src/option.h	/^EXTERN char_u  *p_bdir;		\/* list of directory names for backup files *\/$/;"	v
p_bex	src/option.h	/^EXTERN char_u  *p_bex;		\/* extension for backup file *\/$/;"	v
p_biosk	src/option.h	/^EXTERN int		p_biosk;	\/* Use bioskey() instead of kbhit() *\/$/;"	v
p_bk	src/option.h	/^EXTERN int		p_bk;		\/* make backups when writing out files *\/$/;"	v
p_breakat	src/option.h	/^EXTERN char_u  *p_breakat;	\/* characters that can cause a line break *\/$/;"	v
p_bs	src/option.h	/^EXTERN long		p_bs;		\/* backspace over newlines in insert mode *\/$/;"	v
p_ch	src/option.h	/^EXTERN long		p_ch;		\/* command line height *\/$/;"	v
p_compatible_set	src/option.c	/^p_compatible_set()$/;"	f	file:
p_cp	src/option.h	/^EXTERN int		p_cp;		\/* vi-compatible *\/$/;"	v
p_cpo	src/option.h	/^EXTERN char_u  *p_cpo;		\/* vi-compatible option flags *\/$/;"	v
p_def	src/option.h	/^EXTERN char_u  *p_def;		\/* Pattern for recognising definitions *\/$/;"	v
p_dg	src/option.h	/^EXTERN int		p_dg;		\/* enable digraphs *\/$/;"	v
p_dict	src/option.h	/^EXTERN char_u  *p_dict;		\/* Dictionaries for ^P\/^N *\/$/;"	v
p_dir	src/option.h	/^EXTERN char_u  	*p_dir;		\/* list of directories for swap file *\/$/;"	v
p_ea	src/option.h	/^EXTERN int		p_ea;		\/* make windows equal height *\/$/;"	v
p_eb	src/option.h	/^EXTERN int		p_eb;		\/* ring bell for errors *\/$/;"	v
p_ed	src/option.h	/^EXTERN int		p_ed;		\/* :s is ed compatible *\/$/;"	v
p_ef	src/option.h	/^EXTERN char_u  *p_ef;		\/* name of errorfile *\/$/;"	v
p_efm	src/option.h	/^EXTERN char_u  *p_efm;		\/* error format *\/$/;"	v
p_ek	src/option.h	/^EXTERN int		p_ek;		\/* function keys with ESC in insert mode *\/$/;"	v
p_ep	src/option.h	/^EXTERN char_u  	*p_ep;		\/* program name for '=' command *\/$/;"	v
p_exrc	src/option.h	/^EXTERN int		p_exrc;		\/* read .exrc in current dir *\/$/;"	v
p_fp	src/option.h	/^EXTERN char_u  *p_fp;		\/* name of format program *\/$/;"	v
p_gd	src/option.h	/^EXTERN int		p_gd;		\/* \/g is default for :s *\/$/;"	v
p_guifont	src/option.h	/^EXTERN char_u  *p_guifont;		\/* GUI font list *\/$/;"	v
p_guioptions	src/option.h	/^EXTERN char_u  *p_guioptions;	\/* Which GUI components? *\/$/;"	v
p_guipty	src/option.h	/^EXTERN int		p_guipty;		\/* use pseudo pty for external commands *\/$/;"	v
p_hf	src/option.h	/^EXTERN char_u  *p_hf;		\/* name of help file *\/$/;"	v
p_hh	src/option.h	/^EXTERN long 	p_hh;		\/* help window height *\/$/;"	v
p_hi	src/option.h	/^EXTERN long 	p_hi;		\/* command line history size *\/$/;"	v
p_hid	src/option.h	/^EXTERN int		p_hid;		\/* buffers can be hidden *\/$/;"	v
p_hkmap	src/option.h	/^EXTERN int		p_hkmap;	\/* Hebrew keyboard map *\/$/;"	v
p_hl	src/option.h	/^EXTERN char_u  *p_hl;		\/* which highlight mode to use *\/$/;"	v
p_ic	src/option.h	/^EXTERN int		p_ic;		\/* ignore case in searches *\/$/;"	v
p_icon	src/option.h	/^EXTERN int		p_icon;		\/* put file name in icon if possible *\/$/;"	v
p_im	src/option.h	/^EXTERN int		p_im;		\/* start editing in input mode *\/$/;"	v
p_inc	src/option.h	/^EXTERN char_u  *p_inc;		\/* Pattern for including other files *\/$/;"	v
p_is	src/option.h	/^EXTERN int		p_is;		\/* incremental search *\/$/;"	v
p_isf	src/option.h	/^EXTERN char_u  *p_isf;		\/* characters in a file name *\/$/;"	v
p_isi	src/option.h	/^EXTERN char_u  *p_isi;		\/* characters in an identifier *\/$/;"	v
p_isp	src/option.h	/^EXTERN char_u  *p_isp;		\/* characters that are printable *\/$/;"	v
p_js	src/option.h	/^EXTERN int		p_js;		\/* use two spaces after '.' with Join *\/$/;"	v
p_kp	src/option.h	/^EXTERN char_u  *p_kp;		\/* keyword program *\/$/;"	v
p_langmap	src/option.h	/^EXTERN char_u  *p_langmap;	\/* mapping for some language *\/$/;"	v
p_ls	src/option.h	/^EXTERN long		p_ls;		\/* last window has status line *\/$/;"	v
p_magic	src/option.h	/^EXTERN int		p_magic;	\/* use some characters for reg exp *\/$/;"	v
p_mls	src/option.h	/^EXTERN long 	p_mls;		\/* number of mode lines *\/$/;"	v
p_mm	src/option.h	/^EXTERN long 	p_mm;		\/* maximal amount of memory for buffer *\/$/;"	v
p_mmd	src/option.h	/^EXTERN long 	p_mmd;		\/* maximal map depth *\/$/;"	v
p_mmt	src/option.h	/^EXTERN long 	p_mmt;		\/* maximal amount of memory for Vim *\/$/;"	v
p_more	src/option.h	/^EXTERN int		p_more;		\/* wait when screen full when listing *\/$/;"	v
p_mouse	src/option.h	/^EXTERN char_u  *p_mouse;	\/* enable mouse clicks (for xterm) *\/$/;"	v
p_mouset	src/option.h	/^EXTERN long		p_mouset;  	\/* mouse double click time *\/$/;"	v
p_mp	src/option.h	/^EXTERN char_u  *p_mp;		\/* program for :make command *\/$/;"	v
p_para	src/option.h	/^EXTERN char_u  *p_para;		\/* paragraphs *\/$/;"	v
p_paste	src/option.h	/^EXTERN int		p_paste;	\/* paste mode *\/$/;"	v
p_path	src/option.h	/^EXTERN char_u  *p_path;		\/* path for "]f" and "^Wf" *\/$/;"	v
p_pm	src/option.h	/^EXTERN char_u  *p_pm;  		\/* patchmode file suffix *\/$/;"	v
p_remap	src/option.h	/^EXTERN int		p_remap;	\/* remap *\/$/;"	v
p_report	src/option.h	/^EXTERN long		p_report;	\/* minimum number of lines for report *\/$/;"	v
p_ri	src/option.h	/^EXTERN int		p_ri;		\/* reverse direction of insert *\/$/;"	v
p_rs	src/option.h	/^EXTERN int		p_rs;		\/* restore startup screen upon exit *\/$/;"	v
p_ru	src/option.h	/^EXTERN int		p_ru;		\/* show column\/line number *\/$/;"	v
p_sb	src/option.h	/^EXTERN int		p_sb;		\/* split window backwards *\/$/;"	v
p_sbr	src/option.h	/^EXTERN char_u  *p_sbr;		\/* string for break of line *\/$/;"	v
p_sc	src/option.h	/^EXTERN int		p_sc;		\/* show command in status line *\/$/;"	v
p_scs	src/option.h	/^EXTERN int		p_scs;		\/* 'smartcase' *\/$/;"	v
p_sections	src/option.h	/^EXTERN char_u  *p_sections;	\/* sections *\/$/;"	v
p_secure	src/option.h	/^EXTERN int		p_secure;	\/* do .exrc and .vimrc in secure mode *\/$/;"	v
p_sh	src/option.h	/^EXTERN char_u  *p_sh;		\/* name of shell to use *\/$/;"	v
p_shm	src/option.h	/^EXTERN char_u  *p_shm;		\/* When to use short message *\/$/;"	v
p_sj	src/option.h	/^EXTERN long		p_sj;		\/* scroll jump size *\/$/;"	v
p_sm	src/option.h	/^EXTERN int		p_sm;		\/* showmatch *\/$/;"	v
p_smd	src/option.h	/^EXTERN int		p_smd;		\/* show mode *\/$/;"	v
p_so	src/option.h	/^EXTERN long		p_so;		\/* scroll offset *\/$/;"	v
p_sol	src/option.h	/^EXTERN int		p_sol;		\/* Move cursor to start-of-line? *\/$/;"	v
p_sp	src/option.h	/^EXTERN char_u  *p_sp;		\/* string for output of make *\/$/;"	v
p_sr	src/option.h	/^EXTERN int		p_sr;		\/* shift round off (for < and >) *\/$/;"	v
p_srr	src/option.h	/^EXTERN char_u  *p_srr;		\/* string for output of filter *\/$/;"	v
p_ss	src/option.h	/^EXTERN long		p_ss;		\/* sideways scrolling offset *\/$/;"	v
p_st	src/option.h	/^EXTERN long		p_st;		\/* type of shell *\/$/;"	v
p_sta	src/option.h	/^EXTERN int		p_sta;		\/* smart-tab for expand-tab *\/$/;"	v
p_su	src/option.h	/^EXTERN char_u  *p_su;		\/* suffixes for wildcard expansion *\/$/;"	v
p_sws	src/option.h	/^EXTERN char_u  *p_sws;		\/* swap file syncing *\/$/;"	v
p_ta	src/option.h	/^EXTERN int		p_ta;		\/* auto textmode detection *\/$/;"	v
p_tags	src/option.h	/^EXTERN char_u  *p_tags;		\/* tags search path *\/$/;"	v
p_tbi	src/option.h	/^EXTERN int		p_tbi;		\/* 'ttybuiltin' use builtin termcap first *\/$/;"	v
p_terse	src/option.h	/^EXTERN int		p_terse;	\/* terse messages *\/$/;"	v
p_tf	src/option.h	/^EXTERN int		p_tf;		\/* terminal fast I\/O *\/$/;"	v
p_timeout	src/option.h	/^EXTERN int		p_timeout;	\/* mappings entered within one second *\/$/;"	v
p_title	src/option.h	/^EXTERN int		p_title;	\/* set window title if possible *\/$/;"	v
p_tl	src/option.h	/^EXTERN long 	p_tl;		\/* used tag length *\/$/;"	v
p_tm	src/option.h	/^EXTERN long 	p_tm;		\/* timeoutlen (msec) *\/$/;"	v
p_to	src/option.h	/^EXTERN int		p_to;		\/* tilde is an operator *\/$/;"	v
p_tr	src/option.h	/^EXTERN int		p_tr;		\/* tag file name is relative *\/$/;"	v
p_ttimeout	src/option.h	/^EXTERN int		p_ttimeout;	\/* key codes entered within one second *\/$/;"	v
p_ttm	src/option.h	/^EXTERN long 	p_ttm;		\/* key code timeoutlen (msec) *\/$/;"	v
p_ttyscroll	src/option.h	/^EXTERN long		p_ttyscroll; \/* maximum number of screen lines for a scroll *\/$/;"	v
p_uc	src/option.h	/^EXTERN long 	p_uc;		\/* update count for swap file *\/$/;"	v
p_ul	src/option.h	/^EXTERN long 	p_ul;		\/* number of Undo Levels *\/$/;"	v
p_ut	src/option.h	/^EXTERN long 	p_ut;		\/* update time for swap file *\/$/;"	v
p_vb	src/option.h	/^EXTERN int		p_vb;		\/* visual bell only (no beep) *\/$/;"	v
p_viminfo	src/option.h	/^EXTERN char_u  *p_viminfo;	\/* Parameters for using ~\/.viminfo file *\/$/;"	v
p_wa	src/option.h	/^EXTERN int		p_wa;		\/* write any *\/$/;"	v
p_warn	src/option.h	/^EXTERN int		p_warn;		\/* warn for changes at shell command *\/$/;"	v
p_wb	src/option.h	/^EXTERN int		p_wb;		\/* write backup files *\/$/;"	v
p_wc	src/option.h	/^EXTERN long		p_wc;		\/* character for wildcard exapansion *\/$/;"	v
p_wd	src/option.h	/^EXTERN long		p_wd;		\/* write delay for screen output (for testing) *\/$/;"	v
p_wh	src/option.h	/^EXTERN long		p_wh;		\/* desired window height *\/$/;"	v
p_wiv	src/option.h	/^EXTERN int		p_wiv;		\/* inversion of text is weird *\/$/;"	v
p_ws	src/option.h	/^EXTERN int		p_ws;		\/* wrap scan *\/$/;"	v
p_ww	src/option.h	/^EXTERN char_u  *p_ww;		\/* which keys wrap to next\/prev line *\/$/;"	v
parseEnvironmentOptions	tools/ctags/ctags.c	/^static void parseEnvironmentOptions()$/;"	f	file:
parseOptions	tools/ctags/ctags.c	/^static int parseOptions( argList )$/;"	f	file:
parse_builtin_tcap	src/term.c	/^parse_builtin_tcap(term)$/;"	f	file:
parse_tag_line	src/tag.c	/^parse_tag_line(lbuf,$/;"	f	file:
paste_option_changed	src/option.c	/^paste_option_changed()$/;"	f	file:
pat	src/option.c	/^	char_u			*pat;					\/* pattern as typed *\/$/;"	m	struct:AutoPat	file:
pathChosen	tools/ctags/ctags.c	/^			boolean pathChosen;$/;"	m	struct:__anon22::__anon23::__anon24	file:
pb_count	src/memline.c	/^	short_u		pb_count;		\/* number of pointer in this block *\/$/;"	m	struct:pointer_block	file:
pb_count_max	src/memline.c	/^	short_u		pb_count_max;	\/* maximum value for pb_count *\/$/;"	m	struct:pointer_block	file:
pb_id	src/memline.c	/^	short_u		pb_id;			\/* ID for pointer block: PTR_ID *\/$/;"	m	struct:pointer_block	file:
pb_pointer	src/memline.c	/^	PTR_EN		pb_pointer[1];	\/* list of pointers to blocks (actually longer)$/;"	m	struct:pointer_block	file:
pchar	src/macros.h	16;"	d
pchar_cursor	src/misccmds.c	/^pchar_cursor(c)$/;"	f
pe_bnum	src/memline.c	/^	blocknr_t	pe_bnum;		\/* block number *\/$/;"	m	struct:pointer_entry	file:
pe_line_count	src/memline.c	/^	linenr_t	pe_line_count;	\/* number of lines in this branch *\/$/;"	m	struct:pointer_entry	file:
pe_old_lnum	src/memline.c	/^	linenr_t	pe_old_lnum;	\/* lnum for this block (for recovery) *\/$/;"	m	struct:pointer_entry	file:
pe_page_count	src/memline.c	/^	int			pe_page_count;	\/* number of pages in block pe_bnum *\/$/;"	m	struct:pointer_entry	file:
peekchr	src/regexp.c	/^peekchr()$/;"	f	file:
pid_t	src/conf_os2.h	74;"	d
plines	src/misccmds.c	/^plines(p)$/;"	f
plines_m	src/misccmds.c	/^plines_m(first, last)$/;"	f
plines_m_win	src/misccmds.c	/^plines_m_win(wp, first, last)$/;"	f
plines_win	src/misccmds.c	/^plines_win(wp, p)$/;"	f
plural	src/misccmds.c	/^plural(n)$/;"	f
pname	tools/ctags/ctags.c	/^	char	pname[MAXNAME];			\/* the name of the last NAME token in () *\/$/;"	m	struct:__anon16	file:
pointer_block	src/memline.c	/^struct pointer_block$/;"	s	file:
pointer_entry	src/memline.c	/^struct pointer_entry$/;"	s	file:
popCppIgnore	tools/ctags/ctags.c	/^static boolean popCppIgnore()$/;"	f	file:
pop_showcmd	src/normal.c	/^pop_showcmd()$/;"	f
postponed_split	src/globals.h	/^EXTERN int		postponed_split INIT(= FALSE);	\/* for CTRL-W CTRL-] command *\/$/;"	v
prechar	src/normal.c	/^static int		prechar = NUL;	\/* prepended command char *\/$/;"	v	file:
prefix	src/config.mk	/^prefix = \/usr\/local$/;"	m
prefix	tools/ctags/ctags.c	/^		boolean	prefix;		\/* -iP  prefix static tags with filename *\/$/;"	m	struct:__anon17::__anon18	file:
prep_redo	src/normal.c	/^prep_redo(num, pre_char, cmd, c, nchar)$/;"	f	file:
prepare_viminfo_history	src/cmdline.c	/^prepare_viminfo_history(len)$/;"	f
preserve_exit	src/misccmds.c	/^preserve_exit()$/;"	f
prev	src/edit.c	/^	struct Completion	*prev;$/;"	m	struct:Completion	typeref:struct:Completion::Completion	file:
prev	src/gui.h	/^	FPOS		prev;				\/* Previous position *\/$/;"	m	struct:GuiSelection
prev	tools/ctags/ctags.c	/^	char	prev[MAXNAME];			\/* the name of the prev NAME token *\/$/;"	m	struct:__anon16	file:
prev	tools/ctags/ctags.c	/^	token_t	prev;			\/* the previous token *\/$/;"	m	struct:__anon15	file:
prevCppIgnore	tools/ctags/ctags.c	/^static boolean prevCppIgnore()$/;"	f	file:
prev_wrap	src/gui.h	/^	int			prev_wrap;			\/* For updating the horizontal scrollbar *\/$/;"	m	struct:Gui
prevchr	src/regexp.c	/^static int		prevchr;$/;"	v	file:
prevwin	src/window.c	/^static WIN		*prevwin = NULL;		\/* previous window *\/$/;"	v	file:
printUsage	tools/ctags/ctags.c	/^static void printUsage( error )$/;"	f	file:
print_line	src/cmdcmds.c	/^print_line(lnum, use_number)$/;"	f
printdigraph	src/digraph.c	/^printdigraph(p)$/;"	f	file:
program	src/regexp.h	/^	char_u			program[1]; \/* Unwarranted chumminess with compiler. *\/$/;"	m	struct:regexp
prototypes	tools/ctags/ctags.c	/^		boolean	prototypes;	\/* -ip  include tags for external func. prototypes*\/$/;"	m	struct:__anon17::__anon18	file:
pseudo_code	src/tables.c	/^	int		pseudo_code;		\/* Code for pseudo mouse event *\/$/;"	m	struct:__anon5	file:
pstrcmp	src/msdos.c	/^pstrcmp(a, b)$/;"	f	file:
ptag	tools/ctags/ctags.c	/^	tag_info ptag;			\/* information regarding previous tag candidate *\/$/;"	m	struct:__anon15	file:
pushCppIgnore	tools/ctags/ctags.c	/^static boolean pushCppIgnore( ignore, pathChosen )$/;"	f	file:
push_showcmd	src/normal.c	/^push_showcmd()$/;"	f
put_on_cmdline	src/cmdline.c	/^put_on_cmdline(str, len, redraw)$/;"	f
putcmdline	src/cmdline.c	/^putcmdline(c)$/;"	f	file:
putdigraph	src/digraph.c	/^putdigraph(str)$/;"	f
putenv	src/pty.c	/^putenv(string)$/;"	f
putescstr	src/getchar.c	/^putescstr(fd, str, set)$/;"	f
qf_cleared	src/quickfix.c	/^	char_u			 qf_cleared;\/* set to TRUE if line has been deleted *\/$/;"	m	struct:qf_line	file:
qf_col	src/quickfix.c	/^	int				 qf_col;	\/* column where the error occurred *\/$/;"	m	struct:qf_line	file:
qf_count	src/quickfix.c	/^static int	qf_count = 0;		\/* number of errors (0 means no error list) *\/$/;"	v	file:
qf_fnum	src/quickfix.c	/^	int				 qf_fnum;	\/* file number for the line *\/$/;"	m	struct:qf_line	file:
qf_free	src/quickfix.c	/^qf_free()$/;"	f	file:
qf_index	src/quickfix.c	/^static int	qf_index;			\/* current index in the error list *\/$/;"	v	file:
qf_init	src/quickfix.c	/^qf_init()$/;"	f
qf_jump	src/quickfix.c	/^qf_jump(dir, errornr)$/;"	f
qf_line	src/quickfix.c	/^struct qf_line$/;"	s	file:
qf_list	src/quickfix.c	/^qf_list(all)$/;"	f
qf_lnum	src/quickfix.c	/^	linenr_t		 qf_lnum;	\/* line number where the error occurred *\/$/;"	m	struct:qf_line	file:
qf_mark_adjust	src/quickfix.c	/^qf_mark_adjust(line1, line2, amount, amount_after)$/;"	f
qf_next	src/quickfix.c	/^	struct qf_line	*qf_next;	\/* pointer to next error in the list *\/$/;"	m	struct:qf_line	typeref:struct:qf_line::qf_line	file:
qf_nonevalid	src/quickfix.c	/^static int	qf_nonevalid;		\/* set to TRUE if not a single valid entry found *\/$/;"	v	file:
qf_nr	src/quickfix.c	/^	int				 qf_nr;		\/* error number *\/$/;"	m	struct:qf_line	file:
qf_prev	src/quickfix.c	/^	struct qf_line	*qf_prev;	\/* pointer to previous error in the list *\/$/;"	m	struct:qf_line	typeref:struct:qf_line::qf_line	file:
qf_ptr	src/quickfix.c	/^static struct qf_line *qf_ptr;			\/* pointer to the current error *\/$/;"	v	typeref:struct:qf_line	file:
qf_start	src/quickfix.c	/^static struct qf_line *qf_start;		\/* pointer to the first error *\/$/;"	v	typeref:struct:qf_line	file:
qf_text	src/quickfix.c	/^	char_u			*qf_text;	\/* description of the error *\/$/;"	m	struct:qf_line	file:
qf_type	src/quickfix.c	/^	char_u			 qf_type;	\/* type of the error (mostly 'E') *\/$/;"	m	struct:qf_line	file:
qf_types	src/quickfix.c	/^qf_types(c, nr)$/;"	f	file:
qf_valid	src/quickfix.c	/^	char_u			 qf_valid;	\/* valid error message detected *\/$/;"	m	struct:qf_line	file:
quit_more	src/globals.h	/^EXTERN int		quit_more INIT(= FALSE);	\/* 'q' hit at "--more--" msg *\/$/;"	v
quitmore	src/cmdline.c	/^static int			quitmore = 0;$/;"	v	file:
rc_did_emsg	src/globals.h	/^EXTERN int		rc_did_emsg INIT(= FALSE);	\/* vim_regcomp() called emsg() *\/$/;"	v
readExtensionList	tools/ctags/ctags.c	/^static void readExtensionList( list )$/;"	f	file:
readIdendifier	tools/ctags/ctags.c	/^static void readIdendifier( firstChar, name )$/;"	f	file:
readOptionArg	tools/ctags/ctags.c	/^static char *readOptionArg(option, arg, argList, argNum)$/;"	f	file:
read_redo	src/getchar.c	/^read_redo(init, old_redo)$/;"	f	file:
read_stuff	src/getchar.c	/^read_stuff(advance)$/;"	f	file:
read_viminfo	src/cmdcmds.c	/^read_viminfo(file, want_info, want_marks, force)$/;"	f
read_viminfo_filemark	src/mark.c	/^read_viminfo_filemark(line, fp, force)$/;"	f
read_viminfo_history	src/cmdline.c	/^read_viminfo_history(line, fp)$/;"	f
read_viminfo_register	src/ops.c	/^read_viminfo_register(line, fp, force)$/;"	f
read_viminfo_search_pattern	src/search.c	/^read_viminfo_search_pattern(line, fp, force)$/;"	f
read_viminfo_sub_string	src/csearch.c	/^read_viminfo_sub_string(line, fp, force)$/;"	f
read_viminfo_up_to_marks	src/cmdcmds.c	/^read_viminfo_up_to_marks(line, fp, force)$/;"	f	file:
readfile	src/fileio.c	/^readfile(fname, sfname, from, newfile, lines_to_skip, lines_to_read, filtering)$/;"	f
readonlymode	src/globals.h	/^EXTERN int		readonlymode INIT(= FALSE); \/* Set to TRUE for "view" *\/$/;"	v
realloc_cmdbuff	src/cmdline.c	/^realloc_cmdbuff(len)$/;"	f
recordbuff	src/getchar.c	/^static struct buffheader recordbuff = {{NULL, {NUL}}, NULL, 0, 0};$/;"	v	typeref:struct:buffheader	file:
recover_names	src/memline.c	/^recover_names(fname, list, nr)$/;"	f
recover_old_highlight	src/screen.c	/^recover_old_highlight()$/;"	f
recoverymode	src/globals.h	/^EXTERN int		recoverymode INIT(= FALSE); \/* Set to TRUE for "-r" option *\/$/;"	v
redo_VIsual_busy	src/globals.h	/^EXTERN int		redo_VIsual_busy INIT(= FALSE);$/;"	v
redobuff	src/getchar.c	/^static struct buffheader redobuff = {{NULL, {NUL}}, NULL, 0, 0};$/;"	v	typeref:struct:buffheader	file:
redraw_cmdline	src/globals.h	/^EXTERN int		redraw_cmdline INIT(= FALSE);	\/* cmdline must be redrawn *\/$/;"	v
redraw_later	src/screen.c	/^redraw_later(type)$/;"	f
redrawcmd	src/cmdline.c	/^redrawcmd()$/;"	f	file:
redrawcmdline	src/cmdline.c	/^redrawcmdline()$/;"	f
reg	src/regexp.c	/^reg(paren, flagp)$/;"	f	file:
reg_ic	src/globals.h	/^EXTERN int 		reg_ic INIT(= 0); 			\/* p_ic passed to vim_regexec() *\/$/;"	v
reg_magic	src/globals.h	/^EXTERN int		reg_magic;					\/* p_magic passed to ergexec() *\/$/;"	v
reg_pat	src/option.c	/^	char_u			*reg_pat;				\/* pattern converted to regexp *\/$/;"	m	struct:AutoPat	file:
reg_prev_re	src/regexp.c	/^char_u		   *reg_prev_re;$/;"	v
reg_prev_sub	src/regexp.c	/^char_u		   *reg_prev_sub;$/;"	v
reganch	src/regexp.h	/^	char_u			reganch;	\/* Internal use only. *\/$/;"	m	struct:regexp
regatom	src/regexp.c	/^regatom(flagp)$/;"	f	file:
regbol	src/regexp.c	/^static char_u    *regbol; 		\/* Beginning of input, for ^ check. *\/$/;"	v	file:
regbranch	src/regexp.c	/^regbranch(flagp)$/;"	f	file:
regc	src/regexp.c	/^regc(b)$/;"	f	file:
regcode	src/regexp.c	/^static char_u   *regcode;		\/* Code-emit pointer; &regdummy = don't. *\/$/;"	v	file:
regdummy	src/regexp.c	/^static char_u 	regdummy;$/;"	v	file:
regdump	src/regexp.c	/^regdump(r)$/;"	f
regendp	src/regexp.c	/^static char_u   **regendp;		\/* Ditto for endp. *\/$/;"	v	file:
regexp	src/regexp.h	/^typedef struct regexp$/;"	s
regexp	src/regexp.h	/^} regexp;$/;"	t	typeref:struct:regexp
reginput	src/regexp.c	/^static char_u    *reginput;		\/* String-input pointer. *\/$/;"	v	file:
reginsert	src/regexp.c	/^reginsert(op, opnd)$/;"	f	file:
regmatch	src/regexp.c	/^regmatch(prog)$/;"	f	file:
regmlen	src/regexp.h	/^	int 			regmlen;	\/* Internal use only. *\/$/;"	m	struct:regexp
regmust	src/regexp.h	/^	char_u		   *regmust;	\/* Internal use only. *\/$/;"	m	struct:regexp
regname	src/cmdline.c	/^static int			regname;$/;"	v	file:
regnarrate	src/regexp.c	/^int 			regnarrate = 1;$/;"	v
regnext	src/regexp.c	/^regnext(p)$/;"	f	file:
regnode	src/regexp.c	/^regnode(op)$/;"	f	file:
regnpar	src/regexp.c	/^static int		regnpar;		\/* () count. *\/$/;"	v	file:
regoptail	src/regexp.c	/^regoptail(p, val)$/;"	f	file:
regparse	src/regexp.c	/^static char_u    *regparse;	\/* Input-scan pointer. *\/$/;"	v	file:
regpiece	src/regexp.c	/^regpiece(flagp)$/;"	f	file:
regprop	src/regexp.c	/^regprop(op)$/;"	f	file:
regrepeat	src/regexp.c	/^regrepeat(p)$/;"	f	file:
regsize	src/regexp.c	/^static long 	regsize;		\/* Code size. *\/$/;"	v	file:
regstart	src/regexp.h	/^	char_u			regstart;	\/* Internal use only. *\/$/;"	m	struct:regexp
regstartp	src/regexp.c	/^static char_u   **regstartp;		\/* Pointer to startp array. *\/$/;"	v	file:
regtail	src/regexp.c	/^regtail(p, val)$/;"	f	file:
regtilde	src/regsub.c	/^regtilde(source, magic)$/;"	f
regtry	src/regexp.c	/^regtry(prog, string)$/;"	f	file:
remember_highlight	src/screen.c	/^remember_highlight()$/;"	f
removable	src/mark.c	/^removable(name)$/;"	f	file:
rename	src/msdos.c	1397;"	d	file:
rename	src/msdos.h	132;"	d
rename	src/unix.c	/^rename(src, dest)$/;"	f
replace_flush	src/edit.c	/^replace_flush()$/;"	f
replace_offset	src/globals.h	/^EXTERN int		replace_offset INIT(= 0);	\/* offset for replace_push() *\/$/;"	v
replace_pop	src/edit.c	/^replace_pop()$/;"	f
replace_push	src/edit.c	/^replace_push(c)$/;"	f
replace_stack	src/edit.c	/^char_u	*replace_stack = NULL;$/;"	v
replace_stack_len	src/edit.c	/^long	replace_stack_len = 0;		\/* max. number of entries *\/$/;"	v
replace_stack_nr	src/edit.c	/^long	replace_stack_nr = 0;		\/* next entry in replace stack *\/$/;"	v
replace_termcodes	src/term.c	/^replace_termcodes(from, bufp, from_part)$/;"	f
resel_VIsual_col	src/normal.c	/^static colnr_t	resel_VIsual_col;			\/* number of cols or end column *\/$/;"	v	file:
resel_VIsual_line_count	src/normal.c	/^static linenr_t	resel_VIsual_line_count;		\/* number of lines *\/$/;"	v	file:
resel_VIsual_mode	src/normal.c	/^static int		resel_VIsual_mode = NUL;	\/* 'v', 'V', or Ctrl-V *\/$/;"	v	file:
reset_VIsual	src/window.c	/^reset_VIsual()$/;"	f	file:
reset_signals	src/unix.c	/^reset_signals()$/;"	f
resettitle	src/buffer.c	/^resettitle()$/;"	f
resolve	tools/ctags/ctags.c	/^		boolean		resolve;	\/* must resolve if\/else\/elif\/endif branch *\/$/;"	m	struct:__anon22::__anon23	file:
restart_edit	src/globals.h	/^EXTERN int		restart_edit INIT(= 0);	\/* call edit when next command finished$/;"	v
rev_video	src/gui.h	/^	Bool		rev_video;			\/* Use reverse video? *\/$/;"	m	struct:Gui
rightleft	src/screen.c	/^static int		rightleft = 0;	\/* set to 1 for right to left in screen_fill *\/$/;"	v	file:
rmtmp	tools/mvi/mvi.c	/^static int rmtmp= 0;        \/* If tmp needs to be deleted *\/$/;"	v	file:
root_menu	src/gui.h	/^	GuiMenu		*root_menu;			\/* Root of menu hierarchy *\/$/;"	m	struct:Gui
row	src/gui.h	/^	int			row;				\/* Current cursor row in GUI display *\/$/;"	m	struct:Gui
ru_col	src/globals.h	/^EXTERN int		ru_col;			\/* column for ruler *\/$/;"	v
same_leader	src/ops.c	/^same_leader(leader1_len, leader1_flags, leader2_len, leader2_flags)$/;"	f	file:
sc_col	src/globals.h	/^EXTERN int		sc_col;			\/* column for shown command *\/$/;"	v
scope	tools/ctags/ctags.c	/^	scope_t	scope;$/;"	m	struct:__anon15	file:
scope_t	tools/ctags/ctags.c	/^} scope_t;$/;"	t	typeref:enum:__anon11	file:
screen_Columns	src/globals.h	/^EXTERN int		screen_Columns INIT(= 0);	\/* actual size of NextScreen *\/$/;"	v
screen_Rows	src/globals.h	/^EXTERN int		screen_Rows INIT(= 0);		\/* actual size of NextScreen *\/$/;"	v
screen_char	src/screen.c	/^screen_char(p, row, col)$/;"	f	file:
screen_cleared	src/globals.h	/^EXTERN int		screen_cleared INIT(= FALSE);	\/* screen has been cleared *\/$/;"	v
screen_cur_col	src/globals.h	/^EXTERN int	screen_cur_row, screen_cur_col;		\/* last known cursor position *\/$/;"	v
screen_cur_row	src/globals.h	/^EXTERN int	screen_cur_row, screen_cur_col;		\/* last known cursor position *\/$/;"	v
screen_del_lines	src/screen.c	/^screen_del_lines(off, row, line_count, end)$/;"	f
screen_fill	src/screen.c	/^screen_fill(start_row, end_row, start_col, end_col, c1, c2)$/;"	f
screen_ins_lines	src/screen.c	/^screen_ins_lines(off, row, line_count, end)$/;"	f	file:
screen_msg	src/screen.c	/^screen_msg(text, row, col)$/;"	f
screen_new_rows	src/window.c	/^screen_new_rows()$/;"	f
screen_outchar	src/screen.c	/^screen_outchar(c, row, col)$/;"	f
screen_start	src/screen.c	/^screen_start()$/;"	f
screen_valid	src/screen.c	/^screen_valid(clear)$/;"	f
screenalloc	src/screen.c	/^screenalloc(clear)$/;"	f
screenclear	src/screen.c	/^screenclear()$/;"	f
screenclear2	src/screen.c	/^screenclear2()$/;"	f	file:
screengo	src/edit.c	/^screengo(dir, dist)$/;"	f
scriptin	src/globals.h	/^EXTERN FILE 	*scriptin[NSCRIPT];			\/* streams to read script from *\/$/;"	v
scriptout	src/globals.h	/^EXTERN FILE 	*scriptout	INIT(= NULL); 	\/* stream to write script to *\/$/;"	v
scrollProc	src/gui_at_sb.h	/^    XtCallbackList scrollProc;	\/* proportional scroll *\/$/;"	m	struct:__anon2
scroll_bg_pixel	src/gui.h	/^	Pixel		scroll_bg_pixel;	\/* Pixel value of scrollbar background *\/$/;"	m	struct:Gui
scroll_cursor_bot	src/screen.c	/^scroll_cursor_bot(min_scroll, set_topline)$/;"	f
scroll_cursor_halfway	src/screen.c	/^scroll_cursor_halfway(atend)$/;"	f
scroll_cursor_top	src/screen.c	/^scroll_cursor_top(min_scroll, always)$/;"	f
scroll_fg_pixel	src/gui.h	/^	Pixel		scroll_fg_pixel;	\/* Pixel value of scrollbar foreground *\/$/;"	m	struct:Gui
scroll_mode	src/gui_at_sb.h	/^    char	  scroll_mode;	\/* see below *\/$/;"	m	struct:__anon2
scroll_off	src/gui_at_sb.h	/^    float	  scroll_off;	\/* offset from event to top of thumb *\/$/;"	m	struct:__anon2
scroll_region	src/globals.h	/^EXTERN int		scroll_region INIT(= FALSE);\/* terminal supports scroll region *\/$/;"	v
scroll_region_bot	src/gui.h	/^	int			scroll_region_bot;	\/* Bottom (last) line of scroll region *\/$/;"	m	struct:Gui
scroll_region_reset	src/term.c	/^scroll_region_reset()$/;"	f
scroll_region_set	src/term.c	/^scroll_region_set(wp, off)$/;"	f
scroll_region_top	src/gui.h	/^	int			scroll_region_top;	\/* Top (first) line of scroll region *\/$/;"	m	struct:Gui
scroll_start	src/term.c	/^scroll_start()$/;"	f
scrollbar	src/gui_at_sb.h	/^    ScrollbarPart	scrollbar;$/;"	m	struct:_ScrollbarRec
scrollbar_class	src/gui_at_sb.h	/^    ScrollbarClassPart		scrollbar_class;$/;"	m	struct:_ScrollbarClassRec
scrollbar_value	src/globals.h	/^EXTERN long_u	scrollbar_value;$/;"	v
scrollbar_width	src/gui.h	/^	int			scrollbar_width;	\/* Width of scrollbars *\/$/;"	m	struct:Gui
scrolldown	src/screen.c	/^scrolldown(line_count)$/;"	f
scrolldown_clamp	src/screen.c	/^scrolldown_clamp()$/;"	f
scrollup	src/screen.c	/^scrollup(line_count)$/;"	f
scrollup_clamp	src/screen.c	/^scrollup_clamp()$/;"	f
search_for_exact_line	src/search.c	/^search_for_exact_line(pos, dir, pat)$/;"	f
search_magic	src/search.c	/^static int		search_magic = TRUE;$/;"	v	file:
search_match_len	src/globals.h	/^EXTERN int		search_match_len;			\/* length of matched string *\/$/;"	v
search_no_scs	src/search.c	/^static int		search_no_scs = FALSE;$/;"	v	file:
search_pattern	src/search.c	/^static char_u	*search_pattern = NULL;$/;"	v	file:
searchc	src/search.c	/^searchc(c, dir, type, count)$/;"	f
searchcmdlen	src/globals.h	/^EXTERN int		searchcmdlen;				\/* length of previous search cmd *\/$/;"	v
searchit	src/search.c	/^searchit(pos, dir, str, count, options, which_pat)$/;"	f
secure	src/globals.h	/^EXTERN int		secure INIT(= FALSE);$/;"	v
seek	tools/ctags/ctags.c	/^	long	seek;			\/* fseek() offset to the start of current line *\/$/;"	m	struct:__anon21	file:
select	src/unix.c	23;"	d	file:
select	src/unix.c	39;"	d	file:
selection	src/gui.h	/^	GuiSelection selection;			\/* Info about selected text *\/$/;"	m	struct:Gui
setCppIgnore	tools/ctags/ctags.c	/^static boolean setCppIgnore( ignore )$/;"	f	file:
set_Changed	src/misccmds.c	/^set_Changed()$/;"	f
set_b0_fname	src/memline.c	/^set_b0_fname(b0p, buf)$/;"	f	file:
set_context_in_autocmd	src/option.c	/^set_context_in_autocmd(arg, doautocmd)$/;"	f
set_context_in_set_cmd	src/option.c	/^set_context_in_set_cmd(arg)$/;"	f
set_expand_context	src/cmdline.c	/^set_expand_context(firstc, buff)$/;"	f	file:
set_highlight	src/screen.c	/^set_highlight(context)$/;"	f
set_indent	src/misccmds.c	/^set_indent(size, del_first)$/;"	f
set_init_1	src/option.c	/^set_init_1()$/;"	f
set_init_2	src/option.c	/^set_init_2()$/;"	f
set_init_3	src/option.c	/^set_init_3()$/;"	f
set_last_cursor	src/mark.c	/^set_last_cursor(win)$/;"	f
set_last_insert	src/edit.c	/^set_last_insert(c)$/;"	f
set_one_cmd_context	src/cmdline.c	/^set_one_cmd_context(firstc, buff)$/;"	f	file:
set_option_default	src/option.c	/^set_option_default(opt_idx, dofree)$/;"	f	file:
set_options_bin	src/option.c	/^set_options_bin(oldval, newval)$/;"	f
set_redo_ins	src/getchar.c	/^set_redo_ins()$/;"	f
set_reg_ic	src/search.c	/^set_reg_ic(pat)$/;"	f
set_string_option	src/option.c	/^set_string_option(name, opt_idx, val, dofree)$/;"	f
set_term_defaults	src/option.c	/^set_term_defaults()$/;"	f
set_termname	src/term.c	/^set_termname(term)$/;"	f
set_window	src/msdos.c	/^set_window()$/;"	f
set_winsize	src/term.c	/^set_winsize(width, height, mustset)$/;"	f
set_x11_icon	src/unix.c	/^set_x11_icon(icon)$/;"	f	file:
set_x11_title	src/unix.c	/^set_x11_title(title)$/;"	f	file:
setaltfname	src/buffer.c	/^setaltfname(fname, sfname, lnum)$/;"	f
setcursor	src/term.c	/^setcursor()$/;"	f
setfname	src/buffer.c	/^setfname(fname, sfname, message)$/;"	f
setmark	src/mark.c	/^setmark(c)$/;"	f
setmouse	src/term.c	/^setmouse()$/;"	f
setpcmark	src/mark.c	/^setpcmark()$/;"	f
setperm	src/archie.c	/^setperm(name, perm)$/;"	f
setperm	src/msdos.c	/^setperm(name, perm)$/;"	f
setperm	src/unix.c	/^setperm(name, perm)$/;"	f
settmode	src/term.c	/^settmode(raw)$/;"	f
shadow_width	src/gui_at_sb.h	/^    Dimension	shadow_width;$/;"	m	struct:__anon2
shift_line	src/ops.c	/^shift_line(left, round, amount)$/;"	f
shifted_keys_table	src/tables.c	/^static char_u shifted_keys_table[] =$/;"	v	file:
short_u	src/structs.h	/^typedef unsigned short	short_u;$/;"	t
short_u	src/vim.h	/^typedef unsigned short	short_u;$/;"	t
shortmess	src/option.c	/^shortmess(x)$/;"	f
shortname	src/option.c	/^	char		*shortname; 	\/* permissible abbreviation *\/$/;"	m	struct:option	file:
show_autocmd	src/option.c	/^show_autocmd(ap, event)$/;"	f	file:
show_mouse	src/msdos.c	/^show_mouse(on)$/;"	f	file:
show_one_mark	src/mark.c	/^show_one_mark(c, arg, p, name)$/;"	f	file:
show_one_termcode	src/term.c	/^show_one_termcode(name, code, printit)$/;"	f
show_pat_in_path	src/search.c	/^show_pat_in_path(line, type, did_show, action, fp, lnum, count)$/;"	f	file:
show_shell_mess	src/unix.c	/^static int		show_shell_mess = TRUE;$/;"	v	file:
show_termcodes	src/term.c	/^show_termcodes()$/;"	f
showcmd_buf	src/normal.c	/^static char_u	showcmd_buf[SHOWCMD_COLS + 1];$/;"	v	file:
showmap	src/getchar.c	/^showmap(mp)$/;"	f	file:
showmatch	src/search.c	/^showmatch()$/;"	f
showmatches	src/cmdline.c	/^showmatches(buff)$/;"	f	file:
showmode	src/screen.c	/^showmode()$/;"	f
shown	src/gui_at_sb.h	/^    float	  shown;	\/* What percent is shown in the win *\/$/;"	m	struct:__anon2
shownLength	src/gui_at_sb.h	/^    Dimension	  shownLength;	\/* Num pixels corresponding to shown *\/$/;"	m	struct:__anon2
showoneopt	src/option.c	/^showoneopt(p)$/;"	f	file:
showoptions	src/option.c	/^showoptions(all)$/;"	f	file:
showruler	src/screen.c	/^showruler(always)$/;"	f
sig	src/unix.c	/^	int		sig;		\/* Signal number, eg. SIGSEGV etc *\/$/;"	m	struct:__anon6	file:
signal	src/unixunix.h	17;"	d
signal_info	src/unix.c	/^} signal_info[] =$/;"	v	typeref:struct:__anon6	file:
simple	src/gui_at_sb.h	/^    SimplePart		simple;$/;"	m	struct:_ScrollbarRec
simple_class	src/gui_at_sb.h	/^    SimpleClassPart		simple_class;$/;"	m	struct:_ScrollbarClassRec
size	src/gui.h	/^	int			size;				\/* Size of scrollbar thumb *\/$/;"	m	struct:GuiScrollbar
size_t	src/conf_os2.h	77;"	d
skipInitializer	tools/ctags/ctags.c	/^static int skipInitializer( inEnumBody )$/;"	f	file:
skipOverCComment	tools/ctags/ctags.c	/^static int skipOverCComment()$/;"	f	file:
skipOverCplusComment	tools/ctags/ctags.c	/^static int skipOverCplusComment()$/;"	f	file:
skipParameterDeclarations	tools/ctags/ctags.c	/^static int skipParameterDeclarations( c )$/;"	f	file:
skipToCharacter	tools/ctags/ctags.c	/^static int skipToCharacter( findchar )$/;"	f	file:
skipToEndOfChar	tools/ctags/ctags.c	/^static int skipToEndOfChar()$/;"	f	file:
skipToEndOfString	tools/ctags/ctags.c	/^static int skipToEndOfString()$/;"	f	file:
skipToFormattedBraceMatch	tools/ctags/ctags.c	/^static void skipToFormattedBraceMatch()$/;"	f	file:
skipToMatch	tools/ctags/ctags.c	/^static boolean skipToMatch( pair )$/;"	f	file:
skipToNonWhite	tools/ctags/ctags.c	/^static int skipToNonWhite()$/;"	f	file:
skip_chars	src/search.c	/^skip_chars(cclass, dir)$/;"	f	file:
skip_label	src/misccmds.c	/^skip_label(lnum, pp, ind_maxcomment)$/;"	f	file:
skip_redraw	src/globals.h	/^EXTERN int		skip_redraw INIT(= FALSE);	\/* skip redraw once *\/$/;"	v
skip_regexp	src/regexp.c	/^skip_regexp(p, dirc)$/;"	f
skip_string	src/misccmds.c	/^skip_string(p)$/;"	f	file:
skip_to_option_part	src/misccmds.c	/^skip_to_option_part(p)$/;"	f
skipchr	src/regexp.c	/^skipchr()$/;"	f	file:
skipdigits	src/misccmds.c	/^skipdigits(p)$/;"	f
skiptowhite	src/misccmds.c	/^skiptowhite(p)$/;"	f
skiptowhite_esc	src/misccmds.c	/^skiptowhite_esc(p)$/;"	f
skipwhite	src/misccmds.c	/^skipwhite(p)$/;"	f
slash_adjust	src/msdos.c	/^slash_adjust(p)$/;"	f	file:
slash_adjust	src/unix.c	/^slash_adjust(p)$/;"	f	file:
smsg	src/message.c	/^smsg(s, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10)$/;"	f
socket	src/configure	/^socket()$/;"	f
sortTags	tools/ctags/ctags.c	/^static void sortTags()$/;"	f	file:
sourcing_lnum	src/globals.h	/^EXTERN linenr_t	sourcing_lnum INIT(= 0);	\/* line number of the source file *\/$/;"	v
sourcing_name	src/globals.h	/^EXTERN char_u	*sourcing_name INIT( = NULL);\/* name of error message source *\/$/;"	v
srcdir	src/config.mk	/^srcdir = .$/;"	m
start	src/gui.h	/^	FPOS		start;				\/* Start of selected area *\/$/;"	m	struct:GuiSelection
startPS	src/search.c	/^startPS(lnum, para, both)$/;"	f
start_arrow	src/edit.c	/^start_arrow(end_insert_pos)$/;"	f	file:
start_highlight	src/screen.c	/^start_highlight()$/;"	f
start_redo	src/getchar.c	/^start_redo(count, old_redo)$/;"	f
start_redo_ins	src/getchar.c	/^start_redo_ins()$/;"	f
start_stuff	src/getchar.c	/^start_stuff()$/;"	f	file:
start_visual_highlight	src/normal.c	/^start_visual_highlight()$/;"	f
starting	src/globals.h	/^EXTERN int		starting INIT(= TRUE);$/;"	v
starting	src/gui.h	/^	int			starting;			\/* GUI will start in a little while *\/$/;"	m	struct:Gui
startp	src/regexp.h	/^	char_u		   *startp[NSUBEXP];$/;"	m	struct:regexp
startspaces	src/ops.c	/^	int			startspaces;$/;"	m	struct:block_def	file:
starttermcap	src/term.c	/^starttermcap()$/;"	f
state	src/gui.h	/^	short_u		state;				\/* Current selection state *\/$/;"	m	struct:GuiSelection
state	tools/ctags/ctags.c	/^		drctv_state	state;$/;"	m	struct:__anon22::__anon23	file:
statement_t	tools/ctags/ctags.c	/^} statement_t;$/;"	t	typeref:struct:__anon15	file:
statics	tools/ctags/ctags.c	/^		boolean	statics;	\/* -iS  include static tags *\/$/;"	m	struct:__anon17::__anon18	file:
status_height	src/gui.h	/^	int			status_height;		\/* Height of status line *\/$/;"	m	struct:GuiScrollbar
status_redraw_all	src/screen.c	/^status_redraw_all()$/;"	f
stdout_notty	src/main.c	/^static int stdout_notty = FALSE;			\/* is stdout not a terminal? *\/$/;"	v	file:
stop_arrow	src/edit.c	/^stop_arrow()$/;"	f	file:
stop_highlight	src/screen.c	/^stop_highlight()$/;"	f
stop_insert	src/edit.c	/^stop_insert(end_insert_pos)$/;"	f	file:
stop_redo_ins	src/getchar.c	/^stop_redo_ins()$/;"	f
stoptermcap	src/term.c	/^stoptermcap()$/;"	f
str	src/edit.c	/^	char_u				*str;$/;"	m	struct:Completion	file:
strcspn	src/regexp.c	/^strcspn(s1, s2)$/;"	f	file:
strerror	src/unix.c	/^strerror(err)$/;"	f	file:
strings	src/gui.h	/^	char_u		*strings[4];		\/* Mapped string for each mode *\/$/;"	m	struct:GuiMenu
strlowcpy	src/msdos.c	/^strlowcpy(d, s)$/;"	f	file:
strnsave	src/alloc.c	/^strnsave(string, len)$/;"	f
strsave	src/alloc.c	/^strsave(string)$/;"	f
strsave_escaped	src/alloc.c	/^strsave_escaped(string, esc_chars)$/;"	f
strsize	src/charset.c	/^strsize(s)$/;"	f
stuffReadbuff	src/getchar.c	/^stuffReadbuff(s)$/;"	f
stuff_empty	src/getchar.c	/^stuff_empty()$/;"	f
stuff_inserted	src/edit.c	/^stuff_inserted(c, count, no_esc)$/;"	f
stuff_yank	src/ops.c	/^stuff_yank(bufname, p)$/;"	f	file:
stuffbuff	src/getchar.c	/^static struct buffheader stuffbuff = {{NULL, {NUL}}, NULL, 0, 0};$/;"	v	typeref:struct:buffheader	file:
stuffcharReadbuff	src/getchar.c	/^stuffcharReadbuff(c)$/;"	f
stuffnumReadbuff	src/getchar.c	/^stuffnumReadbuff(n)$/;"	f
stype	src/search.c	/^static int		stype;			\/* type of the word motion being performed *\/$/;"	v	file:
sub_nlines	src/csearch.c	/^static linenr_t		sub_nlines;		\/* total number of lines changed *\/$/;"	v	file:
sub_nsubs	src/csearch.c	/^static long			sub_nsubs;		\/* total number of substitutions *\/$/;"	v	file:
submenu_id	src/gui.h	/^	Widget		submenu_id;			\/* If this is submenu, add children here *\/$/;"	m	struct:GuiMenu
subst_magic	src/search.c	/^static int		subst_magic = TRUE;$/;"	v	file:
subst_no_scs	src/search.c	/^static int		subst_no_scs = FALSE;$/;"	v	file:
subst_pattern	src/search.c	/^static char_u	*subst_pattern = NULL;$/;"	v	file:
summarize	tools/mvi/mvi.c	/^summarize()$/;"	f	file:
swapchar	src/ops.c	/^swapchar(pos)$/;"	f
swapfile_info	src/memline.c	/^swapfile_info(fname)$/;"	f	file:
sys_gvimrc_fname	src/Makefile	/^	-@echo 'char_u *sys_gvimrc_fname = (char_u *)"$(SYS_GVIMRC_FILE)";' >> pathdef.c$/;"	m
sys_gvimrc_fname	src/Makefile	/^	-@echo 'char_u *sys_gvimrc_fname = (char_u *)SYS_GVIMRC_FILE;' >> pathdef.c$/;"	m
sys_gvimrc_fname	src/pathdef.c	/^char_u *sys_gvimrc_fname = (char_u *)"\/usr\/local\/share\/vim\/gvimrc";$/;"	v
sys_gvimrc_fname	src/pathdef.c	/^char_u *sys_gvimrc_fname = (char_u *)SYS_GVIMRC_FILE;$/;"	v
sys_vimrc_fname	src/Makefile	/^	-@echo 'char_u *sys_vimrc_fname = (char_u *)"$(SYS_VIMRC_FILE)";' >> pathdef.c$/;"	m
sys_vimrc_fname	src/Makefile	/^	-@echo 'char_u *sys_vimrc_fname = (char_u *)SYS_VIMRC_FILE;' >> pathdef.c$/;"	m
sys_vimrc_fname	src/pathdef.c	/^char_u *sys_vimrc_fname = (char_u *)"\/usr\/local\/share\/vim\/vimrc";$/;"	v
sys_vimrc_fname	src/pathdef.c	/^char_u *sys_vimrc_fname = (char_u *)SYS_VIMRC_FILE;$/;"	v
t_accept	src/configure	/^t_accept()$/;"	f
tag	tools/ctags/ctags.c	/^		tag_info	tag;		\/* the name associated with the directive *\/$/;"	m	struct:__anon22::__anon23	file:
tag	tools/ctags/ctags.c	/^	struct { size_t line, tag, file; } max;$/;"	m	struct:__anon19::__anon20	file:
tag	tools/ctags/ctags.c	/^	tag_info tag;			\/* information regarding current tag candidate *\/$/;"	m	struct:__anon15	file:
tagFile	tools/ctags/ctags.c	/^	const char *tagFile;	\/* -o  name of tags file *\/$/;"	m	struct:__anon17	file:
tagTypeName	tools/ctags/ctags.c	150;"	d	file:
tag_info	tools/ctags/ctags.c	/^} tag_info;$/;"	t	typeref:struct:__anon13	file:
tag_t	tools/ctags/ctags.c	/^} tag_t;$/;"	t	typeref:enum:__anon9	file:
taggy	src/structs.h	/^struct taggy$/;"	s
tagname	src/structs.h	/^	char_u			*tagname;			\/* tag name *\/$/;"	m	struct:taggy
tc_len	src/term.c	/^static int	tc_len = 0;		\/* current number of entries in termcodes[] *\/$/;"	v	file:
tc_max_len	src/term.c	/^static int	tc_max_len = 0;	\/* number of entries that termcodes[] can hold *\/$/;"	v	file:
term_console	src/globals.h	/^EXTERN int		term_console INIT(= FALSE);	\/* set to TRUE when consule used *\/$/;"	v
term_strings	src/term.c	/^char_u *(term_strings[KS_LAST + 1]);$/;"	v
termcap_active	src/globals.h	/^EXTERN int		termcap_active INIT(= FALSE);	\/* set by starttermcap() *\/$/;"	v
termcapinit	src/term.c	/^termcapinit(term)$/;"	f
termcode	src/term.c	/^struct termcode$/;"	s	file:
termcodes	src/term.c	/^} *termcodes = NULL;$/;"	v	typeref:struct:termcode
termleader	src/term.c	/^static char_u	termleader[256 + 1];			\/* for check_termcode() *\/$/;"	v	file:
test_for_current	src/tag.c	/^test_for_current(is_etag, fname, fname_end, tag_fname)$/;"	f	file:
test_for_static	src/tag.c	/^test_for_static(tagname, tagname_end, fname, fname_end)$/;"	f	file:
text_gc	src/gui.h	/^	GC			text_gc;$/;"	m	struct:Gui
textcol	src/ops.c	/^	colnr_t		textcol;$/;"	m	struct:block_def	file:
textlen	src/ops.c	/^	int			textlen;$/;"	m	struct:block_def	file:
textstart	src/ops.c	/^	char_u		*textstart;$/;"	m	struct:block_def	file:
tgetent	src/configure	/^tgetent()$/;"	f
tgetent_error	src/term.c	/^tgetent_error(tbuf, term)$/;"	f	file:
tgetstr	src/term.c	24;"	d	file:
tgetstr	src/term.c	51;"	d	file:
tgoto	src/term.c	/^tgoto(cm, x, y)$/;"	f
thickness	src/gui_at_sb.h	/^    Dimension	  thickness;	\/* either width or height *\/$/;"	m	struct:__anon2
thumb	src/gui_at_sb.h	/^    Pixmap	  thumb;	\/* thumb color *\/$/;"	m	struct:__anon2
thumbProc	src/gui_at_sb.h	/^    XtCallbackList thumbProc;	\/* jump (to position) scroll *\/$/;"	m	struct:__anon2
timer_id	src/gui_at_sb.h	/^    XtIntervalId  timer_id;     \/* autorepeat timer; remove on destruction *\/$/;"	m	struct:__anon2
tltoa	src/term.c	/^tltoa(i)$/;"	f	file:
token	tools/ctags/ctags.c	/^	token_t	token;			\/* the most recent type of token *\/$/;"	m	struct:__anon15	file:
token_t	tools/ctags/ctags.c	/^} token_t;$/;"	t	typeref:enum:__anon10	file:
top	src/gui.h	/^	int			top;				\/* Top of scroll bar (chars from row 0) *\/$/;"	m	struct:GuiScrollbar
top	src/gui_at_sb.h	/^    float	  top;		\/* What percent is above the win's top *\/$/;"	m	struct:__anon2
topLoc	src/gui_at_sb.h	/^    Position	  topLoc;	\/* Pixel that corresponds to top *\/$/;"	m	struct:__anon2
top_bot_msg	src/search.c	/^static char_u *top_bot_msg = (char_u *)"search hit TOP, continuing at BOTTOM";$/;"	v	file:
top_shadow_GC	src/gui_at_sb.h	/^    GC		top_shadow_GC;$/;"	m	struct:__anon2
top_shadow_contrast	src/gui_at_sb.h	/^    int		top_shadow_contrast;$/;"	m	struct:__anon2
top_shadow_pixel	src/gui_at_sb.h	/^    Pixel	top_shadow_pixel;$/;"	m	struct:__anon2
topmsg	src/tag.c	/^static char_u *topmsg = (char_u *)"at top of tag stack";$/;"	v	file:
total_mem_used	src/memfile.c	/^static long total_mem_used = 0;			\/* total memory used for memfiles *\/$/;"	v	file:
transchar	src/charset.c	/^transchar(c)$/;"	f
transchar_nonprint	src/charset.c	/^transchar_nonprint(buf, c)$/;"	f
trash_input_buf	src/unix.c	/^trash_input_buf()$/;"	f
trash_output_buf	src/term.c	/^trash_output_buf()$/;"	f
truncate_line	src/misccmds.c	/^truncate_line(fixpos)$/;"	f
ttest	src/term.c	/^ttest(pairs)$/;"	f
typebuf	src/globals.h	/^EXTERN char_u	*typebuf INIT(= NULL);	\/* buffer for typed characters *\/$/;"	v
typebuf_init	src/getchar.c	/^static char_u	typebuf_init[TYPELEN_INIT];			\/* initial typebuf *\/$/;"	v	file:
typebuf_typed	src/getchar.c	/^typebuf_typed()$/;"	f
typebuflen	src/globals.h	/^EXTERN int		typebuflen;				\/* size of typebuf *\/$/;"	v
typedefs	tools/ctags/ctags.c	/^		boolean	typedefs;	\/* -it  include tags for typedefs *\/$/;"	m	struct:__anon17::__anon18	file:
typelen	src/globals.h	/^EXTERN int		typelen;				\/* number of valid chars in typebuf *\/$/;"	v
typemaplen	src/getchar.c	/^static int		typemaplen = 0;		\/* nr of mapped characters in typebuf *\/$/;"	v	file:
typeoff	src/globals.h	/^EXTERN int		typeoff;				\/* current position in typebuf *\/$/;"	v
u_alloc_line	src/undo.c	/^u_alloc_line(size)$/;"	f	file:
u_blockalloc	src/undo.c	/^u_blockalloc(size)$/;"	f	file:
u_blockfree	src/undo.c	/^u_blockfree(buf)$/;"	f
u_clearall	src/undo.c	/^u_clearall(buf)$/;"	f
u_clearline	src/undo.c	/^u_clearline()$/;"	f
u_entry	src/structs.h	/^struct u_entry$/;"	s
u_free_line	src/undo.c	/^u_free_line(ptr)$/;"	f	file:
u_freeentry	src/undo.c	/^u_freeentry(uep, n)$/;"	f	file:
u_freelist	src/undo.c	/^u_freelist(uhp)$/;"	f	file:
u_getbot	src/undo.c	/^u_getbot()$/;"	f	file:
u_header	src/structs.h	/^struct u_header$/;"	s
u_inssub	src/undo.c	/^u_inssub(lnum)$/;"	f
u_newcount	src/undo.c	/^static long		u_newcount, u_oldcount;$/;"	v	file:
u_oldcount	src/undo.c	/^static long		u_newcount, u_oldcount;$/;"	v	file:
u_redo	src/undo.c	/^u_redo(count)$/;"	f
u_save	src/undo.c	/^u_save(top, bot)$/;"	f
u_save_cursor	src/undo.c	/^u_save_cursor()$/;"	f
u_save_line	src/undo.c	/^u_save_line(lnum)$/;"	f	file:
u_savecommon	src/undo.c	/^u_savecommon(top, bot, newbot)$/;"	f	file:
u_savedel	src/undo.c	/^u_savedel(lnum, nlines)$/;"	f
u_saveline	src/undo.c	/^u_saveline(lnum)$/;"	f
u_savesub	src/undo.c	/^u_savesub(lnum)$/;"	f
u_sync	src/undo.c	/^u_sync()$/;"	f
u_unchanged	src/undo.c	/^u_unchanged(buf)$/;"	f
u_undo	src/undo.c	/^u_undo(count)$/;"	f
u_undo_end	src/undo.c	/^u_undo_end()$/;"	f	file:
u_undoline	src/undo.c	/^u_undoline()$/;"	f
u_undoredo	src/undo.c	/^u_undoredo()$/;"	f	file:
ue_array	src/structs.h	/^	char_u			**ue_array;	\/* array of lines in undo block *\/$/;"	m	struct:u_entry
ue_bot	src/structs.h	/^	linenr_t		ue_bot;		\/* number of line below undo block *\/$/;"	m	struct:u_entry
ue_lcount	src/structs.h	/^	linenr_t		ue_lcount;	\/* linecount when u_save called *\/$/;"	m	struct:u_entry
ue_next	src/structs.h	/^	struct u_entry	*ue_next;	\/* pointer to next entry in list *\/$/;"	m	struct:u_entry	typeref:struct:u_entry::u_entry
ue_size	src/structs.h	/^	long			ue_size;	\/* number of lines in ue_array *\/$/;"	m	struct:u_entry
ue_top	src/structs.h	/^	linenr_t		ue_top;		\/* number of line above undo block *\/$/;"	m	struct:u_entry
uh_cursor	src/structs.h	/^	FPOS			 uh_cursor;	\/* cursor position before saving *\/$/;"	m	struct:u_header
uh_entry	src/structs.h	/^	struct u_entry	*uh_entry;	\/* pointer to first entry *\/$/;"	m	struct:u_header	typeref:struct:u_header::u_entry
uh_flags	src/structs.h	/^	int				 uh_flags;	\/* see below *\/$/;"	m	struct:u_header
uh_namedm	src/structs.h	/^	FPOS			 uh_namedm[NMARKS];	\/* marks before undo\/after redo *\/$/;"	m	struct:u_header
uh_next	src/structs.h	/^	struct u_header	*uh_next;	\/* pointer to next header in list *\/$/;"	m	struct:u_header	typeref:struct:u_header::u_header
uh_prev	src/structs.h	/^	struct u_header	*uh_prev;	\/* pointer to previous header in list *\/$/;"	m	struct:u_header	typeref:struct:u_header::u_header
uid_t	src/conf_os2.h	80;"	d
underline_pixel	src/gui.h	/^	Pixel		underline_pixel;	\/* Pixel value of underlined text *\/$/;"	m	struct:Gui
undisplay_dollar	src/screen.c	/^undisplay_dollar()$/;"	f
undo_off	src/globals.h	/^EXTERN int		undo_off INIT(= FALSE);		\/* undo switched off for now *\/$/;"	v
ungetch	tools/ctags/ctags.c	/^	int		ungetch;			\/* an ungotten character, if any *\/$/;"	m	struct:__anon22	file:
ungetch	tools/ctags/ctags.c	/^	int		ungetch;		\/* a single character that was ungotten *\/$/;"	m	struct:__anon21	file:
ungetchr	src/regexp.c	/^ungetchr()$/;"	f	file:
unhighlight	src/globals.h	/^EXTERN char_u	*unhighlight INIT(= NULL);	\/* string for end of highlighting *\/$/;"	v
unregc	src/regexp.c	/^unregc()$/;"	f	file:
unset_Changed	src/misccmds.c	/^unset_Changed(buf)$/;"	f
unshift_special_key	src/tables.c	/^unshift_special_key(p)$/;"	f
update	src/gui.h	/^	int			update[2];			\/* What kind of update is required? *\/$/;"	m	struct:GuiScrollbar
updateScreen	src/screen.c	/^updateScreen(type)$/;"	f
updateWindow	src/screen.c	/^updateWindow(wp)$/;"	f
update_curbuf	src/screen.c	/^update_curbuf(type)$/;"	f
updateline	src/screen.c	/^updateline()$/;"	f
updatescript	src/getchar.c	/^updatescript(c)$/;"	f
usage	src/main.c	/^usage(n, str)$/;"	f	file:
usage	tools/mvi/mvi.c	/^usage()$/;"	f	file:
use_viminfo	src/globals.h	/^EXTERN char_u	*use_viminfo INIT(= NULL);	\/* name of viminfo file to use *\/$/;"	v
value	src/gui.h	/^	int			value;				\/* Represents top line number visible *\/$/;"	m	struct:GuiScrollbar
var	src/option.c	/^	char_u		*var;			\/* pointer to variable *\/$/;"	m	struct:option	file:
variables	tools/ctags/ctags.c	/^		boolean	variables;	\/* -iv  include tags for variables *\/$/;"	m	struct:__anon17::__anon18	file:
version	tools/xxd/xxd.c	/^char version[] = "xxd V1.1m 21may96 by Juergen Weigert";$/;"	v
version_msg	src/version.c	/^version_msg(s)$/;"	f	file:
vgetc	src/getchar.c	/^vgetc()$/;"	f
vgetorpeek	src/getchar.c	/^vgetorpeek(advance)$/;"	f	file:
vim_beep	src/misccmds.c	/^vim_beep()$/;"	f
vim_chdir	src/msdos.c	/^vim_chdir(path)$/;"	f
vim_chdir	src/vim.h	520;"	d
vim_fexists	src/misccmds.c	/^vim_fexists(fname)$/;"	f
vim_fgets	src/fileio.c	/^vim_fgets(buf, size, fp)$/;"	f
vim_free	src/alloc.c	/^vim_free(x)$/;"	f
vim_getenv	src/msdos.c	/^vim_getenv(var)$/;"	f
vim_getenv	src/vim.h	493;"	d
vim_isspace	src/alloc.c	/^vim_isspace(x)$/;"	f
vim_iswhite	src/vim.h	527;"	d
vim_memmove	src/alloc.c	/^vim_memmove(dst_arg, src_arg, len)$/;"	f
vim_memmove	src/unix.h	235;"	d
vim_memmove	src/unix.h	238;"	d
vim_memmove	src/unix.h	241;"	d
vim_memmove	src/vim.h	484;"	d
vim_memset	src/alloc.c	/^vim_memset(ptr, c, size)$/;"	f
vim_memset	src/vim.h	511;"	d
vim_regcomp	src/regexp.c	/^vim_regcomp(exp)$/;"	f
vim_regexec	src/regexp.c	/^vim_regexec(prog, string, at_bol)$/;"	f
vim_regsub	src/regsub.c	/^vim_regsub(prog, source, dest, copy, magic)$/;"	f
vim_remove	src/archie.h	19;"	d
vim_remove	src/msdos.c	/^vim_remove(name)$/;"	f
vim_remove	src/unix.h	59;"	d
vim_rename	src/fileio.c	/^vim_rename(from, to)$/;"	f
vim_strchr	src/alloc.c	/^vim_strchr(string, n)$/;"	f
vim_strncpy	src/cmdline.c	/^vim_strncpy(to, from, len)$/;"	f	file:
vim_strnicmp	src/alloc.c	/^vim_strnicmp(s1, s2, len)$/;"	f
vim_strrchr	src/alloc.c	/^vim_strrchr(string, n)$/;"	f
viminfo_add_at_front	src/cmdline.c	/^static int		viminfo_add_at_front = FALSE;$/;"	v	file:
viminfo_filename	src/cmdcmds.c	/^viminfo_filename(file)$/;"	f	file:
viminfo_hisidx	src/cmdline.c	/^static int		viminfo_hisidx[2] = {0, 0};$/;"	v	file:
viminfo_hislen	src/cmdline.c	/^static int		viminfo_hislen = 0;$/;"	v	file:
viminfo_history	src/cmdline.c	/^static char_u **viminfo_history[2] = {NULL, NULL};$/;"	v	file:
viminfo_readstring	src/cmdcmds.c	/^viminfo_readstring(p)$/;"	f
viminfo_writestring	src/cmdcmds.c	/^viminfo_writestring(fd, p)$/;"	f
visibility	src/gui.h	/^	int			visibility;			\/* Is window partially\/fully obscured? *\/$/;"	m	struct:Gui
vpeekc	src/getchar.c	/^vpeekc()$/;"	f
vungetc	src/getchar.c	/^vungetc(c)		\/* unget one character (can only be done once!) *\/$/;"	f
w_alt_fnum	src/structs.h	/^	int			w_alt_fnum;			\/* alternate file (for # and CTRL-^) *\/$/;"	m	struct:window
w_arg_idx	src/structs.h	/^	int			w_arg_idx;			\/* current index in argument list *\/$/;"	m	struct:window
w_arg_idx_invalid	src/structs.h	/^	int			w_arg_idx_invalid;	\/* editing another file then w_arg_idx *\/$/;"	m	struct:window
w_botline	src/structs.h	/^	linenr_t	w_botline;			\/* number of the line below the bottom$/;"	m	struct:window
w_buffer	src/structs.h	/^	BUF			*w_buffer; 			\/* buffer we are a window into *\/$/;"	m	struct:window
w_cline_height	src/structs.h	/^	int			w_cline_height;		\/* current size of cursor line *\/$/;"	m	struct:window
w_cline_row	src/structs.h	/^	int			w_cline_row;		\/* starting row of the cursor line *\/$/;"	m	struct:window
w_col	src/structs.h	/^	int			w_row, w_col;		\/* cursor's position in window *\/$/;"	m	struct:window
w_cursor	src/structs.h	/^	FPOS		w_cursor;			\/* cursor's position in buffer *\/$/;"	m	struct:window
w_curswant	src/structs.h	/^	colnr_t		w_curswant;			\/* The column we'd like to be at. *\/$/;"	m	struct:window
w_empty_rows	src/structs.h	/^	int			w_empty_rows;		\/* number of ~ rows in window *\/$/;"	m	struct:window
w_height	src/structs.h	/^	int			w_height;			\/* number of rows in window, excluding$/;"	m	struct:window
w_jumplist	src/structs.h	/^	struct filemark w_jumplist[JUMPLISTSIZE];$/;"	m	struct:window	typeref:struct:window::filemark
w_jumplistidx	src/structs.h	/^	int				w_jumplistidx;				\/* current position *\/$/;"	m	struct:window
w_jumplistlen	src/structs.h	/^	int 			w_jumplistlen;				\/* number of active entries *\/$/;"	m	struct:window
w_leftcol	src/structs.h	/^	colnr_t		w_leftcol;			\/* starting column of the screen *\/$/;"	m	struct:window
w_lsize	src/structs.h	/^	char_u 	 	*w_lsize;			\/* array of line heights *\/$/;"	m	struct:window
w_lsize_lnum	src/structs.h	/^	linenr_t 	*w_lsize_lnum;		\/* array of line numbers for w_lsize *\/$/;"	m	struct:window
w_lsize_valid	src/structs.h	/^	int		 	w_lsize_valid;		\/* nr. of valid LineSizes *\/$/;"	m	struct:window
w_next	src/structs.h	/^	WIN			*w_next;			\/* link to next window (below) *\/$/;"	m	struct:window
w_old_cursor_lnum	src/structs.h	/^	linenr_t	w_old_cursor_lnum;	\/* last known end of visual part *\/$/;"	m	struct:window
w_old_cursor_vcol	src/structs.h	/^	colnr_t		w_old_cursor_vcol;	\/* last known end of visual part *\/$/;"	m	struct:window
w_old_curswant	src/structs.h	/^	colnr_t		w_old_curswant;		\/* last known value of Curswant *\/$/;"	m	struct:window
w_old_visual_lnum	src/structs.h	/^	linenr_t	w_old_visual_lnum;	\/* last known start of visual part *\/$/;"	m	struct:window
w_p_lbr	src/structs.h	/^				w_p_lbr;$/;"	m	struct:window
w_p_list	src/structs.h	/^	int			w_p_list,$/;"	m	struct:window
w_p_nu	src/structs.h	/^				w_p_nu,$/;"	m	struct:window
w_p_rl	src/structs.h	/^				w_p_rl,$/;"	m	struct:window
w_p_scroll	src/structs.h	/^	long		w_p_scroll;$/;"	m	struct:window
w_p_wrap	src/structs.h	/^				w_p_wrap,$/;"	m	struct:window
w_pcmark	src/structs.h	/^	FPOS		w_pcmark;			\/* previous context mark *\/$/;"	m	struct:window
w_prev	src/structs.h	/^	WIN			*w_prev;			\/* link to previous window (above) *\/$/;"	m	struct:window
w_prev_pcmark	src/structs.h	/^	FPOS		w_prev_pcmark;		\/* previous w_pcmark *\/$/;"	m	struct:window
w_redr_status	src/structs.h	/^	int			w_redr_status;		\/* if TRUE status line must be redrawn *\/$/;"	m	struct:window
w_redr_type	src/structs.h	/^	int			w_redr_type;		\/* type of redraw to be performed on win *\/$/;"	m	struct:window
w_row	src/structs.h	/^	int			w_row, w_col;		\/* cursor's position in window *\/$/;"	m	struct:window
w_scrollbar	src/structs.h	/^	GuiScrollbar	w_scrollbar;				\/* Scrollbar for this window *\/$/;"	m	struct:window
w_set_curswant	src/structs.h	/^	int			w_set_curswant;		\/* If set, then update w_curswant *\/$/;"	m	struct:window
w_status_height	src/structs.h	/^	int			w_status_height;	\/* number of status lines (0 or 1) *\/$/;"	m	struct:window
w_tagstack	src/structs.h	/^	struct taggy	w_tagstack[TAGSTACKSIZE];	\/* the tag stack *\/$/;"	m	struct:window	typeref:struct:window::taggy
w_tagstackidx	src/structs.h	/^	int				w_tagstackidx;				\/* idx just below activ entry *\/$/;"	m	struct:window
w_tagstacklen	src/structs.h	/^	int				w_tagstacklen;				\/* number of tags on stack *\/$/;"	m	struct:window
w_topline	src/structs.h	/^	linenr_t	w_topline;			\/* number of the line at the top of$/;"	m	struct:window
w_virtcol	src/structs.h	/^	colnr_t		w_virtcol;			\/* column number of the file's actual *\/$/;"	m	struct:window
w_winpos	src/structs.h	/^	int			w_winpos;			\/* row of topline of window in screen *\/$/;"	m	struct:window
wait_return	src/message.c	/^wait_return(redraw)$/;"	f
want_start	src/search.c	/^static int		want_start;				\/* looking for start of line? *\/$/;"	v	file:
warned	tools/ctags/ctags.c	/^	boolean warned;			\/* format warning kludge *\/$/;"	m	struct:__anon21	file:
warnings	tools/ctags/ctags.c	/^	boolean warnings;		\/* -w  generate warnings about duplicate tags *\/$/;"	m	struct:__anon17	file:
wasPathChosen	tools/ctags/ctags.c	/^static boolean wasPathChosen()$/;"	f	file:
where_paste_started	src/globals.h	/^EXTERN FPOS		where_paste_started;$/;"	v
which_scrollbars	src/gui.h	/^	int			which_scrollbars[3];\/* Which scrollbar boxes are active? *\/$/;"	m	struct:Gui
wid	src/gui.h	/^	Window		wid;				\/* Window id of text area *\/$/;"	m	struct:Gui
win_alloc	src/window.c	/^win_alloc(after)$/;"	f
win_alloc_lsize	src/window.c	/^win_alloc_lsize(wp)$/;"	f
win_append	src/window.c	/^win_append(after, wp)$/;"	f	file:
win_chartabsize	src/charset.c	/^win_chartabsize(wp, c, col)$/;"	f
win_comp_pos	src/window.c	/^win_comp_pos()$/;"	f	file:
win_comp_scroll	src/window.c	/^win_comp_scroll(wp)$/;"	f
win_copy_options	src/option.c	/^win_copy_options(wp_from, wp_to)$/;"	f
win_count	src/window.c	/^win_count()$/;"	f
win_del_lines	src/screen.c	/^win_del_lines(wp, row, line_count, invalid, mayclear)$/;"	f
win_drag_status_line	src/window.c	/^win_drag_status_line(offset)$/;"	f
win_enter	src/window.c	/^win_enter(wp, undo_sync)$/;"	f
win_equal	src/window.c	/^win_equal(next_curwin, redraw)$/;"	f
win_exchange	src/window.c	/^win_exchange(Prenum)$/;"	f	file:
win_free	src/window.c	/^win_free(wp)$/;"	f
win_free_lsize	src/window.c	/^win_free_lsize(wp)$/;"	f
win_init	src/window.c	/^win_init(wp)$/;"	f
win_ins_lines	src/screen.c	/^win_ins_lines(wp, row, line_count, invalid, mayclear)$/;"	f
win_lbr_chartabsize	src/charset.c	/^win_lbr_chartabsize(wp, s, col, head)$/;"	f
win_line	src/screen.c	/^win_line(wp, lnum, startrow, endrow)$/;"	f	file:
win_new_height	src/window.c	/^win_new_height(wp, height)$/;"	f	file:
win_redr_ruler	src/screen.c	/^win_redr_ruler(wp, always)$/;"	f
win_redr_status	src/screen.c	/^win_redr_status(wp)$/;"	f
win_remove	src/window.c	/^win_remove(wp)$/;"	f	file:
win_rest_invalid	src/screen.c	/^win_rest_invalid(wp)$/;"	f
win_rotate	src/window.c	/^win_rotate(upwards, count)$/;"	f	file:
win_setheight	src/window.c	/^win_setheight(height)$/;"	f
win_split	src/window.c	/^win_split(new_height, redraw)$/;"	f
win_update	src/screen.c	/^win_update(wp)$/;"	f
windgoto	src/term.c	/^windgoto(row, col)$/;"	f
window	src/structs.h	/^struct window$/;"	s
winlnum	src/structs.h	/^struct winlnum$/;"	s
wl_lnum	src/structs.h	/^	linenr_t	 wl_lnum;			\/* last cursor line in the file *\/$/;"	m	struct:winlnum
wl_next	src/structs.h	/^	WINLNUM		*wl_next;			\/* next entry or NULL for last entry *\/$/;"	m	struct:winlnum
wl_prev	src/structs.h	/^	WINLNUM		*wl_prev;			\/* previous entry or NULL for first entry *\/$/;"	m	struct:winlnum
wl_win	src/structs.h	/^	WIN			*wl_win;			\/* pointer to window that did set wl_lnum *\/$/;"	m	struct:winlnum
word_end_col	src/gui.h	/^	short_u		word_end_col;$/;"	m	struct:GuiSelection
word_start_col	src/gui.h	/^	short_u		word_start_col;$/;"	m	struct:GuiSelection
writeXrefEntry	tools/ctags/ctags.c	/^static void writeXrefEntry( tag, tagType )$/;"	f	file:
write_buf	src/fileio.c	/^write_buf(fd, buf, len)$/;"	f	file:
write_no_eol_lnum	src/fileio.c	/^static linenr_t	write_no_eol_lnum = 0; 	\/* non-zero lnum when last line of$/;"	v	file:
write_viminfo	src/cmdcmds.c	/^write_viminfo(file, force)$/;"	f
write_viminfo_filemarks	src/mark.c	/^write_viminfo_filemarks(fp)$/;"	f
write_viminfo_history	src/cmdline.c	/^write_viminfo_history(fp)$/;"	f
write_viminfo_marks	src/mark.c	/^write_viminfo_marks(fp_out)$/;"	f
write_viminfo_registers	src/ops.c	/^write_viminfo_registers(fp)$/;"	f
write_viminfo_search_pattern	src/search.c	/^write_viminfo_search_pattern(fp)$/;"	f
write_viminfo_sub_string	src/csearch.c	/^write_viminfo_sub_string(fp)$/;"	f
writemp	tools/mvi/mvi.c	/^writemp( tmp, head, argv )$/;"	f	file:
x11_display	src/unix.c	/^Display		*x11_display = NULL;$/;"	v
x11_window	src/unix.c	/^Window		x11_window = 0;$/;"	v
x_error_check	src/unix.c	/^x_error_check(dpy, error_event)$/;"	f	file:
x_error_handler	src/unix.c	/^x_error_handler(dpy, error_event)$/;"	f	file:
xref	tools/ctags/ctags.c	/^	boolean xref;			\/* -x  generate xref output instead *\/$/;"	m	struct:__anon17	file:
y_array	src/ops.c	/^	char_u		**y_array;		\/* pointer to array of line pointers *\/$/;"	m	struct:yankbuf	file:
y_buf	src/ops.c	/^} y_buf[NUM_REGISTERS];$/;"	v	typeref:struct:yankbuf	file:
y_current	src/ops.c	/^static struct	yankbuf *y_current;			\/* ptr to current yank buffer *\/$/;"	v	typeref:struct:yankbuf	file:
y_previous	src/ops.c	/^static struct	yankbuf *y_previous = NULL; \/* ptr to last written yank buffr *\/$/;"	v	typeref:struct:yankbuf	file:
y_size	src/ops.c	/^	linenr_t 	y_size; 		\/* number of lines in y_array *\/$/;"	m	struct:yankbuf	file:
y_type	src/ops.c	/^	char_u		y_type; 		\/* MLINE, MCHAR or MBLOCK *\/$/;"	m	struct:yankbuf	file:
yank_buffer_mline	src/ops.c	/^yank_buffer_mline()$/;"	f
yankappend	src/ops.c	/^static int		yankappend;					\/* TRUE when appending *\/$/;"	v	file:
yankbuf	src/ops.c	/^static struct yankbuf$/;"	s	file:
yankbuffer	src/ops.h	/^EXTERN int		yankbuffer INIT(= 0);	\/* current yank buffer *\/$/;"	v
